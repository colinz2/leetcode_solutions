{
 "info_node": {
  "user_name": "colinjxc",
  "num_solved": 342,
  "num_total": 2584,
  "ac_easy": 176,
  "ac_medium": 154,
  "ac_hard": 12
 },
 "ac_problems": {
  "1-bit-and-2-bit-characters": {
   "stat": {
    "question_id": 717,
    "question__title": "1-bit and 2-bit Characters",
    "question__title_slug": "1-bit-and-2-bit-characters",
    "question__hide": false,
    "total_acs": 61543,
    "total_submitted": 111006,
    "total_column_articles": 740,
    "frontend_question_id": "717",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6292278529,
   "progress": 53.5079246421
  },
  "3sum": {
   "stat": {
    "question_id": 15,
    "question__title": "3Sum",
    "question__title_slug": "3sum",
    "question__hide": false,
    "total_acs": 899345,
    "total_submitted": 2565095,
    "total_column_articles": 4137,
    "frontend_question_id": "15",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.3062506452,
   "progress": 87.6373398984
  },
  "N6YdxV": {
   "stat": {
    "question_id": 1000332,
    "question__title": "查找插入位置",
    "question__title_slug": "N6YdxV",
    "question__hide": false,
    "total_acs": 11151,
    "total_submitted": 22216,
    "total_column_articles": 137,
    "frontend_question_id": "剑指 Offer II 068",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "SLwz0R": {
   "stat": {
    "question_id": 1000257,
    "question__title": "删除链表的倒数第 n 个结点",
    "question__title_slug": "SLwz0R",
    "question__hide": false,
    "total_acs": 19922,
    "total_submitted": 37917,
    "total_column_articles": 240,
    "frontend_question_id": "剑指 Offer II 021",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.1902255582,
   "progress": 44.5737040205
  },
  "UHnkqh": {
   "stat": {
    "question_id": 1000260,
    "question__title": "反转链表",
    "question__title_slug": "UHnkqh",
    "question__hide": false,
    "total_acs": 40053,
    "total_submitted": 53183,
    "total_column_articles": 283,
    "frontend_question_id": "剑指 Offer II 024",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2322646104,
   "progress": 45.429248904
  },
  "aMhZSa": {
   "stat": {
    "question_id": 1000263,
    "question__title": "回文链表",
    "question__title_slug": "aMhZSa",
    "question__hide": false,
    "total_acs": 24657,
    "total_submitted": 39928,
    "total_column_articles": 257,
    "frontend_question_id": "剑指 Offer II 027",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.9318605719,
   "progress": 39.3156682056
  },
  "add-binary": {
   "stat": {
    "question_id": 67,
    "question__title": "Add Binary",
    "question__title_slug": "add-binary",
    "question__hide": false,
    "total_acs": 237394,
    "total_submitted": 440176,
    "total_column_articles": 2153,
    "frontend_question_id": "67",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.4008330355,
   "progress": 69.2110109774
  },
  "add-digits": {
   "stat": {
    "question_id": 258,
    "question__title": "Add Digits",
    "question__title_slug": "add-digits",
    "question__hide": false,
    "total_acs": 133187,
    "total_submitted": 187462,
    "total_column_articles": 1128,
    "frontend_question_id": "258",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5038958547,
   "progress": 50.9572689021
  },
  "add-strings": {
   "stat": {
    "question_id": 415,
    "question__title": "Add Strings",
    "question__title_slug": "add-strings",
    "question__hide": false,
    "total_acs": 192025,
    "total_submitted": 351418,
    "total_column_articles": 1335,
    "frontend_question_id": "415",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.151579999,
   "progress": 64.1384142142
  },
  "add-two-numbers": {
   "stat": {
    "question_id": 2,
    "question__title": "Add Two Numbers",
    "question__title_slug": "add-two-numbers",
    "question__hide": false,
    "total_acs": 1271654,
    "total_submitted": 3060888,
    "total_column_articles": 9065,
    "frontend_question_id": "2",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.8613626083,
   "progress": 98.9345308424
  },
  "add-two-numbers-ii": {
   "stat": {
    "question_id": 445,
    "question__title": "Add Two Numbers II",
    "question__title_slug": "add-two-numbers-ii",
    "question__hide": false,
    "total_acs": 97003,
    "total_submitted": 163252,
    "total_column_articles": 1090,
    "frontend_question_id": "445",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2206072023,
   "progress": 45.1920067368
  },
  "arranging-coins": {
   "stat": {
    "question_id": 441,
    "question__title": "Arranging Coins",
    "question__title_slug": "arranging-coins",
    "question__hide": false,
    "total_acs": 87712,
    "total_submitted": 191480,
    "total_column_articles": 840,
    "frontend_question_id": "441",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5269938558,
   "progress": 51.4273407921
  },
  "assign-cookies": {
   "stat": {
    "question_id": 455,
    "question__title": "Assign Cookies",
    "question__title_slug": "assign-cookies",
    "question__hide": false,
    "total_acs": 202724,
    "total_submitted": 353630,
    "total_column_articles": 1592,
    "frontend_question_id": "455",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.9920065797,
   "progress": 60.8909046901
  },
  "average-of-levels-in-binary-tree": {
   "stat": {
    "question_id": 637,
    "question__title": "Average of Levels in Binary Tree",
    "question__title_slug": "average-of-levels-in-binary-tree",
    "question__hide": false,
    "total_acs": 95563,
    "total_submitted": 137656,
    "total_column_articles": 798,
    "frontend_question_id": "637",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.4580762198,
   "progress": 29.6735912055
  },
  "balanced-binary-tree": {
   "stat": {
    "question_id": 110,
    "question__title": "Balanced Binary Tree",
    "question__title_slug": "balanced-binary-tree",
    "question__hide": false,
    "total_acs": 335494,
    "total_submitted": 590163,
    "total_column_articles": 1867,
    "frontend_question_id": "110",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6936033256,
   "progress": 54.8180423402
  },
  "best-time-to-buy-and-sell-stock": {
   "stat": {
    "question_id": 121,
    "question__title": "Best Time to Buy and Sell Stock",
    "question__title_slug": "best-time-to-buy-and-sell-stock",
    "question__hide": false,
    "total_acs": 743440,
    "total_submitted": 1288933,
    "total_column_articles": 4424,
    "frontend_question_id": "121",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 4.1620514573,
   "progress": 84.7027143317
  },
  "best-time-to-buy-and-sell-stock-ii": {
   "stat": {
    "question_id": 122,
    "question__title": "Best Time to Buy and Sell Stock II",
    "question__title_slug": "best-time-to-buy-and-sell-stock-ii",
    "question__hide": false,
    "total_acs": 600649,
    "total_submitted": 857734,
    "total_column_articles": 3343,
    "frontend_question_id": "122",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.1282980314,
   "progress": 63.6645983877
  },
  "binary-gap": {
   "stat": {
    "question_id": 899,
    "question__title": "Binary Gap",
    "question__title_slug": "binary-gap",
    "question__hide": false,
    "total_acs": 18458,
    "total_submitted": 29307,
    "total_column_articles": 270,
    "frontend_question_id": "868",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "binary-prefix-divisible-by-5": {
   "stat": {
    "question_id": 1071,
    "question__title": "Binary Prefix Divisible By 5",
    "question__title_slug": "binary-prefix-divisible-by-5",
    "question__hide": false,
    "total_acs": 45910,
    "total_submitted": 89221,
    "total_column_articles": 401,
    "frontend_question_id": "1018",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 0,
   "progress": 0
  },
  "binary-search": {
   "stat": {
    "question_id": 792,
    "question__title": "Binary Search",
    "question__title_slug": "binary-search",
    "question__hide": false,
    "total_acs": 532777,
    "total_submitted": 981272,
    "total_column_articles": 2692,
    "frontend_question_id": "704",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.8090084718,
   "progress": 97.8690616847
  },
  "binary-search-tree-iterator": {
   "stat": {
    "question_id": 173,
    "question__title": "Binary Search Tree Iterator",
    "question__title_slug": "binary-search-tree-iterator",
    "question__hide": false,
    "total_acs": 88797,
    "total_submitted": 109835,
    "total_column_articles": 746,
    "frontend_question_id": "173",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.1370163737,
   "progress": 43.4908336148
  },
  "binary-search-tree-to-greater-sum-tree": {
   "stat": {
    "question_id": 1114,
    "question__title": "Binary Search Tree to Greater Sum Tree",
    "question__title_slug": "binary-search-tree-to-greater-sum-tree",
    "question__hide": false,
    "total_acs": 31965,
    "total_submitted": 39938,
    "total_column_articles": 389,
    "frontend_question_id": "1038",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.1266071206,
   "progress": 22.9277994463
  },
  "binary-tree-inorder-traversal": {
   "stat": {
    "question_id": 94,
    "question__title": "Binary Tree Inorder Traversal",
    "question__title_slug": "binary-tree-inorder-traversal",
    "question__hide": false,
    "total_acs": 767689,
    "total_submitted": 1013370,
    "total_column_articles": 3045,
    "frontend_question_id": "94",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.7805052338,
   "progress": 56.586599886
  },
  "binary-tree-level-order-traversal": {
   "stat": {
    "question_id": 102,
    "question__title": "Binary Tree Level Order Traversal",
    "question__title_slug": "binary-tree-level-order-traversal",
    "question__hide": false,
    "total_acs": 534097,
    "total_submitted": 826817,
    "total_column_articles": 3264,
    "frontend_question_id": "102",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 4.1692160601,
   "progress": 84.8485225494
  },
  "binary-tree-level-order-traversal-ii": {
   "stat": {
    "question_id": 107,
    "question__title": "Binary Tree Level Order Traversal II",
    "question__title_slug": "binary-tree-level-order-traversal-ii",
    "question__hide": false,
    "total_acs": 199533,
    "total_submitted": 281247,
    "total_column_articles": 1577,
    "frontend_question_id": "107",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.4020785864,
   "progress": 48.8851659795
  },
  "binary-tree-maximum-path-sum": {
   "stat": {
    "question_id": 124,
    "question__title": "Binary Tree Maximum Path Sum",
    "question__title_slug": "binary-tree-maximum-path-sum",
    "question__hide": false,
    "total_acs": 214761,
    "total_submitted": 478496,
    "total_column_articles": 1407,
    "frontend_question_id": "124",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.9149759625,
   "progress": 79.6744331423
  },
  "binary-tree-paths": {
   "stat": {
    "question_id": 257,
    "question__title": "Binary Tree Paths",
    "question__title_slug": "binary-tree-paths",
    "question__hide": false,
    "total_acs": 192209,
    "total_submitted": 277037,
    "total_column_articles": 1375,
    "frontend_question_id": "257",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7888818953,
   "progress": 56.7570749442
  },
  "binary-tree-postorder-traversal": {
   "stat": {
    "question_id": 145,
    "question__title": "Binary Tree Postorder Traversal",
    "question__title_slug": "binary-tree-postorder-traversal",
    "question__hide": false,
    "total_acs": 409802,
    "total_submitted": 541899,
    "total_column_articles": 1986,
    "frontend_question_id": "145",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.0135591381,
   "progress": 61.3295249751
  },
  "binary-tree-preorder-traversal": {
   "stat": {
    "question_id": 144,
    "question__title": "Binary Tree Preorder Traversal",
    "question__title_slug": "binary-tree-preorder-traversal",
    "question__hide": false,
    "total_acs": 560974,
    "total_submitted": 790963,
    "total_column_articles": 2426,
    "frontend_question_id": "144",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.4716700147,
   "progress": 50.3014345993
  },
  "binary-tree-pruning": {
   "stat": {
    "question_id": 832,
    "question__title": "Binary Tree Pruning",
    "question__title_slug": "binary-tree-pruning",
    "question__hide": false,
    "total_acs": 27206,
    "total_submitted": 38777,
    "total_column_articles": 411,
    "frontend_question_id": "814",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.4889428678,
   "progress": 30.3017643295
  },
  "binary-tree-right-side-view": {
   "stat": {
    "question_id": 199,
    "question__title": "Binary Tree Right Side View",
    "question__title_slug": "binary-tree-right-side-view",
    "question__hide": false,
    "total_acs": 190911,
    "total_submitted": 291810,
    "total_column_articles": 2029,
    "frontend_question_id": "199",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7868507779,
   "progress": 56.7157392809
  },
  "binary-tree-zigzag-level-order-traversal": {
   "stat": {
    "question_id": 103,
    "question__title": "Binary Tree Zigzag Level Order Traversal",
    "question__title_slug": "binary-tree-zigzag-level-order-traversal",
    "question__hide": false,
    "total_acs": 221957,
    "total_submitted": 387667,
    "total_column_articles": 1945,
    "frontend_question_id": "103",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.1575820577,
   "progress": 64.2605632721
  },
  "build-an-array-with-stack-operations": {
   "stat": {
    "question_id": 1552,
    "question__title": "Build an Array With Stack Operations",
    "question__title_slug": "build-an-array-with-stack-operations",
    "question__hide": false,
    "total_acs": 20396,
    "total_submitted": 31384,
    "total_column_articles": 415,
    "frontend_question_id": "1441",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "building-h2o": {
   "stat": {
    "question_id": 1186,
    "question__title": "Building H2O",
    "question__title_slug": "building-h2o",
    "question__hide": false,
    "total_acs": 20093,
    "total_submitted": 38204,
    "total_column_articles": 273,
    "frontend_question_id": "1117",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.4580762198,
   "progress": 29.6735912055
  },
  "check-if-a-number-is-majority-element-in-a-sorted-array": {
   "stat": {
    "question_id": 1102,
    "question__title": "Check If a Number Is Majority Element in a Sorted Array",
    "question__title_slug": "check-if-a-number-is-majority-element-in-a-sorted-array",
    "question__hide": false,
    "total_acs": 5588,
    "total_submitted": 9307,
    "total_column_articles": 96,
    "frontend_question_id": "1150",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "check-if-it-is-a-straight-line": {
   "stat": {
    "question_id": 1349,
    "question__title": "Check If It Is a Straight Line",
    "question__title_slug": "check-if-it-is-a-straight-line",
    "question__hide": false,
    "total_acs": 38017,
    "total_submitted": 81714,
    "total_column_articles": 471,
    "frontend_question_id": "1232",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "climbing-stairs": {
   "stat": {
    "question_id": 70,
    "question__title": "Climbing Stairs",
    "question__title_slug": "climbing-stairs",
    "question__hide": false,
    "total_acs": 778708,
    "total_submitted": 1453341,
    "total_column_articles": 4614,
    "frontend_question_id": "70",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.5156671908,
   "progress": 91.8992165289
  },
  "clone-n-ary-tree": {
   "stat": {
    "question_id": 1634,
    "question__title": "Clone N-ary Tree",
    "question__title_slug": "clone-n-ary-tree",
    "question__hide": false,
    "total_acs": 1442,
    "total_submitted": 1725,
    "total_column_articles": 35,
    "frontend_question_id": "1490",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "closest-binary-search-tree-value": {
   "stat": {
    "question_id": 270,
    "question__title": "Closest Binary Search Tree Value",
    "question__title_slug": "closest-binary-search-tree-value",
    "question__hide": false,
    "total_acs": 12990,
    "total_submitted": 22696,
    "total_column_articles": 160,
    "frontend_question_id": "270",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "combination-sum": {
   "stat": {
    "question_id": 39,
    "question__title": "Combination Sum",
    "question__title_slug": "combination-sum",
    "question__hide": false,
    "total_acs": 463882,
    "total_submitted": 637281,
    "total_column_articles": 2654,
    "frontend_question_id": "39",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.1500180112,
   "progress": 64.1066258985
  },
  "combinations": {
   "stat": {
    "question_id": 77,
    "question__title": "Combinations",
    "question__title_slug": "combinations",
    "question__hide": false,
    "total_acs": 320026,
    "total_submitted": 415614,
    "total_column_articles": 1915,
    "frontend_question_id": "77",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2414347801,
   "progress": 45.6158728019
  },
  "cong-wei-dao-tou-da-yin-lian-biao-lcof": {
   "stat": {
    "question_id": 100282,
    "question__title": "从尾到头打印链表 LCOF",
    "question__title_slug": "cong-wei-dao-tou-da-yin-lian-biao-lcof",
    "question__hide": false,
    "total_acs": 424973,
    "total_submitted": 566707,
    "total_column_articles": 2712,
    "frontend_question_id": "剑指 Offer 06",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.5872745763,
   "progress": 73.0053188391
  },
  "construct-string-from-binary-tree": {
   "stat": {
    "question_id": 606,
    "question__title": "Construct String from Binary Tree",
    "question__title_slug": "construct-string-from-binary-tree",
    "question__hide": false,
    "total_acs": 59955,
    "total_submitted": 95016,
    "total_column_articles": 642,
    "frontend_question_id": "606",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.0689382644,
   "progress": 1.402975955
  },
  "container-with-most-water": {
   "stat": {
    "question_id": 11,
    "question__title": "Container With Most Water",
    "question__title_slug": "container-with-most-water",
    "question__hide": false,
    "total_acs": 688851,
    "total_submitted": 1118693,
    "total_column_articles": 3900,
    "frontend_question_id": "11",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.21152803,
   "progress": 85.7096216329
  },
  "contains-duplicate": {
   "stat": {
    "question_id": 217,
    "question__title": "Contains Duplicate",
    "question__title_slug": "contains-duplicate",
    "question__hide": false,
    "total_acs": 532743,
    "total_submitted": 958436,
    "total_column_articles": 2449,
    "frontend_question_id": "217",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.7395708965,
   "progress": 96.4559241562
  },
  "contains-duplicate-ii": {
   "stat": {
    "question_id": 219,
    "question__title": "Contains Duplicate II",
    "question__title_slug": "contains-duplicate-ii",
    "question__hide": false,
    "total_acs": 172668,
    "total_submitted": 388903,
    "total_column_articles": 1428,
    "frontend_question_id": "219",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.9326066978,
   "progress": 59.6820462026
  },
  "continuous-subarray-sum": {
   "stat": {
    "question_id": 523,
    "question__title": "Continuous Subarray Sum",
    "question__title_slug": "continuous-subarray-sum",
    "question__hide": false,
    "total_acs": 77669,
    "total_submitted": 279021,
    "total_column_articles": 664,
    "frontend_question_id": "523",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.6251303045,
   "progress": 33.0733411981
  },
  "convert-binary-number-in-a-linked-list-to-integer": {
   "stat": {
    "question_id": 1411,
    "question__title": "Convert Binary Number in a Linked List to Integer",
    "question__title_slug": "convert-binary-number-in-a-linked-list-to-integer",
    "question__hide": false,
    "total_acs": 62224,
    "total_submitted": 76945,
    "total_column_articles": 813,
    "frontend_question_id": "1290",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 0.5265180158,
   "progress": 10.7152699914
  },
  "convert-binary-search-tree-to-sorted-doubly-linked-list": {
   "stat": {
    "question_id": 758,
    "question__title": "Convert Binary Search Tree to Sorted Doubly Linked List",
    "question__title_slug": "convert-binary-search-tree-to-sorted-doubly-linked-list",
    "question__hide": false,
    "total_acs": 9786,
    "total_submitted": 14435,
    "total_column_articles": 151,
    "frontend_question_id": "426",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "convert-bst-to-greater-tree": {
   "stat": {
    "question_id": 538,
    "question__title": "Convert BST to Greater Tree",
    "question__title_slug": "convert-bst-to-greater-tree",
    "question__hide": false,
    "total_acs": 145916,
    "total_submitted": 200026,
    "total_column_articles": 1078,
    "frontend_question_id": "538",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.7352611289,
   "progress": 35.3146349097
  },
  "convert-sorted-array-to-binary-search-tree": {
   "stat": {
    "question_id": 108,
    "question__title": "Convert Sorted Array to Binary Search Tree",
    "question__title_slug": "convert-sorted-array-to-binary-search-tree",
    "question__hide": false,
    "total_acs": 245148,
    "total_submitted": 320036,
    "total_column_articles": 1513,
    "frontend_question_id": "108",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6740973626,
   "progress": 54.4210727156
  },
  "convert-sorted-list-to-binary-search-tree": {
   "stat": {
    "question_id": 109,
    "question__title": "Convert Sorted List to Binary Search Tree",
    "question__title_slug": "convert-sorted-list-to-binary-search-tree",
    "question__hide": false,
    "total_acs": 112364,
    "total_submitted": 147371,
    "total_column_articles": 886,
    "frontend_question_id": "109",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.5673269067,
   "progress": 52.2481665121
  },
  "copy-list-with-random-pointer": {
   "stat": {
    "question_id": 138,
    "question__title": "Copy List with Random Pointer",
    "question__title_slug": "copy-list-with-random-pointer",
    "question__hide": false,
    "total_acs": 141665,
    "total_submitted": 211997,
    "total_column_articles": 1045,
    "frontend_question_id": "138",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.9244132886,
   "progress": 59.5153005468
  },
  "count-and-say": {
   "stat": {
    "question_id": 38,
    "question__title": "Count and Say",
    "question__title_slug": "count-and-say",
    "question__hide": false,
    "total_acs": 274560,
    "total_submitted": 458515,
    "total_column_articles": 2803,
    "frontend_question_id": "38",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.1608190874,
   "progress": 43.9752472459
  },
  "count-binary-substrings": {
   "stat": {
    "question_id": 696,
    "question__title": "Count Binary Substrings",
    "question__title_slug": "count-binary-substrings",
    "question__hide": false,
    "total_acs": 58312,
    "total_submitted": 91707,
    "total_column_articles": 527,
    "frontend_question_id": "696",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.4889428678,
   "progress": 30.3017643295
  },
  "count-elements-with-strictly-smaller-and-greater-elements": {
   "stat": {
    "question_id": 2269,
    "question__title": "Count Elements With Strictly Smaller and Greater Elements ",
    "question__title_slug": "count-elements-with-strictly-smaller-and-greater-elements",
    "question__hide": false,
    "total_acs": 8257,
    "total_submitted": 14265,
    "total_column_articles": 100,
    "frontend_question_id": "2148",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.5013910657,
   "progress": 10.2039065697
  },
  "count-primes": {
   "stat": {
    "question_id": 204,
    "question__title": "Count Primes",
    "question__title_slug": "count-primes",
    "question__hide": false,
    "total_acs": 195585,
    "total_submitted": 520851,
    "total_column_articles": 837,
    "frontend_question_id": "204",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.367645851,
   "progress": 48.184418721
  },
  "counting-bits": {
   "stat": {
    "question_id": 338,
    "question__title": "Counting Bits",
    "question__title_slug": "counting-bits",
    "question__hide": false,
    "total_acs": 202001,
    "total_submitted": 256803,
    "total_column_articles": 1671,
    "frontend_question_id": "338",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.8809330706,
   "progress": 38.2792327757
  },
  "daily-temperatures": {
   "stat": {
    "question_id": 739,
    "question__title": "Daily Temperatures",
    "question__title_slug": "daily-temperatures",
    "question__hide": false,
    "total_acs": 276189,
    "total_submitted": 400914,
    "total_column_articles": 1897,
    "frontend_question_id": "739",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.6134196765,
   "progress": 73.537402831
  },
  "decode-string": {
   "stat": {
    "question_id": 394,
    "question__title": "Decode String",
    "question__title_slug": "decode-string",
    "question__hide": false,
    "total_acs": 157071,
    "total_submitted": 281008,
    "total_column_articles": 1618,
    "frontend_question_id": "394",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6448391633,
   "progress": 74.1768268842
  },
  "decompress-run-length-encoded-list": {
   "stat": {
    "question_id": 1241,
    "question__title": "Decompress Run-Length Encoded List",
    "question__title_slug": "decompress-run-length-encoded-list",
    "question__hide": false,
    "total_acs": 37396,
    "total_submitted": 44926,
    "total_column_articles": 573,
    "frontend_question_id": "1313",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "delete-node-in-a-linked-list": {
   "stat": {
    "question_id": 237,
    "question__title": "Delete Node in a Linked List",
    "question__title_slug": "delete-node-in-a-linked-list",
    "question__hide": false,
    "total_acs": 280969,
    "total_submitted": 327364,
    "total_column_articles": 1456,
    "frontend_question_id": "237",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2600538248,
   "progress": 45.9947925816
  },
  "delete-operation-for-two-strings": {
   "stat": {
    "question_id": 583,
    "question__title": "Delete Operation for Two Strings",
    "question__title_slug": "delete-operation-for-two-strings",
    "question__hide": false,
    "total_acs": 70284,
    "total_submitted": 109898,
    "total_column_articles": 629,
    "frontend_question_id": "583",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.3489265917,
   "progress": 68.1546528973
  },
  "delete-the-middle-node-of-a-linked-list": {
   "stat": {
    "question_id": 2216,
    "question__title": "Delete the Middle Node of a Linked List",
    "question__title_slug": "delete-the-middle-node-of-a-linked-list",
    "question__hide": false,
    "total_acs": 8041,
    "total_submitted": 13635,
    "total_column_articles": 115,
    "frontend_question_id": "2095",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "design-add-and-search-words-data-structure": {
   "stat": {
    "question_id": 211,
    "question__title": "Design Add and Search Words Data Structure",
    "question__title_slug": "design-add-and-search-words-data-structure",
    "question__hide": false,
    "total_acs": 56606,
    "total_submitted": 110987,
    "total_column_articles": 601,
    "frontend_question_id": "211",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.0411824159,
   "progress": 21.1893047561
  },
  "design-bounded-blocking-queue": {
   "stat": {
    "question_id": 1209,
    "question__title": "Design Bounded Blocking Queue",
    "question__title_slug": "design-bounded-blocking-queue",
    "question__hide": false,
    "total_acs": 4035,
    "total_submitted": 5732,
    "total_column_articles": 75,
    "frontend_question_id": "1188",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 1.2574055243,
   "progress": 25.5897030636
  },
  "design-circular-queue": {
   "stat": {
    "question_id": 860,
    "question__title": "Design Circular Queue",
    "question__title_slug": "design-circular-queue",
    "question__hide": false,
    "total_acs": 78723,
    "total_submitted": 177682,
    "total_column_articles": 533,
    "frontend_question_id": "622",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2206072023,
   "progress": 45.1920067368
  },
  "design-compressed-string-iterator": {
   "stat": {
    "question_id": 604,
    "question__title": "Design Compressed String Iterator",
    "question__title_slug": "design-compressed-string-iterator",
    "question__hide": false,
    "total_acs": 2957,
    "total_submitted": 7808,
    "total_column_articles": 70,
    "frontend_question_id": "604",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "design-hashmap": {
   "stat": {
    "question_id": 817,
    "question__title": "Design HashMap",
    "question__title_slug": "design-hashmap",
    "question__hide": false,
    "total_acs": 72839,
    "total_submitted": 113848,
    "total_column_articles": 476,
    "frontend_question_id": "706",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.722768774,
   "progress": 35.0604005798
  },
  "design-hashset": {
   "stat": {
    "question_id": 816,
    "question__title": "Design HashSet",
    "question__title_slug": "design-hashset",
    "question__hide": false,
    "total_acs": 80622,
    "total_submitted": 126166,
    "total_column_articles": 498,
    "frontend_question_id": "705",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6889564771,
   "progress": 54.7234734272
  },
  "design-linked-list": {
   "stat": {
    "question_id": 838,
    "question__title": "Design Linked List",
    "question__title_slug": "design-linked-list",
    "question__hide": false,
    "total_acs": 103828,
    "total_submitted": 312036,
    "total_column_articles": 679,
    "frontend_question_id": "707",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7737530137,
   "progress": 56.4491841482
  },
  "design-skiplist": {
   "stat": {
    "question_id": 1337,
    "question__title": "Design Skiplist",
    "question__title_slug": "design-skiplist",
    "question__hide": false,
    "total_acs": 9835,
    "total_submitted": 15860,
    "total_column_articles": 114,
    "frontend_question_id": "1206",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 0.6085311675,
   "progress": 12.3843355058
  },
  "design-twitter": {
   "stat": {
    "question_id": 355,
    "question__title": "Design Twitter",
    "question__title_slug": "design-twitter",
    "question__hide": false,
    "total_acs": 32353,
    "total_submitted": 78944,
    "total_column_articles": 539,
    "frontend_question_id": "355",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.5543042519,
   "progress": 31.6319465014
  },
  "detect-capital": {
   "stat": {
    "question_id": 520,
    "question__title": "Detect Capital",
    "question__title_slug": "detect-capital",
    "question__hide": false,
    "total_acs": 72486,
    "total_submitted": 126202,
    "total_column_articles": 1102,
    "frontend_question_id": "520",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2206072023,
   "progress": 45.1920067368
  },
  "diameter-of-binary-tree": {
   "stat": {
    "question_id": 543,
    "question__title": "Diameter of Binary Tree",
    "question__title_slug": "diameter-of-binary-tree",
    "question__hide": false,
    "total_acs": 201580,
    "total_submitted": 355980,
    "total_column_articles": 1524,
    "frontend_question_id": "543",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.5466225285,
   "progress": 72.1780011503
  },
  "diameter-of-n-ary-tree": {
   "stat": {
    "question_id": 1665,
    "question__title": "Diameter of N-Ary Tree",
    "question__title_slug": "diameter-of-n-ary-tree",
    "question__hide": false,
    "total_acs": 1352,
    "total_submitted": 1901,
    "total_column_articles": 41,
    "frontend_question_id": "1522",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "distribute-candies": {
   "stat": {
    "question_id": 575,
    "question__title": "Distribute Candies",
    "question__title_slug": "distribute-candies",
    "question__hide": false,
    "total_acs": 92850,
    "total_submitted": 130767,
    "total_column_articles": 876,
    "frontend_question_id": "575",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.1481836027,
   "progress": 64.0692934962
  },
  "divide-two-integers": {
   "stat": {
    "question_id": 29,
    "question__title": "Divide Two Integers",
    "question__title_slug": "divide-two-integers",
    "question__hide": false,
    "total_acs": 156887,
    "total_submitted": 709471,
    "total_column_articles": 1220,
    "frontend_question_id": "29",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.543183499,
   "progress": 72.1080127965
  },
  "edit-distance": {
   "stat": {
    "question_id": 72,
    "question__title": "Edit Distance",
    "question__title_slug": "edit-distance",
    "question__hide": false,
    "total_acs": 236662,
    "total_submitted": 381270,
    "total_column_articles": 1923,
    "frontend_question_id": "72",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.8085576045,
   "progress": 77.5086925516
  },
  "encode-and-decode-tinyurl": {
   "stat": {
    "question_id": 535,
    "question__title": "Encode and Decode TinyURL",
    "question__title_slug": "encode-and-decode-tinyurl",
    "question__hide": false,
    "total_acs": 17931,
    "total_submitted": 21189,
    "total_column_articles": 120,
    "frontend_question_id": "535",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.1266071206,
   "progress": 22.9277994463
  },
  "er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof": {
   "stat": {
    "question_id": 100333,
    "question__title": "二叉搜索树的第k大节点  LCOF",
    "question__title_slug": "er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof",
    "question__hide": false,
    "total_acs": 217949,
    "total_submitted": 286068,
    "total_column_articles": 1461,
    "frontend_question_id": "剑指 Offer 54",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2171813682,
   "progress": 45.122286924
  },
  "er-jin-zhi-zhong-1de-ge-shu-lcof": {
   "stat": {
    "question_id": 100292,
    "question__title": "二进制中1的个数 LCOF",
    "question__title_slug": "er-jin-zhi-zhong-1de-ge-shu-lcof",
    "question__hide": false,
    "total_acs": 247389,
    "total_submitted": 329838,
    "total_column_articles": 1460,
    "frontend_question_id": "剑指 Offer 15",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.6177773302,
   "progress": 32.9236993956
  },
  "evaluate-reverse-polish-notation": {
   "stat": {
    "question_id": 150,
    "question__title": "Evaluate Reverse Polish Notation",
    "question__title_slug": "evaluate-reverse-polish-notation",
    "question__hide": false,
    "total_acs": 173625,
    "total_submitted": 323898,
    "total_column_articles": 1349,
    "frontend_question_id": "150",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5673269067,
   "progress": 52.2481665121
  },
  "excel-sheet-column-number": {
   "stat": {
    "question_id": 171,
    "question__title": "Excel Sheet Column Number",
    "question__title_slug": "excel-sheet-column-number",
    "question__hide": false,
    "total_acs": 126097,
    "total_submitted": 175994,
    "total_column_articles": 1069,
    "frontend_question_id": "171",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5644782265,
   "progress": 52.1901924715
  },
  "factor-combinations": {
   "stat": {
    "question_id": 254,
    "question__title": "Factor Combinations",
    "question__title_slug": "factor-combinations",
    "question__hide": false,
    "total_acs": 7090,
    "total_submitted": 12399,
    "total_column_articles": 108,
    "frontend_question_id": "254",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": true,
   "frequency": 0.5800067008,
   "progress": 11.8038285659
  },
  "fan-zhuan-lian-biao-lcof": {
   "stat": {
    "question_id": 100298,
    "question__title": "反转链表 LCOF",
    "question__title_slug": "fan-zhuan-lian-biao-lcof",
    "question__hide": false,
    "total_acs": 400296,
    "total_submitted": 538988,
    "total_column_articles": 2299,
    "frontend_question_id": "剑指 Offer 24",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.9984585947,
   "progress": 81.3734043386
  },
  "fei-bo-na-qi-shu-lie-lcof": {
   "stat": {
    "question_id": 100274,
    "question__title": "斐波那契数列  LCOF",
    "question__title_slug": "fei-bo-na-qi-shu-lie-lcof",
    "question__hide": false,
    "total_acs": 350292,
    "total_submitted": 968581,
    "total_column_articles": 2251,
    "frontend_question_id": "剑指 Offer 10- I",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.7545822667,
   "progress": 76.4102300119
  },
  "fibonacci-number": {
   "stat": {
    "question_id": 1013,
    "question__title": "Fibonacci Number",
    "question__title_slug": "fibonacci-number",
    "question__hide": false,
    "total_acs": 363367,
    "total_submitted": 545255,
    "total_column_articles": 2198,
    "frontend_question_id": "509",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.5053059215,
   "progress": 71.3371588896
  },
  "find-all-numbers-disappeared-in-an-array": {
   "stat": {
    "question_id": 448,
    "question__title": "Find All Numbers Disappeared in an Array",
    "question__title_slug": "find-all-numbers-disappeared-in-an-array",
    "question__hide": false,
    "total_acs": 180510,
    "total_submitted": 276134,
    "total_column_articles": 1341,
    "frontend_question_id": "448",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.2663447363,
   "progress": 46.1228201392
  },
  "find-first-and-last-position-of-element-in-sorted-array": {
   "stat": {
    "question_id": 34,
    "question__title": "Find First and Last Position of Element in Sorted Array",
    "question__title_slug": "find-first-and-last-position-of-element-in-sorted-array",
    "question__hide": false,
    "total_acs": 493994,
    "total_submitted": 1170297,
    "total_column_articles": 4689,
    "frontend_question_id": "34",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6340499974,
   "progress": 73.9572544835
  },
  "find-numbers-with-even-number-of-digits": {
   "stat": {
    "question_id": 1421,
    "question__title": "Find Numbers with Even Number of Digits",
    "question__title_slug": "find-numbers-with-even-number-of-digits",
    "question__hide": false,
    "total_acs": 51387,
    "total_submitted": 63728,
    "total_column_articles": 681,
    "frontend_question_id": "1295",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.0970628743,
   "progress": 22.3265387746
  },
  "find-peak-element": {
   "stat": {
    "question_id": 162,
    "question__title": "Find Peak Element",
    "question__title_slug": "find-peak-element",
    "question__hide": false,
    "total_acs": 211210,
    "total_submitted": 426783,
    "total_column_articles": 1404,
    "frontend_question_id": "162",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.3519138681,
   "progress": 68.2154475379
  },
  "find-pivot-index": {
   "stat": {
    "question_id": 724,
    "question__title": "Find Pivot Index",
    "question__title_slug": "find-pivot-index",
    "question__hide": false,
    "total_acs": 171895,
    "total_submitted": 356208,
    "total_column_articles": 1024,
    "frontend_question_id": "724",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.4889428678,
   "progress": 30.3017643295
  },
  "find-smallest-letter-greater-than-target": {
   "stat": {
    "question_id": 745,
    "question__title": "Find Smallest Letter Greater Than Target",
    "question__title_slug": "find-smallest-letter-greater-than-target",
    "question__hide": false,
    "total_acs": 81031,
    "total_submitted": 162824,
    "total_column_articles": 709,
    "frontend_question_id": "744",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.1697045646,
   "progress": 3.4536904229
  },
  "find-the-difference": {
   "stat": {
    "question_id": 389,
    "question__title": "Find the Difference",
    "question__title_slug": "find-the-difference",
    "question__hide": false,
    "total_acs": 120996,
    "total_submitted": 176360,
    "total_column_articles": 1216,
    "frontend_question_id": "389",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "find-the-distance-value-between-two-arrays": {
   "stat": {
    "question_id": 1486,
    "question__title": "Find the Distance Value Between Two Arrays",
    "question__title_slug": "find-the-distance-value-between-two-arrays",
    "question__hide": false,
    "total_acs": 17902,
    "total_submitted": 26054,
    "total_column_articles": 272,
    "frontend_question_id": "1385",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "first-bad-version": {
   "stat": {
    "question_id": 278,
    "question__title": "First Bad Version",
    "question__title_slug": "first-bad-version",
    "question__hide": false,
    "total_acs": 304827,
    "total_submitted": 676605,
    "total_column_articles": 1692,
    "frontend_question_id": "278",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.9910437935,
   "progress": 81.2225042846
  },
  "first-unique-character-in-a-string": {
   "stat": {
    "question_id": 387,
    "question__title": "First Unique Character in a String",
    "question__title_slug": "first-unique-character-in-a-string",
    "question__hide": false,
    "total_acs": 282944,
    "total_submitted": 518365,
    "total_column_articles": 1549,
    "frontend_question_id": "387",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.1995738543,
   "progress": 65.1151464466
  },
  "fixed-point": {
   "stat": {
    "question_id": 1066,
    "question__title": "Fixed Point",
    "question__title_slug": "fixed-point",
    "question__hide": false,
    "total_acs": 5449,
    "total_submitted": 8411,
    "total_column_articles": 80,
    "frontend_question_id": "1064",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "fizz-buzz": {
   "stat": {
    "question_id": 412,
    "question__title": "Fizz Buzz",
    "question__title_slug": "fizz-buzz",
    "question__hide": false,
    "total_acs": 117423,
    "total_submitted": 164748,
    "total_column_articles": 659,
    "frontend_question_id": "412",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.4469895912,
   "progress": 49.7991585266
  },
  "fizz-buzz-multithreaded": {
   "stat": {
    "question_id": 1316,
    "question__title": "Fizz Buzz Multithreaded",
    "question__title_slug": "fizz-buzz-multithreaded",
    "question__hide": false,
    "total_acs": 16345,
    "total_submitted": 25523,
    "total_column_articles": 300,
    "frontend_question_id": "1195",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.8710885336,
   "progress": 38.0788846973
  },
  "flatten-2d-vector": {
   "stat": {
    "question_id": 251,
    "question__title": "Flatten 2D Vector",
    "question__title_slug": "flatten-2d-vector",
    "question__hide": false,
    "total_acs": 4950,
    "total_submitted": 8931,
    "total_column_articles": 86,
    "frontend_question_id": "251",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0.5800067008,
   "progress": 11.8038285659
  },
  "flatten-a-multilevel-doubly-linked-list": {
   "stat": {
    "question_id": 766,
    "question__title": "Flatten a Multilevel Doubly Linked List",
    "question__title_slug": "flatten-a-multilevel-doubly-linked-list",
    "question__hide": false,
    "total_acs": 49674,
    "total_submitted": 84100,
    "total_column_articles": 738,
    "frontend_question_id": "430",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.4469895912,
   "progress": 49.7991585266
  },
  "flatten-binary-tree-to-linked-list": {
   "stat": {
    "question_id": 114,
    "question__title": "Flatten Binary Tree to Linked List",
    "question__title_slug": "flatten-binary-tree-to-linked-list",
    "question__hide": false,
    "total_acs": 239971,
    "total_submitted": 329637,
    "total_column_articles": 1884,
    "frontend_question_id": "114",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.626186303,
   "progress": 53.446025472
  },
  "flipping-an-image": {
   "stat": {
    "question_id": 861,
    "question__title": "Flipping an Image",
    "question__title_slug": "flipping-an-image",
    "question__hide": false,
    "total_acs": 90731,
    "total_submitted": 114137,
    "total_column_articles": 1000,
    "frontend_question_id": "832",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.1266071206,
   "progress": 22.9277994463
  },
  "game-of-life": {
   "stat": {
    "question_id": 289,
    "question__title": "Game of Life",
    "question__title_slug": "game-of-life",
    "question__hide": false,
    "total_acs": 60155,
    "total_submitted": 79687,
    "total_column_articles": 922,
    "frontend_question_id": "289",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.0734996051,
   "progress": 42.1981915689
  },
  "generate-parentheses": {
   "stat": {
    "question_id": 22,
    "question__title": "Generate Parentheses",
    "question__title_slug": "generate-parentheses",
    "question__hide": false,
    "total_acs": 472750,
    "total_submitted": 611075,
    "total_column_articles": 3421,
    "frontend_question_id": "22",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 4.2538965088,
   "progress": 86.5718707408
  },
  "gray-code": {
   "stat": {
    "question_id": 89,
    "question__title": "Gray Code",
    "question__title_slug": "gray-code",
    "question__hide": false,
    "total_acs": 91783,
    "total_submitted": 123186,
    "total_column_articles": 769,
    "frontend_question_id": "89",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6570512186,
   "progress": 54.0741633414
  },
  "group-anagrams": {
   "stat": {
    "question_id": 49,
    "question__title": "Group Anagrams",
    "question__title_slug": "group-anagrams",
    "question__hide": false,
    "total_acs": 304945,
    "total_submitted": 454400,
    "total_column_articles": 1738,
    "frontend_question_id": "49",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.0612863541,
   "progress": 62.3008307801
  },
  "group-shifted-strings": {
   "stat": {
    "question_id": 249,
    "question__title": "Group Shifted Strings",
    "question__title_slug": "group-shifted-strings",
    "question__hide": false,
    "total_acs": 7676,
    "total_submitted": 11852,
    "total_column_articles": 138,
    "frontend_question_id": "249",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 1.1266071206,
   "progress": 22.9277994463
  },
  "guess-number-higher-or-lower": {
   "stat": {
    "question_id": 374,
    "question__title": "Guess Number Higher or Lower",
    "question__title_slug": "guess-number-higher-or-lower",
    "question__hide": false,
    "total_acs": 103132,
    "total_submitted": 198201,
    "total_column_articles": 694,
    "frontend_question_id": "374",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "guess-numbers": {
   "stat": {
    "question_id": 100107,
    "question__title": "Guess Numbers",
    "question__title_slug": "guess-numbers",
    "question__hide": false,
    "total_acs": 87064,
    "total_submitted": 103030,
    "total_column_articles": 678,
    "frontend_question_id": "LCP 01",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.4540225138,
   "progress": 9.2399000056
  },
  "hamming-distance": {
   "stat": {
    "question_id": 461,
    "question__title": "Hamming Distance",
    "question__title_slug": "hamming-distance",
    "question__hide": false,
    "total_acs": 202964,
    "total_submitted": 248976,
    "total_column_articles": 1595,
    "frontend_question_id": "461",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.2937731685,
   "progress": 26.3298280252
  },
  "happy-number": {
   "stat": {
    "question_id": 202,
    "question__title": "Happy Number",
    "question__title_slug": "happy-number",
    "question__hide": false,
    "total_acs": 230363,
    "total_submitted": 367947,
    "total_column_articles": 1816,
    "frontend_question_id": "202",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6867957156,
   "progress": 54.6794993534
  },
  "he-bing-liang-ge-pai-xu-de-lian-biao-lcof": {
   "stat": {
    "question_id": 100286,
    "question__title": "合并两个排序的链表  LCOF",
    "question__title_slug": "he-bing-liang-ge-pai-xu-de-lian-biao-lcof",
    "question__hide": false,
    "total_acs": 249345,
    "total_submitted": 343095,
    "total_column_articles": 1485,
    "frontend_question_id": "剑指 Offer 25",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.3536799042,
   "progress": 68.2513884794
  },
  "house-robber": {
   "stat": {
    "question_id": 198,
    "question__title": "House Robber",
    "question__title_slug": "house-robber",
    "question__hide": false,
    "total_acs": 518178,
    "total_submitted": 980677,
    "total_column_articles": 3490,
    "frontend_question_id": "198",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.4749974045,
   "progress": 70.7203443968
  },
  "house-robber-ii": {
   "stat": {
    "question_id": 213,
    "question__title": "House Robber II",
    "question__title_slug": "house-robber-ii",
    "question__hide": false,
    "total_acs": 229498,
    "total_submitted": 526563,
    "total_column_articles": 2047,
    "frontend_question_id": "213",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.941744745,
   "progress": 59.8680163676
  },
  "house-robber-iii": {
   "stat": {
    "question_id": 337,
    "question__title": "House Robber III",
    "question__title_slug": "house-robber-iii",
    "question__hide": false,
    "total_acs": 170938,
    "total_submitted": 281678,
    "total_column_articles": 1164,
    "frontend_question_id": "337",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.1995738543,
   "progress": 65.1151464466
  },
  "iIQa4I": {
   "stat": {
    "question_id": 1000282,
    "question__title": "每日温度",
    "question__title_slug": "iIQa4I",
    "question__hide": false,
    "total_acs": 14051,
    "total_submitted": 18167,
    "total_column_articles": 170,
    "frontend_question_id": "剑指 Offer II 038",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.5265180158,
   "progress": 10.7152699914
  },
  "image-smoother": {
   "stat": {
    "question_id": 661,
    "question__title": "Image Smoother",
    "question__title_slug": "image-smoother",
    "question__hide": false,
    "total_acs": 45082,
    "total_submitted": 69775,
    "total_column_articles": 488,
    "frontend_question_id": "661",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.1927860632,
   "progress": 3.9234264658
  },
  "implement-queue-using-stacks": {
   "stat": {
    "question_id": 232,
    "question__title": "Implement Queue using Stacks",
    "question__title_slug": "implement-queue-using-stacks",
    "question__hide": false,
    "total_acs": 220879,
    "total_submitted": 320788,
    "total_column_articles": 1640,
    "frontend_question_id": "232",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2171813682,
   "progress": 45.122286924
  },
  "implement-stack-using-queues": {
   "stat": {
    "question_id": 225,
    "question__title": "Implement Stack using Queues",
    "question__title_slug": "implement-stack-using-queues",
    "question__hide": false,
    "total_acs": 180757,
    "total_submitted": 267596,
    "total_column_articles": 5015,
    "frontend_question_id": "225",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.3453794148,
   "progress": 47.7312701705
  },
  "implement-strstr": {
   "stat": {
    "question_id": 28,
    "question__title": "Implement strStr()",
    "question__title_slug": "implement-strstr",
    "question__hide": false,
    "total_acs": 609960,
    "total_submitted": 1517773,
    "total_column_articles": 4058,
    "frontend_question_id": "28",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6466050902,
   "progress": 74.2127656044
  },
  "implement-trie-prefix-tree": {
   "stat": {
    "question_id": 208,
    "question__title": "Implement Trie (Prefix Tree)",
    "question__title_slug": "implement-trie-prefix-tree",
    "question__hide": false,
    "total_acs": 185993,
    "total_submitted": 258821,
    "total_column_articles": 1222,
    "frontend_question_id": "208",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.9390280902,
   "progress": 59.8127292012
  },
  "insert-into-a-sorted-circular-linked-list": {
   "stat": {
    "question_id": 850,
    "question__title": "Insert into a Sorted Circular Linked List",
    "question__title_slug": "insert-into-a-sorted-circular-linked-list",
    "question__hide": false,
    "total_acs": 3330,
    "total_submitted": 9205,
    "total_column_articles": 66,
    "frontend_question_id": "708",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": true,
   "frequency": 0,
   "progress": 0
  },
  "insertion-sort-list": {
   "stat": {
    "question_id": 147,
    "question__title": "Insertion Sort List",
    "question__title_slug": "insertion-sort-list",
    "question__hide": false,
    "total_acs": 117289,
    "total_submitted": 170703,
    "total_column_articles": 902,
    "frontend_question_id": "147",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6889564771,
   "progress": 54.7234734272
  },
  "integer-break": {
   "stat": {
    "question_id": 343,
    "question__title": "Integer Break",
    "question__title_slug": "integer-break",
    "question__hide": false,
    "total_acs": 152892,
    "total_submitted": 248357,
    "total_column_articles": 1367,
    "frontend_question_id": "343",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.3427818015,
   "progress": 68.0295990846
  },
  "intersection-of-two-arrays": {
   "stat": {
    "question_id": 349,
    "question__title": "Intersection of Two Arrays",
    "question__title_slug": "intersection-of-two-arrays",
    "question__hide": false,
    "total_acs": 280350,
    "total_submitted": 378913,
    "total_column_articles": 1941,
    "frontend_question_id": "349",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6134196765,
   "progress": 73.537402831
  },
  "intersection-of-two-arrays-ii": {
   "stat": {
    "question_id": 350,
    "question__title": "Intersection of Two Arrays II",
    "question__title_slug": "intersection-of-two-arrays-ii",
    "question__hide": false,
    "total_acs": 331808,
    "total_submitted": 593669,
    "total_column_articles": 1909,
    "frontend_question_id": "350",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.0684964506,
   "progress": 62.4475648485
  },
  "intersection-of-two-linked-lists": {
   "stat": {
    "question_id": 160,
    "question__title": "Intersection of Two Linked Lists",
    "question__title_slug": "intersection-of-two-linked-lists",
    "question__hide": false,
    "total_acs": 445519,
    "total_submitted": 712272,
    "total_column_articles": 2639,
    "frontend_question_id": "160",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.9535698729,
   "progress": 60.1086718339
  },
  "invert-binary-tree": {
   "stat": {
    "question_id": 226,
    "question__title": "Invert Binary Tree",
    "question__title_slug": "invert-binary-tree",
    "question__hide": false,
    "total_acs": 422986,
    "total_submitted": 534793,
    "total_column_articles": 2669,
    "frontend_question_id": "226",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6535425549,
   "progress": 74.3539512916
  },
  "is-subsequence": {
   "stat": {
    "question_id": 392,
    "question__title": "Is Subsequence",
    "question__title_slug": "is-subsequence",
    "question__hide": false,
    "total_acs": 185412,
    "total_submitted": 356461,
    "total_column_articles": 1906,
    "frontend_question_id": "392",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.9318605719,
   "progress": 39.3156682056
  },
  "is-unique-lcci": {
   "stat": {
    "question_id": 100158,
    "question__title": "Is Unique LCCI",
    "question__title_slug": "is-unique-lcci",
    "question__hide": false,
    "total_acs": 116905,
    "total_submitted": 164010,
    "total_column_articles": 1815,
    "frontend_question_id": "面试题 01.01",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 4.1250343853,
   "progress": 83.949372739
  },
  "isomorphic-strings": {
   "stat": {
    "question_id": 205,
    "question__title": "Isomorphic Strings",
    "question__title_slug": "isomorphic-strings",
    "question__hide": false,
    "total_acs": 135223,
    "total_submitted": 271410,
    "total_column_articles": 1030,
    "frontend_question_id": "205",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.3804092661,
   "progress": 48.4441694513
  },
  "jBjn9C": {
   "stat": {
    "question_id": 1000323,
    "question__title": "数据流的第 K 大数值",
    "question__title_slug": "jBjn9C",
    "question__hide": false,
    "total_acs": 8899,
    "total_submitted": 13982,
    "total_column_articles": 106,
    "frontend_question_id": "剑指 Offer II 059",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "jump-game": {
   "stat": {
    "question_id": 55,
    "question__title": "Jump Game",
    "question__title_slug": "jump-game",
    "question__hide": false,
    "total_acs": 460714,
    "total_submitted": 1060245,
    "total_column_articles": 3405,
    "frontend_question_id": "55",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.522799589,
   "progress": 71.6931759008
  },
  "kill-process": {
   "stat": {
    "question_id": 582,
    "question__title": "Kill Process",
    "question__title_slug": "kill-process",
    "question__hide": false,
    "total_acs": 10077,
    "total_submitted": 23547,
    "total_column_articles": 153,
    "frontend_question_id": "582",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": true,
   "frequency": 0.5265180158,
   "progress": 10.7152699914
  },
  "kth-largest-element-in-a-stream": {
   "stat": {
    "question_id": 789,
    "question__title": "Kth Largest Element in a Stream",
    "question__title_slug": "kth-largest-element-in-a-stream",
    "question__hide": false,
    "total_acs": 70103,
    "total_submitted": 135358,
    "total_column_articles": 639,
    "frontend_question_id": "703",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.6923018326,
   "progress": 34.4403619616
  },
  "kth-largest-element-in-an-array": {
   "stat": {
    "question_id": 215,
    "question__title": "Kth Largest Element in an Array",
    "question__title_slug": "kth-largest-element-in-an-array",
    "question__hide": false,
    "total_acs": 586869,
    "total_submitted": 907582,
    "total_column_articles": 2975,
    "frontend_question_id": "215",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.885301506,
   "progress": 79.0705225377
  },
  "kth-node-from-end-of-list-lcci": {
   "stat": {
    "question_id": 1000007,
    "question__title": "Kth Node From End of List LCCI",
    "question__title_slug": "kth-node-from-end-of-list-lcci",
    "question__hide": false,
    "total_acs": 75024,
    "total_submitted": 96189,
    "total_column_articles": 1061,
    "frontend_question_id": "面试题 02.02",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5962976466,
   "progress": 52.8377556438
  },
  "kth-smallest-element-in-a-bst": {
   "stat": {
    "question_id": 230,
    "question__title": "Kth Smallest Element in a BST",
    "question__title_slug": "kth-smallest-element-in-a-bst",
    "question__hide": false,
    "total_acs": 198469,
    "total_submitted": 263570,
    "total_column_articles": 1377,
    "frontend_question_id": "230",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.2937731685,
   "progress": 26.3298280252
  },
  "largest-number": {
   "stat": {
    "question_id": 179,
    "question__title": "Largest Number",
    "question__title_slug": "largest-number",
    "question__hide": false,
    "total_acs": 146246,
    "total_submitted": 355908,
    "total_column_articles": 1140,
    "frontend_question_id": "179",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.4473414397,
   "progress": 70.1575125067
  },
  "largest-rectangle-in-histogram": {
   "stat": {
    "question_id": 84,
    "question__title": "Largest Rectangle in Histogram",
    "question__title_slug": "largest-rectangle-in-histogram",
    "question__hide": false,
    "total_acs": 233292,
    "total_submitted": 530238,
    "total_column_articles": 1450,
    "frontend_question_id": "84",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.7737530137,
   "progress": 56.4491841482
  },
  "lemonade-change": {
   "stat": {
    "question_id": 890,
    "question__title": "Lemonade Change",
    "question__title_slug": "lemonade-change",
    "question__hide": false,
    "total_acs": 111852,
    "total_submitted": 191365,
    "total_column_articles": 927,
    "frontend_question_id": "860",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.6068649565,
   "progress": 32.7016195681
  },
  "length-of-last-word": {
   "stat": {
    "question_id": 58,
    "question__title": "Length of Last Word",
    "question__title_slug": "length-of-last-word",
    "question__hide": false,
    "total_acs": 306476,
    "total_submitted": 771303,
    "total_column_articles": 3260,
    "frontend_question_id": "58",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.9326066978,
   "progress": 59.6820462026
  },
  "letter-case-permutation": {
   "stat": {
    "question_id": 800,
    "question__title": "Letter Case Permutation",
    "question__title_slug": "letter-case-permutation",
    "question__hide": false,
    "total_acs": 59986,
    "total_submitted": 86046,
    "total_column_articles": 701,
    "frontend_question_id": "784",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.3804092661,
   "progress": 48.4441694513
  },
  "letter-combinations-of-a-phone-number": {
   "stat": {
    "question_id": 17,
    "question__title": "Letter Combinations of a Phone Number",
    "question__title_slug": "letter-combinations-of-a-phone-number",
    "question__hide": false,
    "total_acs": 453799,
    "total_submitted": 786032,
    "total_column_articles": 3980,
    "frontend_question_id": "17",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.1407953164,
   "progress": 63.9189330527
  },
  "lexicographical-numbers": {
   "stat": {
    "question_id": 386,
    "question__title": "Lexicographical Numbers",
    "question__title_slug": "lexicographical-numbers",
    "question__hide": false,
    "total_acs": 29007,
    "total_submitted": 38494,
    "total_column_articles": 294,
    "frontend_question_id": "386",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.318277485,
   "progress": 47.1797135549
  },
  "lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof": {
   "stat": {
    "question_id": 100294,
    "question__title": "链表中倒数第k个节点 LCOF",
    "question__title_slug": "lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof",
    "question__hide": false,
    "total_acs": 334382,
    "total_submitted": 417017,
    "total_column_articles": 2887,
    "frontend_question_id": "剑指 Offer 22",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.8698743388,
   "progress": 78.7565612735
  },
  "lian-xu-zi-shu-zu-de-zui-da-he-lcof": {
   "stat": {
    "question_id": 100304,
    "question__title": "连续子数组的最大和  LCOF",
    "question__title_slug": "lian-xu-zi-shu-zu-de-zui-da-he-lcof",
    "question__hide": false,
    "total_acs": 289582,
    "total_submitted": 477125,
    "total_column_articles": 1833,
    "frontend_question_id": "剑指 Offer 42",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.2747746374,
   "progress": 66.6455721312
  },
  "linked-list-cycle": {
   "stat": {
    "question_id": 141,
    "question__title": "Linked List Cycle",
    "question__title_slug": "linked-list-cycle",
    "question__hide": false,
    "total_acs": 695581,
    "total_submitted": 1353620,
    "total_column_articles": 3579,
    "frontend_question_id": "141",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.2667975689,
   "progress": 66.4832292677
  },
  "linked-list-cycle-ii": {
   "stat": {
    "question_id": 142,
    "question__title": "Linked List Cycle II",
    "question__title_slug": "linked-list-cycle-ii",
    "question__hide": false,
    "total_acs": 413493,
    "total_submitted": 739480,
    "total_column_articles": 2453,
    "frontend_question_id": "142",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.8020434436,
   "progress": 57.0249281585
  },
  "linked-list-cycle-lcci": {
   "stat": {
    "question_id": 100168,
    "question__title": "Linked List Cycle LCCI",
    "question__title_slug": "linked-list-cycle-lcci",
    "question__hide": false,
    "total_acs": 33654,
    "total_submitted": 62389,
    "total_column_articles": 334,
    "frontend_question_id": "面试题 02.08",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.1266071206,
   "progress": 22.9277994463
  },
  "linked-list-random-node": {
   "stat": {
    "question_id": 382,
    "question__title": "Linked List Random Node",
    "question__title_slug": "linked-list-random-node",
    "question__hide": false,
    "total_acs": 43242,
    "total_submitted": 60136,
    "total_column_articles": 344,
    "frontend_question_id": "382",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5644782265,
   "progress": 52.1901924715
  },
  "longest-common-prefix": {
   "stat": {
    "question_id": 14,
    "question__title": "Longest Common Prefix",
    "question__title_slug": "longest-common-prefix",
    "question__hide": false,
    "total_acs": 790551,
    "total_submitted": 1875879,
    "total_column_articles": 4907,
    "frontend_question_id": "14",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 4.6729733717,
   "progress": 95.1005850456
  },
  "longest-common-subsequence": {
   "stat": {
    "question_id": 1250,
    "question__title": "Longest Common Subsequence",
    "question__title_slug": "longest-common-subsequence",
    "question__hide": false,
    "total_acs": 218318,
    "total_submitted": 340120,
    "total_column_articles": 1365,
    "frontend_question_id": "1143",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.0376349324,
   "progress": 61.8194961209
  },
  "longest-consecutive-sequence": {
   "stat": {
    "question_id": 128,
    "question__title": "Longest Consecutive Sequence",
    "question__title_slug": "longest-consecutive-sequence",
    "question__hide": false,
    "total_acs": 242466,
    "total_submitted": 442294,
    "total_column_articles": 1555,
    "frontend_question_id": "128",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.9676844557,
   "progress": 80.7471138823
  },
  "longest-palindrome": {
   "stat": {
    "question_id": 409,
    "question__title": "Longest Palindrome",
    "question__title_slug": "longest-palindrome",
    "question__hide": false,
    "total_acs": 117627,
    "total_submitted": 211763,
    "total_column_articles": 1571,
    "frontend_question_id": "409",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.5962976466,
   "progress": 52.8377556438
  },
  "longest-palindromic-substring": {
   "stat": {
    "question_id": 5,
    "question__title": "Longest Palindromic Substring",
    "question__title_slug": "longest-palindromic-substring",
    "question__hide": false,
    "total_acs": 969529,
    "total_submitted": 2661316,
    "total_column_articles": 5255,
    "frontend_question_id": "5",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 4.5581517735,
   "progress": 92.7638284893
  },
  "longest-substring-without-repeating-characters": {
   "stat": {
    "question_id": 3,
    "question__title": "Longest Substring Without Repeating Characters",
    "question__title_slug": "longest-substring-without-repeating-characters",
    "question__hide": false,
    "total_acs": 1633505,
    "total_submitted": 4229500,
    "total_column_articles": 9790,
    "frontend_question_id": "3",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.6105059099,
   "progress": 93.8292976469
  },
  "lowest-common-ancestor-of-a-binary-search-tree": {
   "stat": {
    "question_id": 235,
    "question__title": "Lowest Common Ancestor of a Binary Search Tree",
    "question__title_slug": "lowest-common-ancestor-of-a-binary-search-tree",
    "question__hide": false,
    "total_acs": 223767,
    "total_submitted": 333516,
    "total_column_articles": 1273,
    "frontend_question_id": "235",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5438472405,
   "progress": 51.7703272842
  },
  "lowest-common-ancestor-of-a-binary-tree": {
   "stat": {
    "question_id": 236,
    "question__title": "Lowest Common Ancestor of a Binary Tree",
    "question__title_slug": "lowest-common-ancestor-of-a-binary-tree",
    "question__hide": false,
    "total_acs": 352227,
    "total_submitted": 511715,
    "total_column_articles": 1860,
    "frontend_question_id": "236",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.0918899382,
   "progress": 62.9236502409
  },
  "lru-cache": {
   "stat": {
    "question_id": 146,
    "question__title": "LRU Cache",
    "question__title_slug": "lru-cache",
    "question__hide": false,
    "total_acs": 323644,
    "total_submitted": 614787,
    "total_column_articles": 2147,
    "frontend_question_id": "146",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.2324721371,
   "progress": 86.135859209
  },
  "majority-element": {
   "stat": {
    "question_id": 169,
    "question__title": "Majority Element",
    "question__title_slug": "majority-element",
    "question__hide": false,
    "total_acs": 494403,
    "total_submitted": 741936,
    "total_column_articles": 2724,
    "frontend_question_id": "169",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.2942874516,
   "progress": 67.0426811881
  },
  "max-stack": {
   "stat": {
    "question_id": 716,
    "question__title": "Max Stack",
    "question__title_slug": "max-stack",
    "question__hide": false,
    "total_acs": 5497,
    "total_submitted": 11620,
    "total_column_articles": 94,
    "frontend_question_id": "716",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": true,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "maximal-square": {
   "stat": {
    "question_id": 221,
    "question__title": "Maximal Square",
    "question__title_slug": "maximal-square",
    "question__hide": false,
    "total_acs": 183176,
    "total_submitted": 376268,
    "total_column_articles": 1238,
    "frontend_question_id": "221",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.8411185455,
   "progress": 57.8201531179
  },
  "maximum-depth-of-binary-tree": {
   "stat": {
    "question_id": 104,
    "question__title": "Maximum Depth of Binary Tree",
    "question__title_slug": "maximum-depth-of-binary-tree",
    "question__hide": false,
    "total_acs": 681324,
    "total_submitted": 885645,
    "total_column_articles": 3291,
    "frontend_question_id": "104",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.4193608521,
   "progress": 69.5880741567
  },
  "maximum-depth-of-n-ary-tree": {
   "stat": {
    "question_id": 774,
    "question__title": "Maximum Depth of N-ary Tree",
    "question__title_slug": "maximum-depth-of-n-ary-tree",
    "question__hide": false,
    "total_acs": 102943,
    "total_submitted": 138582,
    "total_column_articles": 866,
    "frontend_question_id": "559",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.8710885336,
   "progress": 38.0788846973
  },
  "maximum-frequency-stack": {
   "stat": {
    "question_id": 931,
    "question__title": "Maximum Frequency Stack",
    "question__title_slug": "maximum-frequency-stack",
    "question__hide": false,
    "total_acs": 10474,
    "total_submitted": 18152,
    "total_column_articles": 125,
    "frontend_question_id": "895",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2206072023,
   "progress": 45.1920067368
  },
  "maximum-lcci": {
   "stat": {
    "question_id": 100349,
    "question__title": "Maximum LCCI",
    "question__title_slug": "maximum-lcci",
    "question__hide": false,
    "total_acs": 24048,
    "total_submitted": 32765,
    "total_column_articles": 335,
    "frontend_question_id": "面试题 16.07",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.1892940985,
   "progress": 24.2035542602
  },
  "maximum-number-of-balloons": {
   "stat": {
    "question_id": 1297,
    "question__title": "Maximum Number of Balloons",
    "question__title_slug": "maximum-number-of-balloons",
    "question__hide": false,
    "total_acs": 52295,
    "total_submitted": 76039,
    "total_column_articles": 717,
    "frontend_question_id": "1189",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.1705166033,
   "progress": 44.1726032674
  },
  "maximum-product-of-three-numbers": {
   "stat": {
    "question_id": 628,
    "question__title": "Maximum Product of Three Numbers",
    "question__title_slug": "maximum-product-of-three-numbers",
    "question__hide": false,
    "total_acs": 90963,
    "total_submitted": 173526,
    "total_column_articles": 860,
    "frontend_question_id": "628",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.4889428678,
   "progress": 30.3017643295
  },
  "maximum-subarray": {
   "stat": {
    "question_id": 53,
    "question__title": "Maximum Subarray",
    "question__title_slug": "maximum-subarray",
    "question__hide": false,
    "total_acs": 961248,
    "total_submitted": 1748806,
    "total_column_articles": 4969,
    "frontend_question_id": "53",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.0519202245,
   "progress": 82.4614123089
  },
  "maximum-twin-sum-of-a-linked-list": {
   "stat": {
    "question_id": 2236,
    "question__title": "Maximum Twin Sum of a Linked List",
    "question__title_slug": "maximum-twin-sum-of-a-linked-list",
    "question__hide": false,
    "total_acs": 5268,
    "total_submitted": 6306,
    "total_column_articles": 81,
    "frontend_question_id": "2130",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "median-of-two-sorted-arrays": {
   "stat": {
    "question_id": 4,
    "question__title": "Median of Two Sorted Arrays",
    "question__title_slug": "median-of-two-sorted-arrays",
    "question__hide": false,
    "total_acs": 671235,
    "total_submitted": 1625537,
    "total_column_articles": 4962,
    "frontend_question_id": "4",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 4.7253275081,
   "progress": 96.1660542032
  },
  "meeting-rooms": {
   "stat": {
    "question_id": 252,
    "question__title": "Meeting Rooms",
    "question__title_slug": "meeting-rooms",
    "question__hide": false,
    "total_acs": 16371,
    "total_submitted": 28713,
    "total_column_articles": 190,
    "frontend_question_id": "252",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0.5800067008,
   "progress": 11.8038285659
  },
  "merge-in-between-linked-lists": {
   "stat": {
    "question_id": 1765,
    "question__title": "Merge In Between Linked Lists",
    "question__title_slug": "merge-in-between-linked-lists",
    "question__hide": false,
    "total_acs": 16471,
    "total_submitted": 21876,
    "total_column_articles": 301,
    "frontend_question_id": "1669",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "merge-intervals": {
   "stat": {
    "question_id": 56,
    "question__title": "Merge Intervals",
    "question__title_slug": "merge-intervals",
    "question__hide": false,
    "total_acs": 413630,
    "total_submitted": 855832,
    "total_column_articles": 2963,
    "frontend_question_id": "56",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.8698743388,
   "progress": 78.7565612735
  },
  "merge-k-sorted-lists": {
   "stat": {
    "question_id": 23,
    "question__title": "Merge k Sorted Lists",
    "question__title_slug": "merge-k-sorted-lists",
    "question__hide": false,
    "total_acs": 436199,
    "total_submitted": 768448,
    "total_column_articles": 2964,
    "frontend_question_id": "23",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6753014638,
   "progress": 74.7967710562
  },
  "merge-sorted-array": {
   "stat": {
    "question_id": 88,
    "question__title": "Merge Sorted Array",
    "question__title_slug": "merge-sorted-array",
    "question__hide": false,
    "total_acs": 620780,
    "total_submitted": 1189032,
    "total_column_articles": 4233,
    "frontend_question_id": "88",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.0609098571,
   "progress": 82.6443620617
  },
  "merge-two-binary-trees": {
   "stat": {
    "question_id": 617,
    "question__title": "Merge Two Binary Trees",
    "question__title_slug": "merge-two-binary-trees",
    "question__hide": false,
    "total_acs": 260452,
    "total_submitted": 330175,
    "total_column_articles": 1684,
    "frontend_question_id": "617",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.941744745,
   "progress": 59.8680163676
  },
  "merge-two-sorted-lists": {
   "stat": {
    "question_id": 21,
    "question__title": "Merge Two Sorted Lists",
    "question__title_slug": "merge-two-sorted-lists",
    "question__hide": false,
    "total_acs": 949835,
    "total_submitted": 1424980,
    "total_column_articles": 4903,
    "frontend_question_id": "21",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.1835198978,
   "progress": 85.1396227164
  },
  "middle-of-the-linked-list": {
   "stat": {
    "question_id": 908,
    "question__title": "Middle of the Linked List",
    "question__title_slug": "middle-of-the-linked-list",
    "question__hide": false,
    "total_acs": 228831,
    "total_submitted": 323738,
    "total_column_articles": 2331,
    "frontend_question_id": "876",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.8484942981,
   "progress": 57.9702584852
  },
  "min-stack": {
   "stat": {
    "question_id": 155,
    "question__title": "Min Stack",
    "question__title_slug": "min-stack",
    "question__hide": false,
    "total_acs": 360743,
    "total_submitted": 622140,
    "total_column_articles": 1980,
    "frontend_question_id": "155",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.1400805967,
   "progress": 63.9043876542
  },
  "minimum-ascii-delete-sum-for-two-strings": {
   "stat": {
    "question_id": 712,
    "question__title": "Minimum ASCII Delete Sum for Two Strings",
    "question__title_slug": "minimum-ascii-delete-sum-for-two-strings",
    "question__hide": false,
    "total_acs": 20119,
    "total_submitted": 29787,
    "total_column_articles": 228,
    "frontend_question_id": "712",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.5265180158,
   "progress": 10.7152699914
  },
  "minimum-depth-of-binary-tree": {
   "stat": {
    "question_id": 111,
    "question__title": "Minimum Depth of Binary Tree",
    "question__title_slug": "minimum-depth-of-binary-tree",
    "question__hide": false,
    "total_acs": 364137,
    "total_submitted": 728319,
    "total_column_articles": 2577,
    "frontend_question_id": "111",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.4197844314,
   "progress": 49.2455010558
  },
  "minimum-height-tree-lcci": {
   "stat": {
    "question_id": 100174,
    "question__title": "Minimum Height Tree LCCI",
    "question__title_slug": "minimum-height-tree-lcci",
    "question__hide": false,
    "total_acs": 40116,
    "total_submitted": 50933,
    "total_column_articles": 484,
    "frontend_question_id": "面试题 04.02",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.9318605719,
   "progress": 39.3156682056
  },
  "minimum-path-sum": {
   "stat": {
    "question_id": 64,
    "question__title": "Minimum Path Sum",
    "question__title_slug": "minimum-path-sum",
    "question__hide": false,
    "total_acs": 343821,
    "total_submitted": 497276,
    "total_column_articles": 2551,
    "frontend_question_id": "64",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.1852093292,
   "progress": 64.8228112178
  },
  "minimum-size-subarray-sum": {
   "stat": {
    "question_id": 209,
    "question__title": "Minimum Size Subarray Sum",
    "question__title_slug": "minimum-size-subarray-sum",
    "question__hide": false,
    "total_acs": 297526,
    "total_submitted": 614755,
    "total_column_articles": 2054,
    "frontend_question_id": "209",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.9273846175,
   "progress": 59.5757706357
  },
  "missing-number": {
   "stat": {
    "question_id": 268,
    "question__title": "Missing Number",
    "question__title_slug": "missing-number",
    "question__hide": false,
    "total_acs": 222256,
    "total_submitted": 338976,
    "total_column_articles": 1692,
    "frontend_question_id": "268",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.4020785864,
   "progress": 48.8851659795
  },
  "missing-ranges": {
   "stat": {
    "question_id": 163,
    "question__title": "Missing Ranges",
    "question__title_slug": "missing-ranges",
    "question__hide": false,
    "total_acs": 12661,
    "total_submitted": 37026,
    "total_column_articles": 196,
    "frontend_question_id": "163",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 2.1047033847,
   "progress": 42.8332257251
  },
  "most-common-word": {
   "stat": {
    "question_id": 837,
    "question__title": "Most Common Word",
    "question__title_slug": "most-common-word",
    "question__hide": false,
    "total_acs": 25841,
    "total_submitted": 61076,
    "total_column_articles": 301,
    "frontend_question_id": "819",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "move-zeroes": {
   "stat": {
    "question_id": 283,
    "question__title": "Move Zeroes",
    "question__title_slug": "move-zeroes",
    "question__hide": false,
    "total_acs": 697458,
    "total_submitted": 1090628,
    "total_column_articles": 4388,
    "frontend_question_id": "283",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.522799589,
   "progress": 71.6931759008
  },
  "moving-average-from-data-stream": {
   "stat": {
    "question_id": 346,
    "question__title": "Moving Average from Data Stream",
    "question__title_slug": "moving-average-from-data-stream",
    "question__hide": false,
    "total_acs": 15414,
    "total_submitted": 21585,
    "total_column_articles": 165,
    "frontend_question_id": "346",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "multiply-strings": {
   "stat": {
    "question_id": 43,
    "question__title": "Multiply Strings",
    "question__title_slug": "multiply-strings",
    "question__hide": false,
    "total_acs": 213517,
    "total_submitted": 475819,
    "total_column_articles": 1421,
    "frontend_question_id": "43",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.9405789995,
   "progress": 80.1954855013
  },
  "n-ary-tree-level-order-traversal": {
   "stat": {
    "question_id": 764,
    "question__title": "N-ary Tree Level Order Traversal",
    "question__title_slug": "n-ary-tree-level-order-traversal",
    "question__hide": false,
    "total_acs": 79550,
    "total_submitted": 111117,
    "total_column_articles": 636,
    "frontend_question_id": "429",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.068611453,
   "progress": 21.7475183975
  },
  "n-ary-tree-preorder-traversal": {
   "stat": {
    "question_id": 775,
    "question__title": "N-ary Tree Preorder Traversal",
    "question__title_slug": "n-ary-tree-preorder-traversal",
    "question__hide": false,
    "total_acs": 140547,
    "total_submitted": 184917,
    "total_column_articles": 907,
    "frontend_question_id": "589",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.1046308469,
   "progress": 2.1293626056
  },
  "n-th-tribonacci-number": {
   "stat": {
    "question_id": 1236,
    "question__title": "N-th Tribonacci Number",
    "question__title_slug": "n-th-tribonacci-number",
    "question__hide": false,
    "total_acs": 120305,
    "total_submitted": 198024,
    "total_column_articles": 1162,
    "frontend_question_id": "1137",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.0141438077,
   "progress": 40.9902302544
  },
  "next-greater-element-i": {
   "stat": {
    "question_id": 496,
    "question__title": "Next Greater Element I",
    "question__title_slug": "next-greater-element-i",
    "question__hide": false,
    "total_acs": 171111,
    "total_submitted": 241097,
    "total_column_articles": 1692,
    "frontend_question_id": "496",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.7297576489,
   "progress": 55.5538259676
  },
  "nim-game": {
   "stat": {
    "question_id": 292,
    "question__title": "Nim Game",
    "question__title_slug": "nim-game",
    "question__hide": false,
    "total_acs": 129361,
    "total_submitted": 182803,
    "total_column_articles": 863,
    "frontend_question_id": "292",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.626186303,
   "progress": 53.446025472
  },
  "number-complement": {
   "stat": {
    "question_id": 476,
    "question__title": "Number Complement",
    "question__title_slug": "number-complement",
    "question__hide": false,
    "total_acs": 69060,
    "total_submitted": 97100,
    "total_column_articles": 922,
    "frontend_question_id": "476",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.1370163737,
   "progress": 43.4908336148
  },
  "number-of-1-bits": {
   "stat": {
    "question_id": 191,
    "question__title": "Number of 1 Bits",
    "question__title_slug": "number-of-1-bits",
    "question__hide": false,
    "total_acs": 240947,
    "total_submitted": 318523,
    "total_column_articles": 1539,
    "frontend_question_id": "191",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.8114490549,
   "progress": 16.5139566859
  },
  "number-of-enclaves": {
   "stat": {
    "question_id": 1073,
    "question__title": "Number of Enclaves",
    "question__title_slug": "number-of-enclaves",
    "question__hide": false,
    "total_acs": 40566,
    "total_submitted": 66610,
    "total_column_articles": 581,
    "frontend_question_id": "1020",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.9858693768,
   "progress": 40.4148118425
  },
  "number-of-islands": {
   "stat": {
    "question_id": 200,
    "question__title": "Number of Islands",
    "question__title_slug": "number-of-islands",
    "question__hide": false,
    "total_acs": 441158,
    "total_submitted": 769244,
    "total_column_articles": 2709,
    "frontend_question_id": "200",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6589371648,
   "progress": 74.4637380403
  },
  "number-of-matching-subsequences": {
   "stat": {
    "question_id": 808,
    "question__title": "Number of Matching Subsequences",
    "question__title_slug": "number-of-matching-subsequences",
    "question__hide": false,
    "total_acs": 10831,
    "total_submitted": 23107,
    "total_column_articles": 119,
    "frontend_question_id": "792",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.1573220658,
   "progress": 23.552885238
  },
  "number-of-provinces": {
   "stat": {
    "question_id": 547,
    "question__title": "Number of Provinces",
    "question__title_slug": "number-of-provinces",
    "question__hide": false,
    "total_acs": 200340,
    "total_submitted": 323299,
    "total_column_articles": 1439,
    "frontend_question_id": "547",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.8710885336,
   "progress": 38.0788846973
  },
  "number-of-recent-calls": {
   "stat": {
    "question_id": 969,
    "question__title": "Number of Recent Calls",
    "question__title_slug": "number-of-recent-calls",
    "question__hide": false,
    "total_acs": 44568,
    "total_submitted": 61059,
    "total_column_articles": 387,
    "frontend_question_id": "933",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.8710885336,
   "progress": 38.0788846973
  },
  "number-of-segments-in-a-string": {
   "stat": {
    "question_id": 434,
    "question__title": "Number of Segments in a String",
    "question__title_slug": "number-of-segments-in-a-string",
    "question__hide": false,
    "total_acs": 71581,
    "total_submitted": 179948,
    "total_column_articles": 974,
    "frontend_question_id": "434",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.3427818015,
   "progress": 68.0295990846
  },
  "occurrences-after-bigram": {
   "stat": {
    "question_id": 1156,
    "question__title": "Occurrences After Bigram",
    "question__title_slug": "occurrences-after-bigram",
    "question__hide": false,
    "total_acs": 33145,
    "total_submitted": 50508,
    "total_column_articles": 452,
    "frontend_question_id": "1078",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.9009557638,
   "progress": 38.686718477
  },
  "odd-even-linked-list": {
   "stat": {
    "question_id": 328,
    "question__title": "Odd Even Linked List",
    "question__title_slug": "odd-even-linked-list",
    "question__hide": false,
    "total_acs": 153241,
    "total_submitted": 234397,
    "total_column_articles": 1242,
    "frontend_question_id": "328",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.8411185455,
   "progress": 57.8201531179
  },
  "one-edit-distance": {
   "stat": {
    "question_id": 161,
    "question__title": "One Edit Distance",
    "question__title_slug": "one-edit-distance",
    "question__hide": false,
    "total_acs": 9662,
    "total_submitted": 28597,
    "total_column_articles": 129,
    "frontend_question_id": "161",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "opLdQZ": {
   "stat": {
    "question_id": 1000319,
    "question__title": "二叉搜索树中两个节点之和",
    "question__title_slug": "opLdQZ",
    "question__hide": false,
    "total_acs": 11714,
    "total_submitted": 16041,
    "total_column_articles": 163,
    "frontend_question_id": "剑指 Offer II 056",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.0970628743,
   "progress": 22.3265387746
  },
  "palindrome-linked-list": {
   "stat": {
    "question_id": 234,
    "question__title": "Palindrome Linked List",
    "question__title_slug": "palindrome-linked-list",
    "question__hide": false,
    "total_acs": 405172,
    "total_submitted": 791242,
    "total_column_articles": 2531,
    "frontend_question_id": "234",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7984608796,
   "progress": 56.9520187069
  },
  "palindrome-number": {
   "stat": {
    "question_id": 9,
    "question__title": "Palindrome Number",
    "question__title_slug": "palindrome-number",
    "question__hide": false,
    "total_acs": 981325,
    "total_submitted": 1708672,
    "total_column_articles": 6141,
    "frontend_question_id": "9",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.2521221373,
   "progress": 86.5357601641
  },
  "palindrome-permutation": {
   "stat": {
    "question_id": 266,
    "question__title": "Palindrome Permutation",
    "question__title_slug": "palindrome-permutation",
    "question__hide": false,
    "total_acs": 8612,
    "total_submitted": 12468,
    "total_column_articles": 126,
    "frontend_question_id": "266",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "partition-list": {
   "stat": {
    "question_id": 86,
    "question__title": "Partition List",
    "question__title_slug": "partition-list",
    "question__hide": false,
    "total_acs": 144149,
    "total_submitted": 227980,
    "total_column_articles": 1329,
    "frontend_question_id": "86",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2600538248,
   "progress": 45.9947925816
  },
  "pascals-triangle": {
   "stat": {
    "question_id": 118,
    "question__title": "Pascal's Triangle",
    "question__title_slug": "pascals-triangle",
    "question__hide": false,
    "total_acs": 287127,
    "total_submitted": 385264,
    "total_column_articles": 2292,
    "frontend_question_id": "118",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.3814713465,
   "progress": 68.8169774982
  },
  "path-sum": {
   "stat": {
    "question_id": 112,
    "question__title": "Path Sum",
    "question__title_slug": "path-sum",
    "question__hide": false,
    "total_acs": 361732,
    "total_submitted": 680948,
    "total_column_articles": 2227,
    "frontend_question_id": "112",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.8135989223,
   "progress": 57.260095941
  },
  "peak-index-in-a-mountain-array": {
   "stat": {
    "question_id": 882,
    "question__title": "Peak Index in a Mountain Array",
    "question__title_slug": "peak-index-in-a-mountain-array",
    "question__hide": false,
    "total_acs": 98076,
    "total_submitted": 138314,
    "total_column_articles": 841,
    "frontend_question_id": "852",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "perfect-squares": {
   "stat": {
    "question_id": 279,
    "question__title": "Perfect Squares",
    "question__title_slug": "perfect-squares",
    "question__hide": false,
    "total_acs": 264423,
    "total_submitted": 410115,
    "total_column_articles": 1497,
    "frontend_question_id": "279",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.1230839834,
   "progress": 63.5584862882
  },
  "permutations": {
   "stat": {
    "question_id": 46,
    "question__title": "Permutations",
    "question__title_slug": "permutations",
    "question__hide": false,
    "total_acs": 573758,
    "total_submitted": 730970,
    "total_column_articles": 3933,
    "frontend_question_id": "46",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.8643098812,
   "progress": 78.6433179212
  },
  "plus-one": {
   "stat": {
    "question_id": 66,
    "question__title": "Plus One",
    "question__title_slug": "plus-one",
    "question__hide": false,
    "total_acs": 467841,
    "total_submitted": 1016986,
    "total_column_articles": 4196,
    "frontend_question_id": "66",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.2592608295,
   "progress": 66.3298476258
  },
  "plus-one-linked-list": {
   "stat": {
    "question_id": 369,
    "question__title": "Plus One Linked List",
    "question__title_slug": "plus-one-linked-list",
    "question__hide": false,
    "total_acs": 5741,
    "total_submitted": 9192,
    "total_column_articles": 159,
    "frontend_question_id": "369",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0.6085311675,
   "progress": 12.3843355058
  },
  "populating-next-right-pointers-in-each-node": {
   "stat": {
    "question_id": 116,
    "question__title": "Populating Next Right Pointers in Each Node",
    "question__title_slug": "populating-next-right-pointers-in-each-node",
    "question__hide": false,
    "total_acs": 231272,
    "total_submitted": 324190,
    "total_column_articles": 1837,
    "frontend_question_id": "116",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7868507779,
   "progress": 56.7157392809
  },
  "populating-next-right-pointers-in-each-node-ii": {
   "stat": {
    "question_id": 117,
    "question__title": "Populating Next Right Pointers in Each Node II",
    "question__title_slug": "populating-next-right-pointers-in-each-node-ii",
    "question__hide": false,
    "total_acs": 124307,
    "total_submitted": 195892,
    "total_column_articles": 1019,
    "frontend_question_id": "117",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.4540225138,
   "progress": 9.2399000056
  },
  "power-of-three": {
   "stat": {
    "question_id": 326,
    "question__title": "Power of Three",
    "question__title_slug": "power-of-three",
    "question__hide": false,
    "total_acs": 159606,
    "total_submitted": 315386,
    "total_column_articles": 687,
    "frontend_question_id": "326",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.626186303,
   "progress": 53.446025472
  },
  "power-of-two": {
   "stat": {
    "question_id": 231,
    "question__title": "Power of Two",
    "question__title_slug": "power-of-two",
    "question__hide": false,
    "total_acs": 215127,
    "total_submitted": 426554,
    "total_column_articles": 1561,
    "frontend_question_id": "231",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 0,
   "progress": 0
  },
  "powx-n": {
   "stat": {
    "question_id": 50,
    "question__title": "Pow(x, n)",
    "question__title_slug": "powx-n",
    "question__hide": false,
    "total_acs": 274593,
    "total_submitted": 726146,
    "total_column_articles": 1622,
    "frontend_question_id": "50",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.4614653983,
   "progress": 70.4449519206
  },
  "print-foobar-alternately": {
   "stat": {
    "question_id": 1187,
    "question__title": "Print FooBar Alternately",
    "question__title_slug": "print-foobar-alternately",
    "question__hide": false,
    "total_acs": 50229,
    "total_submitted": 89400,
    "total_column_articles": 528,
    "frontend_question_id": "1115",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.6923018326,
   "progress": 34.4403619616
  },
  "print-in-order": {
   "stat": {
    "question_id": 1203,
    "question__title": "Print in Order",
    "question__title_slug": "print-in-order",
    "question__hide": false,
    "total_acs": 88874,
    "total_submitted": 136160,
    "total_column_articles": 634,
    "frontend_question_id": "1114",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.2891592352,
   "progress": 66.9383158648
  },
  "print-zero-even-odd": {
   "stat": {
    "question_id": 1216,
    "question__title": "Print Zero Even Odd",
    "question__title_slug": "print-zero-even-odd",
    "question__hide": false,
    "total_acs": 26415,
    "total_submitted": 50089,
    "total_column_articles": 399,
    "frontend_question_id": "1116",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.4283121179,
   "progress": 29.0678562099
  },
  "product-of-array-except-self": {
   "stat": {
    "question_id": 238,
    "question__title": "Product of Array Except Self",
    "question__title_slug": "product-of-array-except-self",
    "question__hide": false,
    "total_acs": 179343,
    "total_submitted": 245260,
    "total_column_articles": 1141,
    "frontend_question_id": "238",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.9635955779,
   "progress": 60.3127068959
  },
  "que-shi-de-shu-zi-lcof": {
   "stat": {
    "question_id": 100331,
    "question__title": "缺失的数字  LCOF",
    "question__title_slug": "que-shi-de-shu-zi-lcof",
    "question__hide": false,
    "total_acs": 241253,
    "total_submitted": 540127,
    "total_column_articles": 1949,
    "frontend_question_id": "剑指 Offer 53 - II",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.6590141204,
   "progress": 54.1141107356
  },
  "range-sum-of-bst": {
   "stat": {
    "question_id": 975,
    "question__title": "Range Sum of BST",
    "question__title_slug": "range-sum-of-bst",
    "question__hide": false,
    "total_acs": 106010,
    "total_submitted": 129201,
    "total_column_articles": 874,
    "frontend_question_id": "938",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.0147118391,
   "progress": 20.6505969277
  },
  "ransom-note": {
   "stat": {
    "question_id": 383,
    "question__title": "Ransom Note",
    "question__title_slug": "ransom-note",
    "question__hide": false,
    "total_acs": 153314,
    "total_submitted": 237993,
    "total_column_articles": 1528,
    "frontend_question_id": "383",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7462787582,
   "progress": 55.8900502587
  },
  "recover-binary-search-tree": {
   "stat": {
    "question_id": 99,
    "question__title": "Recover Binary Search Tree",
    "question__title_slug": "recover-binary-search-tree",
    "question__hide": false,
    "total_acs": 95072,
    "total_submitted": 157023,
    "total_column_articles": 771,
    "frontend_question_id": "99",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.4750104775,
   "progress": 50.3694170029
  },
  "redundant-connection": {
   "stat": {
    "question_id": 684,
    "question__title": "Redundant Connection",
    "question__title_slug": "redundant-connection",
    "question__hide": false,
    "total_acs": 70842,
    "total_submitted": 105922,
    "total_column_articles": 726,
    "frontend_question_id": "684",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 0.5800067008,
   "progress": 11.8038285659
  },
  "remove-duplicates-from-sorted-array": {
   "stat": {
    "question_id": 26,
    "question__title": "Remove Duplicates from Sorted Array",
    "question__title_slug": "remove-duplicates-from-sorted-array",
    "question__hide": false,
    "total_acs": 1047660,
    "total_submitted": 1945740,
    "total_column_articles": 5700,
    "frontend_question_id": "26",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.9707001092,
   "progress": 80.8084860303
  },
  "remove-duplicates-from-sorted-array-ii": {
   "stat": {
    "question_id": 80,
    "question__title": "Remove Duplicates from Sorted Array II",
    "question__title_slug": "remove-duplicates-from-sorted-array-ii",
    "question__hide": false,
    "total_acs": 173746,
    "total_submitted": 280437,
    "total_column_articles": 1527,
    "frontend_question_id": "80",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.1047033847,
   "progress": 42.8332257251
  },
  "remove-duplicates-from-sorted-list": {
   "stat": {
    "question_id": 83,
    "question__title": "Remove Duplicates from Sorted List",
    "question__title_slug": "remove-duplicates-from-sorted-list",
    "question__hide": false,
    "total_acs": 405914,
    "total_submitted": 757226,
    "total_column_articles": 2500,
    "frontend_question_id": "83",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.3403924951,
   "progress": 47.6297804031
  },
  "remove-duplicates-from-sorted-list-ii": {
   "stat": {
    "question_id": 82,
    "question__title": "Remove Duplicates from Sorted List II",
    "question__title_slug": "remove-duplicates-from-sorted-list-ii",
    "question__hide": false,
    "total_acs": 240293,
    "total_submitted": 450820,
    "total_column_articles": 2124,
    "frontend_question_id": "82",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7496699714,
   "progress": 55.9590654952
  },
  "remove-element": {
   "stat": {
    "question_id": 27,
    "question__title": "Remove Element",
    "question__title_slug": "remove-element",
    "question__hide": false,
    "total_acs": 652475,
    "total_submitted": 1096553,
    "total_column_articles": 5232,
    "frontend_question_id": "27",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.283691326,
   "progress": 66.8270373856
  },
  "remove-linked-list-elements": {
   "stat": {
    "question_id": 203,
    "question__title": "Remove Linked List Elements",
    "question__title_slug": "remove-linked-list-elements",
    "question__hide": false,
    "total_acs": 329565,
    "total_submitted": 619547,
    "total_column_articles": 2218,
    "frontend_question_id": "203",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.9644183997,
   "progress": 19.6270654126
  },
  "remove-nth-node-from-end-of-list": {
   "stat": {
    "question_id": 19,
    "question__title": "Remove Nth Node From End of List",
    "question__title_slug": "remove-nth-node-from-end-of-list",
    "question__hide": false,
    "total_acs": 732257,
    "total_submitted": 1671594,
    "total_column_articles": 5424,
    "frontend_question_id": "19",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.451045226,
   "progress": 70.2328889786
  },
  "reorder-list": {
   "stat": {
    "question_id": 143,
    "question__title": "Reorder List",
    "question__title_slug": "reorder-list",
    "question__hide": false,
    "total_acs": 168009,
    "total_submitted": 264959,
    "total_column_articles": 1355,
    "frontend_question_id": "143",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.7024328079,
   "progress": 75.3489262873
  },
  "repeated-substring-pattern": {
   "stat": {
    "question_id": 459,
    "question__title": "Repeated Substring Pattern",
    "question__title_slug": "repeated-substring-pattern",
    "question__hide": false,
    "total_acs": 105710,
    "total_submitted": 207786,
    "total_column_articles": 825,
    "frontend_question_id": "459",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2887070277,
   "progress": 46.5779194577
  },
  "restore-ip-addresses": {
   "stat": {
    "question_id": 93,
    "question__title": "Restore IP Addresses",
    "question__title_slug": "restore-ip-addresses",
    "question__hide": false,
    "total_acs": 207622,
    "total_submitted": 372044,
    "total_column_articles": 1725,
    "frontend_question_id": "93",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6466050902,
   "progress": 74.2127656044
  },
  "reverse-bits": {
   "stat": {
    "question_id": 190,
    "question__title": "Reverse Bits",
    "question__title_slug": "reverse-bits",
    "question__hide": false,
    "total_acs": 162113,
    "total_submitted": 228969,
    "total_column_articles": 1027,
    "frontend_question_id": "190",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.8142162614,
   "progress": 36.9214660842
  },
  "reverse-integer": {
   "stat": {
    "question_id": 7,
    "question__title": "Reverse Integer",
    "question__title_slug": "reverse-integer",
    "question__hide": false,
    "total_acs": 985854,
    "total_submitted": 2799971,
    "total_column_articles": 6095,
    "frontend_question_id": "7",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.6206192352,
   "progress": 94.0351158879
  },
  "reverse-linked-list": {
   "stat": {
    "question_id": 206,
    "question__title": "Reverse Linked List",
    "question__title_slug": "reverse-linked-list",
    "question__hide": false,
    "total_acs": 972317,
    "total_submitted": 1335029,
    "total_column_articles": 8779,
    "frontend_question_id": "206",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.8456832463,
   "progress": 78.2642436709
  },
  "reverse-linked-list-ii": {
   "stat": {
    "question_id": 92,
    "question__title": "Reverse Linked List II",
    "question__title_slug": "reverse-linked-list-ii",
    "question__hide": false,
    "total_acs": 276560,
    "total_submitted": 500292,
    "total_column_articles": 2630,
    "frontend_question_id": "92",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.5100459408,
   "progress": 71.4336239393
  },
  "reverse-nodes-in-k-group": {
   "stat": {
    "question_id": 25,
    "question__title": "Reverse Nodes in k-Group",
    "question__title_slug": "reverse-nodes-in-k-group",
    "question__hide": false,
    "total_acs": 310879,
    "total_submitted": 466186,
    "total_column_articles": 2816,
    "frontend_question_id": "25",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.8437734183,
   "progress": 78.2253763903
  },
  "reverse-only-letters": {
   "stat": {
    "question_id": 953,
    "question__title": "Reverse Only Letters",
    "question__title_slug": "reverse-only-letters",
    "question__hide": false,
    "total_acs": 66484,
    "total_submitted": 110333,
    "total_column_articles": 934,
    "frontend_question_id": "917",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.0596914066,
   "progress": 62.2683716941
  },
  "reverse-string": {
   "stat": {
    "question_id": 344,
    "question__title": "Reverse String",
    "question__title_slug": "reverse-string",
    "question__hide": false,
    "total_acs": 502356,
    "total_submitted": 641555,
    "total_column_articles": 2627,
    "frontend_question_id": "344",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.855181497,
   "progress": 58.1063509641
  },
  "reverse-string-ii": {
   "stat": {
    "question_id": 541,
    "question__title": "Reverse String II",
    "question__title_slug": "reverse-string-ii",
    "question__hide": false,
    "total_acs": 104386,
    "total_submitted": 175316,
    "total_column_articles": 1036,
    "frontend_question_id": "541",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.0734996051,
   "progress": 42.1981915689
  },
  "reverse-vowels-of-a-string": {
   "stat": {
    "question_id": 345,
    "question__title": "Reverse Vowels of a String",
    "question__title_slug": "reverse-vowels-of-a-string",
    "question__hide": false,
    "total_acs": 123474,
    "total_submitted": 228211,
    "total_column_articles": 1161,
    "frontend_question_id": "345",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.1047033847,
   "progress": 42.8332257251
  },
  "reverse-words-in-a-string": {
   "stat": {
    "question_id": 151,
    "question__title": "Reverse Words in a String",
    "question__title_slug": "reverse-words-in-a-string",
    "question__hide": false,
    "total_acs": 233297,
    "total_submitted": 466569,
    "total_column_articles": 1877,
    "frontend_question_id": "151",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5119306078,
   "progress": 51.1207857181
  },
  "reverse-words-in-a-string-iii": {
   "stat": {
    "question_id": 557,
    "question__title": "Reverse Words in a String III",
    "question__title_slug": "reverse-words-in-a-string-iii",
    "question__hide": false,
    "total_acs": 225585,
    "total_submitted": 304251,
    "total_column_articles": 1880,
    "frontend_question_id": "557",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.5652399732,
   "progress": 72.5568883697
  },
  "richest-customer-wealth": {
   "stat": {
    "question_id": 1791,
    "question__title": "Richest Customer Wealth",
    "question__title_slug": "richest-customer-wealth",
    "question__hide": false,
    "total_acs": 47094,
    "total_submitted": 55325,
    "total_column_articles": 557,
    "frontend_question_id": "1672",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 0.4772469668,
   "progress": 9.7125453418
  },
  "roman-to-integer": {
   "stat": {
    "question_id": 13,
    "question__title": "Roman to Integer",
    "question__title_slug": "roman-to-integer",
    "question__hide": false,
    "total_acs": 596629,
    "total_submitted": 952260,
    "total_column_articles": 4852,
    "frontend_question_id": "13",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.4633130544,
   "progress": 90.8337473713
  },
  "rotate-array": {
   "stat": {
    "question_id": 189,
    "question__title": "Rotate Array",
    "question__title_slug": "rotate-array",
    "question__hide": false,
    "total_acs": 471291,
    "total_submitted": 1062267,
    "total_column_articles": 2382,
    "frontend_question_id": "189",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6986016792,
   "progress": 75.2709582453
  },
  "rotate-image": {
   "stat": {
    "question_id": 48,
    "question__title": "Rotate Image",
    "question__title_slug": "rotate-image",
    "question__hide": false,
    "total_acs": 299862,
    "total_submitted": 405310,
    "total_column_articles": 2759,
    "frontend_question_id": "48",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.4159030938,
   "progress": 69.5177046481
  },
  "rotate-list": {
   "stat": {
    "question_id": 61,
    "question__title": "Rotate List",
    "question__title_slug": "rotate-list",
    "question__hide": false,
    "total_acs": 238129,
    "total_submitted": 570859,
    "total_column_articles": 2385,
    "frontend_question_id": "61",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.4197844314,
   "progress": 49.2455010558
  },
  "rotate-string": {
   "stat": {
    "question_id": 812,
    "question__title": "Rotate String",
    "question__title_slug": "rotate-string",
    "question__hide": false,
    "total_acs": 34630,
    "total_submitted": 60534,
    "total_column_articles": 423,
    "frontend_question_id": "796",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.4469895912,
   "progress": 49.7991585266
  },
  "rotated-digits": {
   "stat": {
    "question_id": 804,
    "question__title": "Rotated Digits",
    "question__title_slug": "rotated-digits",
    "question__hide": false,
    "total_acs": 19568,
    "total_submitted": 32012,
    "total_column_articles": 207,
    "frontend_question_id": "788",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "same-tree": {
   "stat": {
    "question_id": 100,
    "question__title": "Same Tree",
    "question__title_slug": "same-tree",
    "question__hide": false,
    "total_acs": 320256,
    "total_submitted": 535937,
    "total_column_articles": 2353,
    "frontend_question_id": "100",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6197014763,
   "progress": 53.31405151
  },
  "search-a-2d-matrix": {
   "stat": {
    "question_id": 74,
    "question__title": "Search a 2D Matrix",
    "question__title_slug": "search-a-2d-matrix",
    "question__hide": false,
    "total_acs": 219128,
    "total_submitted": 465107,
    "total_column_articles": 2186,
    "frontend_question_id": "74",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6518366269,
   "progress": 53.9680401753
  },
  "search-in-a-binary-search-tree": {
   "stat": {
    "question_id": 783,
    "question__title": "Search in a Binary Search Tree",
    "question__title_slug": "search-in-a-binary-search-tree",
    "question__hide": false,
    "total_acs": 154464,
    "total_submitted": 199325,
    "total_column_articles": 1089,
    "frontend_question_id": "700",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.1536128878,
   "progress": 43.8285924826
  },
  "search-in-a-sorted-array-of-unknown-size": {
   "stat": {
    "question_id": 786,
    "question__title": "Search in a Sorted Array of Unknown Size",
    "question__title_slug": "search-in-a-sorted-array-of-unknown-size",
    "question__hide": false,
    "total_acs": 5639,
    "total_submitted": 7592,
    "total_column_articles": 91,
    "frontend_question_id": "702",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": true,
   "is_favor": true,
   "frequency": 0,
   "progress": 0
  },
  "search-in-rotated-sorted-array": {
   "stat": {
    "question_id": 33,
    "question__title": "Search in Rotated Sorted Array",
    "question__title_slug": "search-in-rotated-sorted-array",
    "question__hide": false,
    "total_acs": 497772,
    "total_submitted": 1147579,
    "total_column_articles": 3244,
    "frontend_question_id": "33",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.5672439418,
   "progress": 72.5976715208
  },
  "search-insert-position": {
   "stat": {
    "question_id": 35,
    "question__title": "Search Insert Position",
    "question__title_slug": "search-insert-position",
    "question__hide": false,
    "total_acs": 742048,
    "total_submitted": 1634432,
    "total_column_articles": 5240,
    "frontend_question_id": "35",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.4745858649,
   "progress": 70.7119690753
  },
  "second-highest-salary": {
   "stat": {
    "question_id": 176,
    "question__title": "Second Highest Salary",
    "question__title_slug": "second-highest-salary",
    "question__hide": false,
    "total_acs": 298397,
    "total_submitted": 840189,
    "total_column_articles": 1231,
    "frontend_question_id": "176",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.9481725117,
   "progress": 80.3500225365
  },
  "second-minimum-node-in-a-binary-tree": {
   "stat": {
    "question_id": 671,
    "question__title": "Second Minimum Node In a Binary Tree",
    "question__title_slug": "second-minimum-node-in-a-binary-tree",
    "question__hide": false,
    "total_acs": 59257,
    "total_submitted": 122499,
    "total_column_articles": 745,
    "frontend_question_id": "671",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.0411824159,
   "progress": 21.1893047561
  },
  "serialize-and-deserialize-binary-tree": {
   "stat": {
    "question_id": 297,
    "question__title": "Serialize and Deserialize Binary Tree",
    "question__title_slug": "serialize-and-deserialize-binary-tree",
    "question__hide": false,
    "total_acs": 142372,
    "total_submitted": 248984,
    "total_column_articles": 956,
    "frontend_question_id": "297",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.9287743945,
   "progress": 59.6040542568
  },
  "set-matrix-zeroes": {
   "stat": {
    "question_id": 73,
    "question__title": "Set Matrix Zeroes",
    "question__title_slug": "set-matrix-zeroes",
    "question__hide": false,
    "total_acs": 175006,
    "total_submitted": 284061,
    "total_column_articles": 1291,
    "frontend_question_id": "73",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5962976466,
   "progress": 52.8377556438
  },
  "shan-chu-lian-biao-de-jie-dian-lcof": {
   "stat": {
    "question_id": 100299,
    "question__title": "删除链表的节点 LCOF",
    "question__title_slug": "shan-chu-lian-biao-de-jie-dian-lcof",
    "question__hide": false,
    "total_acs": 250691,
    "total_submitted": 417342,
    "total_column_articles": 1784,
    "frontend_question_id": "剑指 Offer 18",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.909676876,
   "progress": 38.8642035198
  },
  "shu-zu-zhong-zhong-fu-de-shu-zi-lcof": {
   "stat": {
    "question_id": 100275,
    "question__title": "数组中重复的数字 LCOF",
    "question__title_slug": "shu-zu-zhong-zhong-fu-de-shu-zi-lcof",
    "question__hide": false,
    "total_acs": 529839,
    "total_submitted": 780063,
    "total_column_articles": 3424,
    "frontend_question_id": "剑指 Offer 03",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.9343957076,
   "progress": 80.069648132
  },
  "simplify-path": {
   "stat": {
    "question_id": 71,
    "question__title": "Simplify Path",
    "question__title_slug": "simplify-path",
    "question__hide": false,
    "total_acs": 140498,
    "total_submitted": 317969,
    "total_column_articles": 1363,
    "frontend_question_id": "71",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.439552545,
   "progress": 69.9989992052
  },
  "single-element-in-a-sorted-array": {
   "stat": {
    "question_id": 540,
    "question__title": "Single Element in a Sorted Array",
    "question__title_slug": "single-element-in-a-sorted-array",
    "question__hide": false,
    "total_acs": 92083,
    "total_submitted": 151413,
    "total_column_articles": 914,
    "frontend_question_id": "540",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.3427818015,
   "progress": 68.0295990846
  },
  "single-number": {
   "stat": {
    "question_id": 136,
    "question__title": "Single Number",
    "question__title_slug": "single-number",
    "question__hide": false,
    "total_acs": 649784,
    "total_submitted": 901414,
    "total_column_articles": 2953,
    "frontend_question_id": "136",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.0679303858,
   "progress": 82.7872381993
  },
  "sliding-window-maximum": {
   "stat": {
    "question_id": 239,
    "question__title": "Sliding Window Maximum",
    "question__title_slug": "sliding-window-maximum",
    "question__hide": false,
    "total_acs": 269307,
    "total_submitted": 540284,
    "total_column_articles": 1762,
    "frontend_question_id": "239",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.1710548112,
   "progress": 64.5347498842
  },
  "sort-array-by-parity": {
   "stat": {
    "question_id": 941,
    "question__title": "Sort Array By Parity",
    "question__title_slug": "sort-array-by-parity",
    "question__hide": false,
    "total_acs": 65461,
    "total_submitted": 93552,
    "total_column_articles": 703,
    "frontend_question_id": "905",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.0970628743,
   "progress": 22.3265387746
  },
  "sort-characters-by-frequency": {
   "stat": {
    "question_id": 451,
    "question__title": "Sort Characters By Frequency",
    "question__title_slug": "sort-characters-by-frequency",
    "question__hide": false,
    "total_acs": 96444,
    "total_submitted": 134883,
    "total_column_articles": 1093,
    "frontend_question_id": "451",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.4624530198,
   "progress": 50.1138577529
  },
  "sort-colors": {
   "stat": {
    "question_id": 75,
    "question__title": "Sort Colors",
    "question__title_slug": "sort-colors",
    "question__hide": false,
    "total_acs": 357701,
    "total_submitted": 595803,
    "total_column_articles": 2462,
    "frontend_question_id": "75",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.6907608803,
   "progress": 54.7601951865
  },
  "sort-list": {
   "stat": {
    "question_id": 148,
    "question__title": "Sort List",
    "question__title_slug": "sort-list",
    "question__hide": false,
    "total_acs": 274046,
    "total_submitted": 411931,
    "total_column_articles": 1600,
    "frontend_question_id": "148",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.1174842375,
   "progress": 63.4445247773
  },
  "spiral-matrix": {
   "stat": {
    "question_id": 54,
    "question__title": "Spiral Matrix",
    "question__title_slug": "spiral-matrix",
    "question__hide": false,
    "total_acs": 245900,
    "total_submitted": 506098,
    "total_column_articles": 2619,
    "frontend_question_id": "54",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.8069364031,
   "progress": 77.4756991695
  },
  "spiral-matrix-ii": {
   "stat": {
    "question_id": 59,
    "question__title": "Spiral Matrix II",
    "question__title_slug": "spiral-matrix-ii",
    "question__hide": false,
    "total_acs": 181468,
    "total_submitted": 236741,
    "total_column_articles": 2178,
    "frontend_question_id": "59",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.3375777931,
   "progress": 67.9236913027
  },
  "split-linked-list-in-parts": {
   "stat": {
    "question_id": 725,
    "question__title": "Split Linked List in Parts",
    "question__title_slug": "split-linked-list-in-parts",
    "question__hide": false,
    "total_acs": 53012,
    "total_submitted": 87346,
    "total_column_articles": 672,
    "frontend_question_id": "725",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7417758687,
   "progress": 55.7984110844
  },
  "sqrtx": {
   "stat": {
    "question_id": 69,
    "question__title": "Sqrt(x)",
    "question__title_slug": "sqrtx",
    "question__hide": false,
    "total_acs": 503916,
    "total_submitted": 1296729,
    "total_column_articles": 2528,
    "frontend_question_id": "69",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.5266235392,
   "progress": 71.7709978511
  },
  "string-compression": {
   "stat": {
    "question_id": 443,
    "question__title": "String Compression",
    "question__title_slug": "string-compression",
    "question__hide": false,
    "total_acs": 63106,
    "total_submitted": 132155,
    "total_column_articles": 758,
    "frontend_question_id": "443",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.9970727205,
   "progress": 40.6428132576
  },
  "string-to-integer-atoi": {
   "stat": {
    "question_id": 8,
    "question__title": "String to Integer (atoi)",
    "question__title_slug": "string-to-integer-atoi",
    "question__hide": false,
    "total_acs": 431925,
    "total_submitted": 1991807,
    "total_column_articles": 3260,
    "frontend_question_id": "8",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6217841464,
   "progress": 73.7076297753
  },
  "student-attendance-record-i": {
   "stat": {
    "question_id": 551,
    "question__title": "Student Attendance Record I",
    "question__title_slug": "student-attendance-record-i",
    "question__hide": false,
    "total_acs": 64638,
    "total_submitted": 113897,
    "total_column_articles": 820,
    "frontend_question_id": "551",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.4889428678,
   "progress": 30.3017643295
  },
  "subarray-sum-equals-k": {
   "stat": {
    "question_id": 560,
    "question__title": "Subarray Sum Equals K",
    "question__title_slug": "subarray-sum-equals-k",
    "question__hide": false,
    "total_acs": 208526,
    "total_submitted": 463955,
    "total_column_articles": 1354,
    "frontend_question_id": "560",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.6753014638,
   "progress": 74.7967710562
  },
  "subdomain-visit-count": {
   "stat": {
    "question_id": 829,
    "question__title": "Subdomain Visit Count",
    "question__title_slug": "subdomain-visit-count",
    "question__hide": false,
    "total_acs": 17383,
    "total_submitted": 24470,
    "total_column_articles": 222,
    "frontend_question_id": "811",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "subsets": {
   "stat": {
    "question_id": 78,
    "question__title": "Subsets",
    "question__title_slug": "subsets",
    "question__hide": false,
    "total_acs": 414469,
    "total_submitted": 515447,
    "total_column_articles": 2974,
    "frontend_question_id": "78",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.0264215383,
   "progress": 61.5912901701
  },
  "subsets-ii": {
   "stat": {
    "question_id": 90,
    "question__title": "Subsets II",
    "question__title_slug": "subsets-ii",
    "question__hide": false,
    "total_acs": 186027,
    "total_submitted": 293269,
    "total_column_articles": 1586,
    "frontend_question_id": "90",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.1790871049,
   "progress": 44.3470232024
  },
  "sum-lists-lcci": {
   "stat": {
    "question_id": 100188,
    "question__title": "Sum Lists LCCI",
    "question__title_slug": "sum-lists-lcci",
    "question__hide": false,
    "total_acs": 46497,
    "total_submitted": 99765,
    "total_column_articles": 620,
    "frontend_question_id": "面试题 02.05",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.8923225221,
   "progress": 58.8622151495
  },
  "sum-of-square-numbers": {
   "stat": {
    "question_id": 633,
    "question__title": "Sum of Square Numbers",
    "question__title_slug": "sum-of-square-numbers",
    "question__hide": false,
    "total_acs": 105982,
    "total_submitted": 271634,
    "total_column_articles": 858,
    "frontend_question_id": "633",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.8421948097,
   "progress": 37.4908629341
  },
  "sum-of-two-integers": {
   "stat": {
    "question_id": 371,
    "question__title": "Sum of Two Integers",
    "question__title_slug": "sum-of-two-integers",
    "question__hide": false,
    "total_acs": 90481,
    "total_submitted": 147252,
    "total_column_articles": 563,
    "frontend_question_id": "371",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.8198795609,
   "progress": 57.3879144333
  },
  "sum-root-to-leaf-numbers": {
   "stat": {
    "question_id": 129,
    "question__title": "Sum Root to Leaf Numbers",
    "question__title_slug": "sum-root-to-leaf-numbers",
    "question__hide": false,
    "total_acs": 152163,
    "total_submitted": 220017,
    "total_column_articles": 1386,
    "frontend_question_id": "129",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.3732968606,
   "progress": 48.2994235107
  },
  "summary-ranges": {
   "stat": {
    "question_id": 228,
    "question__title": "Summary Ranges",
    "question__title_slug": "summary-ranges",
    "question__hide": false,
    "total_acs": 68810,
    "total_submitted": 120738,
    "total_column_articles": 779,
    "frontend_question_id": "228",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.0970628743,
   "progress": 22.3265387746
  },
  "surrounded-regions": {
   "stat": {
    "question_id": 130,
    "question__title": "Surrounded Regions",
    "question__title_slug": "surrounded-regions",
    "question__hide": false,
    "total_acs": 165110,
    "total_submitted": 363933,
    "total_column_articles": 1489,
    "frontend_question_id": "130",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2206072023,
   "progress": 45.1920067368
  },
  "swap-nodes-in-pairs": {
   "stat": {
    "question_id": 24,
    "question__title": "Swap Nodes in Pairs",
    "question__title_slug": "swap-nodes-in-pairs",
    "question__hide": false,
    "total_acs": 415643,
    "total_submitted": 587730,
    "total_column_articles": 3211,
    "frontend_question_id": "24",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.251595943,
   "progress": 66.1738580373
  },
  "symmetric-tree": {
   "stat": {
    "question_id": 101,
    "question__title": "Symmetric Tree",
    "question__title_slug": "symmetric-tree",
    "question__hide": false,
    "total_acs": 552515,
    "total_submitted": 962021,
    "total_column_articles": 2981,
    "frontend_question_id": "101",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.3909142873,
   "progress": 69.0091526131
  },
  "tenth-line": {
   "stat": {
    "question_id": 195,
    "question__title": "Tenth Line",
    "question__title_slug": "tenth-line",
    "question__hide": false,
    "total_acs": 41260,
    "total_submitted": 93808,
    "total_column_articles": 160,
    "frontend_question_id": "195",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.722768774,
   "progress": 35.0604005798
  },
  "the-dining-philosophers": {
   "stat": {
    "question_id": 1340,
    "question__title": "The Dining Philosophers",
    "question__title_slug": "the-dining-philosophers",
    "question__hide": false,
    "total_acs": 13958,
    "total_submitted": 23565,
    "total_column_articles": 148,
    "frontend_question_id": "1226",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 2.2520280995,
   "progress": 45.8314594942
  },
  "ti-huan-kong-ge-lcof": {
   "stat": {
    "question_id": 100280,
    "question__title": "替换空格 LCOF",
    "question__title_slug": "ti-huan-kong-ge-lcof",
    "question__hide": false,
    "total_acs": 417097,
    "total_submitted": 549274,
    "total_column_articles": 2539,
    "frontend_question_id": "剑指 Offer 05",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.4136047177,
   "progress": 69.4709299523
  },
  "to-lower-case": {
   "stat": {
    "question_id": 742,
    "question__title": "To Lower Case",
    "question__title_slug": "to-lower-case",
    "question__hide": false,
    "total_acs": 104802,
    "total_submitted": 135618,
    "total_column_articles": 766,
    "frontend_question_id": "709",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.0734996051,
   "progress": 42.1981915689
  },
  "top-k-frequent-elements": {
   "stat": {
    "question_id": 347,
    "question__title": "Top K Frequent Elements",
    "question__title_slug": "top-k-frequent-elements",
    "question__hide": false,
    "total_acs": 270695,
    "total_submitted": 431354,
    "total_column_articles": 1965,
    "frontend_question_id": "347",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.2361448826,
   "progress": 65.8594105186
  },
  "top-k-frequent-words": {
   "stat": {
    "question_id": 692,
    "question__title": "Top K Frequent Words",
    "question__title_slug": "top-k-frequent-words",
    "question__hide": false,
    "total_acs": 78450,
    "total_submitted": 137732,
    "total_column_articles": 846,
    "frontend_question_id": "692",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.0411824159,
   "progress": 21.1893047561
  },
  "traffic-light-controlled-intersection": {
   "stat": {
    "question_id": 1410,
    "question__title": "Traffic Light Controlled Intersection",
    "question__title_slug": "traffic-light-controlled-intersection",
    "question__hide": false,
    "total_acs": 1897,
    "total_submitted": 3023,
    "total_column_articles": 21,
    "frontend_question_id": "1279",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "transpose-matrix": {
   "stat": {
    "question_id": 898,
    "question__title": "Transpose Matrix",
    "question__title_slug": "transpose-matrix",
    "question__hide": false,
    "total_acs": 88589,
    "total_submitted": 132617,
    "total_column_articles": 795,
    "frontend_question_id": "867",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.4889428678,
   "progress": 30.3017643295
  },
  "trapping-rain-water": {
   "stat": {
    "question_id": 42,
    "question__title": "Trapping Rain Water",
    "question__title_slug": "trapping-rain-water",
    "question__hide": false,
    "total_acs": 446046,
    "total_submitted": 738899,
    "total_column_articles": 3087,
    "frontend_question_id": "42",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.3586047816,
   "progress": 88.702809056
  },
  "triangle": {
   "stat": {
    "question_id": 120,
    "question__title": "Triangle",
    "question__title_slug": "triangle",
    "question__hide": false,
    "total_acs": 222885,
    "total_submitted": 325256,
    "total_column_articles": 1946,
    "frontend_question_id": "120",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.6177773302,
   "progress": 32.9236993956
  },
  "two-sum": {
   "stat": {
    "question_id": 1,
    "question__title": "Two Sum",
    "question__title_slug": "two-sum",
    "question__hide": false,
    "total_acs": 3225161,
    "total_submitted": 6153134,
    "total_column_articles": 17093,
    "frontend_question_id": "1",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.9137167447,
   "progress": 100
  },
  "two-sum-ii-input-array-is-sorted": {
   "stat": {
    "question_id": 167,
    "question__title": "Two Sum II - Input Array Is Sorted",
    "question__title_slug": "two-sum-ii-input-array-is-sorted",
    "question__hide": false,
    "total_acs": 403289,
    "total_submitted": 689724,
    "total_column_articles": 2593,
    "frontend_question_id": "167",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.5498868356,
   "progress": 72.2444336951
  },
  "two-sum-iv-input-is-a-bst": {
   "stat": {
    "question_id": 653,
    "question__title": "Two Sum IV - Input is a BST",
    "question__title_slug": "two-sum-iv-input-is-a-bst",
    "question__hide": false,
    "total_acs": 86800,
    "total_submitted": 137912,
    "total_column_articles": 791,
    "frontend_question_id": "653",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "two-sum-less-than-k": {
   "stat": {
    "question_id": 1083,
    "question__title": "Two Sum Less Than K",
    "question__title_slug": "two-sum-less-than-k",
    "question__hide": false,
    "total_acs": 6179,
    "total_submitted": 10419,
    "total_column_articles": 107,
    "frontend_question_id": "1099",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": true,
   "is_favor": false,
   "frequency": 0.5265180158,
   "progress": 10.7152699914
  },
  "ugly-number": {
   "stat": {
    "question_id": 263,
    "question__title": "Ugly Number",
    "question__title_slug": "ugly-number",
    "question__hide": false,
    "total_acs": 122171,
    "total_submitted": 238156,
    "total_column_articles": 940,
    "frontend_question_id": "263",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.722768774,
   "progress": 35.0604005798
  },
  "ugly-number-ii": {
   "stat": {
    "question_id": 264,
    "question__title": "Ugly Number II",
    "question__title_slug": "ugly-number-ii",
    "question__hide": false,
    "total_acs": 120957,
    "total_submitted": 207331,
    "total_column_articles": 760,
    "frontend_question_id": "264",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.3732968606,
   "progress": 48.2994235107
  },
  "unique-binary-search-trees": {
   "stat": {
    "question_id": 96,
    "question__title": "Unique Binary Search Trees",
    "question__title_slug": "unique-binary-search-trees",
    "question__hide": false,
    "total_acs": 227366,
    "total_submitted": 324223,
    "total_column_articles": 1719,
    "frontend_question_id": "96",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.5552173386,
   "progress": 72.3529157933
  },
  "unique-email-addresses": {
   "stat": {
    "question_id": 965,
    "question__title": "Unique Email Addresses",
    "question__title_slug": "unique-email-addresses",
    "question__hide": false,
    "total_acs": 28381,
    "total_submitted": 43957,
    "total_column_articles": 255,
    "frontend_question_id": "929",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0.5526975214,
   "progress": 11.2480541737
  },
  "unique-morse-code-words": {
   "stat": {
    "question_id": 822,
    "question__title": "Unique Morse Code Words",
    "question__title_slug": "unique-morse-code-words",
    "question__hide": false,
    "total_acs": 43233,
    "total_submitted": 55559,
    "total_column_articles": 450,
    "frontend_question_id": "804",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "unique-paths": {
   "stat": {
    "question_id": 62,
    "question__title": "Unique Paths",
    "question__title_slug": "unique-paths",
    "question__hide": false,
    "total_acs": 411185,
    "total_submitted": 614498,
    "total_column_articles": 3036,
    "frontend_question_id": "62",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.2157883223,
   "progress": 65.4451302214
  },
  "unique-paths-ii": {
   "stat": {
    "question_id": 63,
    "question__title": "Unique Paths II",
    "question__title_slug": "unique-paths-ii",
    "question__hide": false,
    "total_acs": 240471,
    "total_submitted": 601248,
    "total_column_articles": 2177,
    "frontend_question_id": "63",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.2600538248,
   "progress": 45.9947925816
  },
  "univalued-binary-tree": {
   "stat": {
    "question_id": 1005,
    "question__title": "Univalued Binary Tree",
    "question__title_slug": "univalued-binary-tree",
    "question__hide": false,
    "total_acs": 38757,
    "total_submitted": 56292,
    "total_column_articles": 465,
    "frontend_question_id": "965",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.0970628743,
   "progress": 22.3265387746
  },
  "utf-8-validation": {
   "stat": {
    "question_id": 393,
    "question__title": "UTF-8 Validation",
    "question__title_slug": "utf-8-validation",
    "question__hide": false,
    "total_acs": 33963,
    "total_submitted": 77295,
    "total_column_articles": 429,
    "frontend_question_id": "393",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "valid-anagram": {
   "stat": {
    "question_id": 242,
    "question__title": "Valid Anagram",
    "question__title_slug": "valid-anagram",
    "question__hide": false,
    "total_acs": 392573,
    "total_submitted": 602357,
    "total_column_articles": 2256,
    "frontend_question_id": "242",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 1.722768774,
   "progress": 35.0604005798
  },
  "valid-palindrome": {
   "stat": {
    "question_id": 125,
    "question__title": "Valid Palindrome",
    "question__title_slug": "valid-palindrome",
    "question__hide": false,
    "total_acs": 343509,
    "total_submitted": 731116,
    "total_column_articles": 2215,
    "frontend_question_id": "125",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.7608329373,
   "progress": 56.1862451748
  },
  "valid-parentheses": {
   "stat": {
    "question_id": 20,
    "question__title": "Valid Parentheses",
    "question__title_slug": "valid-parentheses",
    "question__hide": false,
    "total_acs": 1023501,
    "total_submitted": 2298379,
    "total_column_articles": 7058,
    "frontend_question_id": "20",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 4.2141140154,
   "progress": 85.7622495222
  },
  "valid-perfect-square": {
   "stat": {
    "question_id": 367,
    "question__title": "Valid Perfect Square",
    "question__title_slug": "valid-perfect-square",
    "question__hide": false,
    "total_acs": 143154,
    "total_submitted": 319384,
    "total_column_articles": 1130,
    "frontend_question_id": "367",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.318277485,
   "progress": 47.1797135549
  },
  "valid-square": {
   "stat": {
    "question_id": 593,
    "question__title": "Valid Square",
    "question__title_slug": "valid-square",
    "question__hide": false,
    "total_acs": 9981,
    "total_submitted": 22607,
    "total_column_articles": 162,
    "frontend_question_id": "593",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.1370163737,
   "progress": 43.4908336148
  },
  "validate-binary-search-tree": {
   "stat": {
    "question_id": 98,
    "question__title": "Validate Binary Search Tree",
    "question__title_slug": "validate-binary-search-tree",
    "question__hide": false,
    "total_acs": 472869,
    "total_submitted": 1319101,
    "total_column_articles": 2653,
    "frontend_question_id": "98",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 3.0145503658,
   "progress": 61.3496976421
  },
  "validate-ip-address": {
   "stat": {
    "question_id": 468,
    "question__title": "Validate IP Address",
    "question__title_slug": "validate-ip-address",
    "question__hide": false,
    "total_acs": 31679,
    "total_submitted": 123312,
    "total_column_articles": 359,
    "frontend_question_id": "468",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 1.9858693768,
   "progress": 40.4148118425
  },
  "video-stitching": {
   "stat": {
    "question_id": 1081,
    "question__title": "Video Stitching",
    "question__title_slug": "video-stitching",
    "question__hide": false,
    "total_acs": 36908,
    "total_submitted": 67203,
    "total_column_articles": 416,
    "frontend_question_id": "1024",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 0,
   "progress": 0
  },
  "wildcard-matching": {
   "stat": {
    "question_id": 44,
    "question__title": "Wildcard Matching",
    "question__title_slug": "wildcard-matching",
    "question__hide": false,
    "total_acs": 101499,
    "total_submitted": 306214,
    "total_column_articles": 675,
    "frontend_question_id": "44",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 3
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.5610081696,
   "progress": 52.1195726718
  },
  "word-break": {
   "stat": {
    "question_id": 139,
    "question__title": "Word Break",
    "question__title_slug": "word-break",
    "question__hide": false,
    "total_acs": 273361,
    "total_submitted": 518163,
    "total_column_articles": 1655,
    "frontend_question_id": "139",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.4717099362,
   "progress": 70.653440493
  },
  "word-pattern": {
   "stat": {
    "question_id": 290,
    "question__title": "Word Pattern",
    "question__title_slug": "word-pattern",
    "question__hide": false,
    "total_acs": 98971,
    "total_submitted": 218357,
    "total_column_articles": 1310,
    "frontend_question_id": "290",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.318277485,
   "progress": 47.1797135549
  },
  "word-search": {
   "stat": {
    "question_id": 79,
    "question__title": "Word Search",
    "question__title_slug": "word-search",
    "question__hide": false,
    "total_acs": 294696,
    "total_submitted": 637932,
    "total_column_articles": 1837,
    "frontend_question_id": "79",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 2
   },
   "paid_only": false,
   "is_favor": false,
   "frequency": 2.8576848152,
   "progress": 58.157296477
  },
  "xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof": {
   "stat": {
    "question_id": 100278,
    "question__title": "旋转数组的最小数字  LCOF",
    "question__title_slug": "xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof",
    "question__hide": false,
    "total_acs": 351119,
    "total_submitted": 714386,
    "total_column_articles": 2060,
    "frontend_question_id": "剑指 Offer 11",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.9081263191,
   "progress": 79.5350347235
  },
  "yong-liang-ge-zhan-shi-xian-dui-lie-lcof": {
   "stat": {
    "question_id": 100273,
    "question__title": "用两个栈实现队列 LCOF",
    "question__title_slug": "yong-liang-ge-zhan-shi-xian-dui-lie-lcof",
    "question__hide": false,
    "total_acs": 389901,
    "total_submitted": 549105,
    "total_column_articles": 2256,
    "frontend_question_id": "剑指 Offer 09",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 4.7566543354,
   "progress": 96.8035925271
  },
  "zui-xiao-de-kge-shu-lcof": {
   "stat": {
    "question_id": 100301,
    "question__title": "最小的k个数  LCOF",
    "question__title_slug": "zui-xiao-de-kge-shu-lcof",
    "question__hide": false,
    "total_acs": 321722,
    "total_submitted": 561441,
    "total_column_articles": 2128,
    "frontend_question_id": "剑指 Offer 40",
    "is_new_question": false
   },
   "status": "ac",
   "difficulty": {
    "level": 1
   },
   "paid_only": false,
   "is_favor": true,
   "frequency": 3.0902208789,
   "progress": 62.8896828908
  }
 },
 "ac_problems_detail": {
  "1-bit-and-2-bit-characters": {
   "content": "\u003cp\u003eWe have two special characters:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe first character can be represented by one bit \u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe second character can be represented by two bits (\u003ccode\u003e10\u003c/code\u003e or \u003ccode\u003e11\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eGiven a binary array \u003ccode\u003ebits\u003c/code\u003e that ends with \u003ccode\u003e0\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if the last character must be a one-bit character.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e bits = [1,0,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The only way to decode it is two-bit character and one-bit character.\nSo the last character is one-bit character.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e bits = [1,1,1,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The only way to decode it is two-bit character and two-bit character.\nSo the last character is not one-bit character.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= bits.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebits[i]\u003c/code\u003e is either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Keep track of where the next character starts.  At the end, you want to know if you started on the last bit."
   ],
   "questionId": "717",
   "similarQuestions": "[{\"title\": \"Gray Code\", \"titleSlug\": \"gray-code\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u683c\\u96f7\\u7f16\\u7801\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    }
   ],
   "translatedContent": "\u003cp\u003e有两种特殊字符：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e第一种字符可以用一比特\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e 表示\u003c/li\u003e\n\t\u003cli\u003e第二种字符可以用两比特（\u003ccode\u003e10\u003c/code\u003e\u0026nbsp;或\u0026nbsp;\u003ccode\u003e11\u003c/code\u003e）表示\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e给你一个以 \u003ccode\u003e0\u003c/code\u003e 结尾的二进制数组\u0026nbsp;\u003ccode\u003ebits\u003c/code\u003e\u0026nbsp;，如果最后一个字符必须是一个一比特字符，则返回 \u003ccode\u003etrue\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e bits = [1, 0, 0]\n\u003cstrong\u003e输出:\u003c/strong\u003e true\n\u003cstrong\u003e解释:\u003c/strong\u003e 唯一的解码方式是将其解析为一个两比特字符和一个一比特字符。\n所以最后一个字符是一比特字符。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ebits = [1,1,1,0]\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003cstrong\u003e解释：\u003c/strong\u003e唯一的解码方式是将其解析为两比特字符和两比特字符。\n所以最后一个字符不是一比特字符。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= bits.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebits[i]\u003c/code\u003e 为 \u003ccode\u003e0\u003c/code\u003e 或 \u003ccode\u003e1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "1 比特与 2 比特字符"
  },
  "3sum": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "N6YdxV": {
   "content": "\u003cp\u003eEnglish description is not available for the problem. Please switch to Chinese.\u003c/p\u003e\n",
   "hints": [],
   "questionId": "1000332",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个排序的整数数组 \u003ccode\u003enums\u003c/code\u003e\u0026nbsp;和一个整数目标值\u003ccode\u003e target\u003c/code\u003e ，请在数组中找到\u0026nbsp;\u003ccode\u003etarget\u0026nbsp;\u003c/code\u003e，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\u003c/p\u003e\n\n\u003cp\u003e请必须使用时间复杂度为 \u003ccode\u003eO(log n)\u003c/code\u003e 的算法。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1,3,5,6], target = 5\n\u003cstrong\u003e输出:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1,3,5,6], target = 2\n\u003cstrong\u003e输出:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1,3,5,6], target = 7\n\u003cstrong\u003e输出:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1,3,5,6], target = 0\n\u003cstrong\u003e输出:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 5:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1], target = 0\n\u003cstrong\u003e输出:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e 为\u003cstrong\u003e无重复元素\u003c/strong\u003e的\u003cstrong\u003e升序\u003c/strong\u003e排列数组\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= target \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e注意：本题与主站 35\u0026nbsp;题相同：\u0026nbsp;\u003ca href=\"https://leetcode-cn.com/problems/search-insert-position/\"\u003ehttps://leetcode-cn.com/problems/search-insert-position/\u003c/a\u003e\u003c/p\u003e\n",
   "translatedTitle": "查找插入位置"
  },
  "SLwz0R": {
   "content": "\u003cp\u003eEnglish description is not available for the problem. Please switch to Chinese.\u003c/p\u003e\n",
   "hints": [],
   "questionId": "1000257",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个链表，删除链表的倒数第\u0026nbsp;\u003ccode\u003en\u003c/code\u003e\u003cem\u003e\u0026nbsp;\u003c/em\u003e个结点，并且返回链表的头结点。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,4,5], n = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2,3,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1], n = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2], n = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中结点的数目为 \u003ccode\u003esz\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= sz \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= sz\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e能尝试使用一趟扫描实现吗？\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e注意：本题与主站 19\u0026nbsp;题相同：\u0026nbsp;\u003ca href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\"\u003ehttps://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\u003c/a\u003e\u003c/p\u003e\n",
   "translatedTitle": "删除链表的倒数第 n 个结点"
  },
  "UHnkqh": {
   "content": "\u003cp\u003eEnglish description is not available for the problem. Please switch to Chinese.\u003c/p\u003e\n",
   "hints": [],
   "questionId": "1000260",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    }
   ],
   "translatedContent": "\u003cp\u003e给定单链表的头节点 \u003ccode\u003ehead\u003c/code\u003e ，请反转链表，并返回反转后的链表的头节点。\u003c/p\u003e\n\n\u003cdiv class=\"original__bRMd\"\u003e\n\u003cdiv\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 302px; \" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,4,5]\n\u003cstrong\u003e输出：\u003c/strong\u003e[5,4,3,2,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 102px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e[2,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = []\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点的数目范围是 \u003ccode\u003e[0, 5000]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-5000 \u0026lt;= Node.val \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e注意：本题与主站 206\u0026nbsp;题相同：\u0026nbsp;\u003ca href=\"https://leetcode-cn.com/problems/reverse-linked-list/\"\u003ehttps://leetcode-cn.com/problems/reverse-linked-list/\u003c/a\u003e\u003c/p\u003e\n",
   "translatedTitle": "反转链表"
  },
  "aMhZSa": {
   "content": "\u003cp\u003eEnglish description is not available for the problem. Please switch to Chinese.\u003c/p\u003e\n",
   "hints": [],
   "questionId": "1000263",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个链表的 \u003cstrong\u003e头节点\u0026nbsp;\u003c/strong\u003e\u003ccode\u003ehead\u003c/code\u003e\u003cstrong\u003e\u0026nbsp;，\u003c/strong\u003e请判断其是否为回文链表。\u003c/p\u003e\n\n\u003cp\u003e如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://pic.leetcode-cn.com/1626421737-LjXceN-image.png\" /\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e head = [1,2,3,3,2,1]\n\u003cstrong\u003e输出:\u003c/strong\u003e true\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://pic.leetcode-cn.com/1626422231-wgvnWh-image.png\" style=\"width: 138px; height: 62px;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e head = [1,2]\n\u003cstrong\u003e输出:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表 L 的长度范围为 \u003ccode\u003e[1, 10\u003csup\u003e\u003cspan style=\"font-size: 9.449999809265137px;\"\u003e5\u003c/span\u003e\u003c/sup\u003e]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0\u0026nbsp;\u0026lt;= node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e能否用\u0026nbsp;O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e注意：本题与主站 234\u0026nbsp;题相同：\u003ca href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\"\u003ehttps://leetcode-cn.com/problems/palindrome-linked-list/\u003c/a\u003e\u003c/p\u003e\n",
   "translatedTitle": "回文链表"
  },
  "add-binary": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "add-digits": {
   "content": "\u003cp\u003eGiven an integer \u003ccode\u003enum\u003c/code\u003e, repeatedly add all its digits until the result has only one digit, and return it.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e num = 38\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The process is\n38 --\u0026gt; 3 + 8 --\u0026gt; 11\n11 --\u0026gt; 1 + 1 --\u0026gt; 2 \nSince 2 has only one digit, return it.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e num = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= num \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you do it without any loop/recursion in \u003ccode\u003eO(1)\u003c/code\u003e runtime?\u003c/p\u003e\n",
   "hints": [
    "A naive implementation of the above process is trivial. Could you come up with other methods?",
    "What are all the possible results?",
    "How do they occur, periodically or randomly?",
    "You may find this \u003ca href=\"https://en.wikipedia.org/wiki/Digital_root\" target=\"_blank\"\u003eWikipedia article\u003c/a\u003e useful."
   ],
   "questionId": "258",
   "similarQuestions": "[{\"title\": \"Happy Number\", \"titleSlug\": \"happy-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5feb\\u4e50\\u6570\"}, {\"title\": \"Sum of Digits in the Minimum Number\", \"titleSlug\": \"sum-of-digits-in-the-minimum-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6700\\u5c0f\\u5143\\u7d20\\u5404\\u6570\\u4f4d\\u4e4b\\u548c\"}]",
   "topicTags": [
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Number Theory",
     "slug": "number-theory",
     "translatedName": "数论"
    },
    {
     "name": "Simulation",
     "slug": "simulation",
     "translatedName": "模拟"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个非负整数 \u003ccode\u003enum\u003c/code\u003e，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e num =\u003cstrong\u003e \u003c/strong\u003e\u003ccode\u003e38\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e 2 \n\u003cstrong\u003e解释: \u003c/strong\u003e各位相加的过程为\u003cstrong\u003e：\n\u003c/strong\u003e38 --\u0026gt; 3 + 8 --\u0026gt; 11\n11 --\u0026gt; 1 + 1 --\u0026gt; 2\n由于\u0026nbsp;\u003ccode\u003e2\u003c/code\u003e 是一位数，所以返回 2。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e num =\u003cstrong\u003e \u003c/strong\u003e0\n\u003cstrong\u003e输出:\u003c/strong\u003e 0\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= num \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e\u0026nbsp;- 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你可以不使用循环或者递归，在 \u003ccode\u003eO(1)\u003c/code\u003e 时间复杂度内解决这个问题吗？\u003c/p\u003e\n",
   "translatedTitle": "各位相加"
  },
  "add-strings": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "add-two-numbers": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "add-two-numbers-ii": {
   "content": "\u003cp\u003eYou are given two \u003cstrong\u003enon-empty\u003c/strong\u003e linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\u003c/p\u003e\n\n\u003cp\u003eYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg\" style=\"width: 523px; height: 342px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e l1 = [7,2,4,3], l2 = [5,6,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [7,8,0,7]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e l1 = [2,4,3], l2 = [5,6,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [8,0,7]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e l1 = [0], l2 = [0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in each linked list is in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eIt is guaranteed that the list represents a number that does not have leading zeros.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e\u0026nbsp;Could you solve it without reversing the input lists?\u003c/p\u003e\n",
   "hints": [],
   "questionId": "445",
   "similarQuestions": "[{\"title\": \"Add Two Numbers\", \"titleSlug\": \"add-two-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e24\\u6570\\u76f8\\u52a0\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e给你两个 \u003cstrong\u003e非空 \u003c/strong\u003e链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\u003c/p\u003e\n\n\u003cp\u003e你可以假设除了数字 0 之外，这两个数字都不会以零开头。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png\" style=\"width: 302px; \" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003el1 = [7,2,4,3], l2 = [5,6,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e[7,8,0,7]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003el1 = [2,4,3], l2 = [5,6,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e[8,0,7]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003el1 = [0], l2 = [0]\n\u003cstrong\u003e输出：\u003c/strong\u003e[0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表的长度范围为\u003ccode\u003e [1, 100]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e输入数据保证链表代表的数字无前导 0\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e如果输入链表不能翻转该如何解决？\u003c/p\u003e\n",
   "translatedTitle": "两数相加 II"
  },
  "arranging-coins": {
   "content": "\u003cp\u003eYou have \u003ccode\u003en\u003c/code\u003e coins and you want to build a staircase with these coins. The staircase consists of \u003ccode\u003ek\u003c/code\u003e rows where the \u003ccode\u003ei\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e row has exactly \u003ccode\u003ei\u003c/code\u003e coins. The last row of the staircase \u003cstrong\u003emay be\u003c/strong\u003e incomplete.\u003c/p\u003e\n\n\u003cp\u003eGiven the integer \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003ethe number of \u003cstrong\u003ecomplete rows\u003c/strong\u003e of the staircase you will build\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg\" style=\"width: 253px; height: 253px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Because the 3\u003csup\u003erd\u003c/sup\u003e row is incomplete, we return 2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg\" style=\"width: 333px; height: 333px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 8\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Because the 4\u003csup\u003eth\u003c/sup\u003e row is incomplete, we return 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "441",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e你总共有\u0026nbsp;\u003ccode\u003en\u003c/code\u003e\u003cem\u003e\u0026nbsp;\u003c/em\u003e枚硬币，并计划将它们按阶梯状排列。对于一个由 \u003ccode\u003ek\u003c/code\u003e 行组成的阶梯，其第 \u003ccode\u003ei\u003c/code\u003e\u003cem\u003e \u003c/em\u003e行必须正好有 \u003ccode\u003ei\u003c/code\u003e\u003cem\u003e \u003c/em\u003e枚硬币。阶梯的最后一行 \u003cstrong\u003e可能\u003c/strong\u003e 是不完整的。\u003c/p\u003e\n\n\u003cp\u003e给你一个数字\u0026nbsp;\u003ccode\u003en\u003c/code\u003e\u003cem\u003e \u003c/em\u003e，计算并返回可形成 \u003cstrong\u003e完整阶梯行\u003c/strong\u003e 的总行数。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg\" style=\"width: 253px; height: 253px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 5\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e因为第三行不完整，所以返回 2 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg\" style=\"width: 333px; height: 333px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 8\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e因为第四行不完整，所以返回 3 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "排列硬币"
  },
  "assign-cookies": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "average-of-levels-in-binary-tree": {
   "content": "Given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe average value of the nodes on each level in the form of an array\u003c/em\u003e. Answers within \u003ccode\u003e10\u003csup\u003e-5\u003c/sup\u003e\u003c/code\u003e of the actual answer will be accepted.\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg\" style=\"width: 292px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3.00000,14.50000,11.00000]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "637",
   "similarQuestions": "[{\"title\": \"Binary Tree Level Order Traversal\", \"titleSlug\": \"binary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u5c42\\u5e8f\\u904d\\u5386\"}, {\"title\": \"Binary Tree Level Order Traversal II\", \"titleSlug\": \"binary-tree-level-order-traversal-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u5c42\\u5e8f\\u904d\\u5386 II\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个非空二叉树的根节点\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;, 以数组的形式返回每一层节点的平均值。与实际答案相差\u0026nbsp;\u003ccode\u003e10\u003csup\u003e-5\u003c/sup\u003e\u003c/code\u003e 以内的答案可以被接受。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [3,9,20,null,null,15,7]\n\u003cstrong\u003e输出：\u003c/strong\u003e[3.00000,14.50000,11.00000]\n\u003cstrong\u003e解释：\u003c/strong\u003e第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n因此返回 [3, 14.5, 11] 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [3,9,20,15,7]\n\u003cstrong\u003e输出：\u003c/strong\u003e[3.00000,14.50000,11.00000]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数量在\u0026nbsp;\u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e 范围内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e\u0026nbsp;\u0026lt;= Node.val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e\u0026nbsp;- 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树的层平均值"
  },
  "balanced-binary-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "best-time-to-buy-and-sell-stock": {
   "content": "\u003cp\u003eYou are given an array \u003ccode\u003eprices\u003c/code\u003e where \u003ccode\u003eprices[i]\u003c/code\u003e is the price of a given stock on the \u003ccode\u003ei\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e day.\u003c/p\u003e\n\n\u003cp\u003eYou want to maximize your profit by choosing a \u003cstrong\u003esingle day\u003c/strong\u003e to buy one stock and choosing a \u003cstrong\u003edifferent day in the future\u003c/strong\u003e to sell that stock.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe maximum profit you can achieve from this transaction\u003c/em\u003e. If you cannot achieve any profit, return \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e prices = [7,1,5,3,6,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e prices = [7,6,4,3,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e In this case, no transactions are done and the max profit = 0.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= prices.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= prices[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "121",
   "similarQuestions": "[{\"title\": \"Maximum Subarray\", \"titleSlug\": \"maximum-subarray\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6700\\u5927\\u5b50\\u6570\\u7ec4\\u548c\"}, {\"title\": \"Best Time to Buy and Sell Stock II\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e70\\u5356\\u80a1\\u7968\\u7684\\u6700\\u4f73\\u65f6\\u673a II\"}, {\"title\": \"Best Time to Buy and Sell Stock III\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u4e70\\u5356\\u80a1\\u7968\\u7684\\u6700\\u4f73\\u65f6\\u673a III\"}, {\"title\": \"Best Time to Buy and Sell Stock IV\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-iv\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u4e70\\u5356\\u80a1\\u7968\\u7684\\u6700\\u4f73\\u65f6\\u673a IV\"}, {\"title\": \"Best Time to Buy and Sell Stock with Cooldown\", \"titleSlug\": \"best-time-to-buy-and-sell-stock-with-cooldown\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u4f73\\u4e70\\u5356\\u80a1\\u7968\\u65f6\\u673a\\u542b\\u51b7\\u51bb\\u671f\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个数组 \u003ccode\u003eprices\u003c/code\u003e ，它的第 \u003ccode\u003ei\u003c/code\u003e 个元素 \u003ccode\u003eprices[i]\u003c/code\u003e 表示一支给定股票第 \u003ccode\u003ei\u003c/code\u003e 天的价格。\u003c/p\u003e\n\n\u003cp\u003e你只能选择 \u003cstrong\u003e某一天\u003c/strong\u003e 买入这只股票，并选择在 \u003cstrong\u003e未来的某一个不同的日子\u003c/strong\u003e 卖出该股票。设计一个算法来计算你所能获取的最大利润。\u003c/p\u003e\n\n\u003cp\u003e返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 \u003ccode\u003e0\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e[7,1,5,3,6,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e5\n\u003cstrong\u003e解释：\u003c/strong\u003e在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eprices = [7,6,4,3,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003cstrong\u003e解释：\u003c/strong\u003e在这种情况下, 没有交易完成, 所以最大利润为 0。\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= prices.length \u003c= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= prices[i] \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "买卖股票的最佳时机"
  },
  "best-time-to-buy-and-sell-stock-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "binary-gap": {
   "content": "\u003cp\u003eGiven a positive integer \u003ccode\u003en\u003c/code\u003e, find and return \u003cem\u003ethe \u003cstrong\u003elongest distance\u003c/strong\u003e between any two \u003cstrong\u003eadjacent\u003c/strong\u003e \u003c/em\u003e\u003ccode\u003e1\u003c/code\u003e\u003cem\u003e\u0026#39;s in the binary representation of \u003c/em\u003e\u003ccode\u003en\u003c/code\u003e\u003cem\u003e. If there are no two adjacent \u003c/em\u003e\u003ccode\u003e1\u003c/code\u003e\u003cem\u003e\u0026#39;s, return \u003c/em\u003e\u003ccode\u003e0\u003c/code\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eTwo \u003ccode\u003e1\u003c/code\u003e\u0026#39;s are \u003cstrong\u003eadjacent\u003c/strong\u003e if there are only \u003ccode\u003e0\u003c/code\u003e\u0026#39;s separating them (possibly no \u003ccode\u003e0\u003c/code\u003e\u0026#39;s). The \u003cb\u003edistance\u003c/b\u003e between two \u003ccode\u003e1\u003c/code\u003e\u0026#39;s is the absolute difference between their bit positions. For example, the two \u003ccode\u003e1\u003c/code\u003e\u0026#39;s in \u003ccode\u003e\u0026quot;1001\u0026quot;\u003c/code\u003e have a distance of 3.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 22\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e 22 in binary is \u0026quot;10110\u0026quot;.\nThe first adjacent pair of 1\u0026#39;s is \u0026quot;\u003cu\u003e1\u003c/u\u003e0\u003cu\u003e1\u003c/u\u003e10\u0026quot; with a distance of 2.\nThe second adjacent pair of 1\u0026#39;s is \u0026quot;10\u003cu\u003e11\u003c/u\u003e0\u0026quot; with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that \u0026quot;\u003cu\u003e1\u003c/u\u003e01\u003cu\u003e1\u003c/u\u003e0\u0026quot; is not a valid pair since there is a 1 separating the two 1\u0026#39;s underlined.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 8\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e 8 in binary is \u0026quot;1000\u0026quot;.\nThere are not any adjacent pairs of 1\u0026#39;s in the binary representation of 8, so we return 0.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e 5 in binary is \u0026quot;101\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "899",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个正整数 \u003ccode\u003en\u003c/code\u003e，找到并返回 \u003ccode\u003en\u003c/code\u003e 的二进制表示中两个 \u003cstrong\u003e相邻\u003c/strong\u003e 1 之间的\u003cstrong\u003e 最长距离 \u003c/strong\u003e。如果不存在两个相邻的 1，返回 \u003ccode\u003e0\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e如果只有 \u003ccode\u003e0\u003c/code\u003e 将两个 \u003ccode\u003e1\u003c/code\u003e 分隔开（可能不存在 \u003ccode\u003e0\u003c/code\u003e ），则认为这两个 1 彼此 \u003cstrong\u003e相邻\u003c/strong\u003e 。两个 \u003ccode\u003e1\u003c/code\u003e 之间的距离是它们的二进制表示中位置的绝对差。例如，\u003ccode\u003e\"1001\"\u003c/code\u003e 中的两个 \u003ccode\u003e1\u003c/code\u003e 的距离为 3 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cul\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 22\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e22 的二进制是 \"10110\" 。\n在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。\n第一对相邻的 1 中，两个 1 之间的距离为 2 。\n第二对相邻的 1 中，两个 1 之间的距离为 1 。\n答案取两个距离之中最大的，也就是 2 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 8\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003cstrong\u003e解释：\u003c/strong\u003e8 的二进制是 \"1000\" 。\n在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 5\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e5 的二进制是 \"101\" 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二进制间距"
  },
  "binary-prefix-divisible-by-5": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "binary-search": {
   "content": "\u003cp\u003eGiven an array of integers \u003ccode\u003enums\u003c/code\u003e which is sorted in ascending order, and an integer \u003ccode\u003etarget\u003c/code\u003e, write a function to search \u003ccode\u003etarget\u003c/code\u003e in \u003ccode\u003enums\u003c/code\u003e. If \u003ccode\u003etarget\u003c/code\u003e exists, then return its index. Otherwise, return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou must write an algorithm with \u003ccode\u003eO(log n)\u003c/code\u003e runtime complexity.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [-1,0,3,5,9,12], target = 9\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e 9 exists in nums and its index is 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [-1,0,3,5,9,12], target = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003cstrong\u003eExplanation:\u003c/strong\u003e 2 does not exist in nums so return -1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt; nums[i], target \u0026lt; 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the integers in \u003ccode\u003enums\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e is sorted in ascending order.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "792",
   "similarQuestions": "[{\"title\": \"Search in a Sorted Array of Unknown Size\", \"titleSlug\": \"search-in-a-sorted-array-of-unknown-size\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u641c\\u7d22\\u957f\\u5ea6\\u672a\\u77e5\\u7684\\u6709\\u5e8f\\u6570\\u7ec4\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个\u0026nbsp;\u003ccode\u003en\u003c/code\u003e\u0026nbsp;个元素有序的（升序）整型数组\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e 和一个目标值\u0026nbsp;\u003ccode\u003etarget\u003c/code\u003e \u0026nbsp;，写一个函数搜索\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e\u0026nbsp;中的 \u003ccode\u003etarget\u003c/code\u003e，如果目标值存在返回下标，否则返回 \u003ccode\u003e-1\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cbr\u003e\n\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003enums\u003c/code\u003e = [-1,0,3,5,9,12], \u003ccode\u003etarget\u003c/code\u003e = 9\n\u003cstrong\u003e输出:\u003c/strong\u003e 4\n\u003cstrong\u003e解释:\u003c/strong\u003e 9 出现在 \u003ccode\u003enums\u003c/code\u003e 中并且下标为 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003enums\u003c/code\u003e = [-1,0,3,5,9,12], \u003ccode\u003etarget\u003c/code\u003e = 2\n\u003cstrong\u003e输出:\u003c/strong\u003e -1\n\u003cstrong\u003e解释:\u003c/strong\u003e 2 不存在 \u003ccode\u003enums\u003c/code\u003e 中因此返回 -1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003col\u003e\n\t\u003cli\u003e你可以假设 \u003ccode\u003enums\u003c/code\u003e\u0026nbsp;中的所有元素是不重复的。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en\u003c/code\u003e\u0026nbsp;将在\u0026nbsp;\u003ccode\u003e[1, 10000]\u003c/code\u003e之间。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e\u0026nbsp;的每个元素都将在\u0026nbsp;\u003ccode\u003e[-9999, 9999]\u003c/code\u003e之间。\u003c/li\u003e\n\u003c/ol\u003e\n",
   "translatedTitle": "二分查找"
  },
  "binary-search-tree-iterator": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "binary-search-tree-to-greater-sum-tree": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\u003c/p\u003e\n\n\u003cp\u003eAs a reminder, a \u003cem\u003ebinary search tree\u003c/em\u003e is a tree that satisfies these constraints:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe left subtree of a node contains only nodes with keys \u003cstrong\u003eless than\u003c/strong\u003e the node\u0026#39;s key.\u003c/li\u003e\n\t\u003cli\u003eThe right subtree of a node contains only nodes with keys \u003cstrong\u003egreater than\u003c/strong\u003e the node\u0026#39;s key.\u003c/li\u003e\n\t\u003cli\u003eBoth the left and right subtrees must also be binary search trees.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/02/tree.png\" style=\"width: 400px; height: 273px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values in the tree are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This question is the same as 538: \u003ca href=\"https://leetcode.com/problems/convert-bst-to-greater-tree/\" target=\"_blank\"\u003ehttps://leetcode.com/problems/convert-bst-to-greater-tree/\u003c/a\u003e\u003c/p\u003e\n",
   "hints": [
    "What traversal method organizes all nodes in sorted order?"
   ],
   "questionId": "1114",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e\u003cspan style=\"font-size:10.5pt\"\u003e\u003cspan style=\"font-family:Calibri\"\u003e\u003cspan style=\"font-size:10.5000pt\"\u003e\u003cspan style=\"font-family:宋体\"\u003e\u003cfont face=\"宋体\"\u003e给定一个二叉搜索树\u003c/font\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;(BST)\u003cspan style=\"font-size:10.5pt\"\u003e\u003cspan style=\"font-family:Calibri\"\u003e\u003cspan style=\"font-size:10.5000pt\"\u003e\u003cspan style=\"font-family:宋体\"\u003e\u003cfont face=\"宋体\"\u003e，请将它的每个\u003c/font\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e节点\u003cspan style=\"font-size:10.5pt\"\u003e\u003cspan style=\"font-family:Calibri\"\u003e\u003cspan style=\"font-size:10.5000pt\"\u003e\u003cspan style=\"font-family:宋体\"\u003e\u003cfont face=\"宋体\"\u003e的值替换成树中大于或者等于该\u003c/font\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e节点\u003cspan style=\"font-size:10.5pt\"\u003e\u003cspan style=\"font-family:Calibri\"\u003e\u003cspan style=\"font-size:10.5000pt\"\u003e\u003cspan style=\"font-family:宋体\"\u003e\u003cfont face=\"宋体\"\u003e值的所有\u003c/font\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e节点\u003cspan style=\"font-size:10.5pt\"\u003e\u003cspan style=\"font-family:Calibri\"\u003e\u003cspan style=\"font-size:10.5000pt\"\u003e\u003cspan style=\"font-family:宋体\"\u003e\u003cfont face=\"宋体\"\u003e值之和。\u003c/font\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e提醒一下， \u003cem\u003e二叉搜索树\u003c/em\u003e 满足下列约束条件：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e节点的左子树仅包含键\u003cstrong\u003e 小于 \u003c/strong\u003e节点键的节点。\u003c/li\u003e\n\t\u003cli\u003e节点的右子树仅包含键\u003cstrong\u003e 大于\u003c/strong\u003e 节点键的节点。\u003c/li\u003e\n\t\u003cli\u003e左右子树也必须是二叉搜索树。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height:273px; width:400px\" /\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n\u003cstrong\u003e输出：\u003c/strong\u003e[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [0,null,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中的节点数在\u0026nbsp;\u003ccode\u003e[1, 100]\u003c/code\u003e\u0026nbsp;范围内。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e树中的所有值均 \u003cstrong\u003e不重复\u003c/strong\u003e\u0026nbsp;。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e该题目与 538:\u0026nbsp;\u003ca href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\"\u003ehttps://leetcode-cn.com/problems/convert-bst-to-greater-tree/\u0026nbsp; \u003c/a\u003e相同\u003c/p\u003e\n",
   "translatedTitle": "从二叉搜索树到更大和树"
  },
  "binary-tree-inorder-traversal": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe inorder traversal of its nodes\u0026#39; values\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 125px; height: 200px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,3,2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Recursive solution is trivial, could you do it iteratively?",
   "hints": [],
   "questionId": "94",
   "similarQuestions": "[{\"title\": \"Validate Binary Search Tree\", \"titleSlug\": \"validate-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u9a8c\\u8bc1\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\"}, {\"title\": \"Binary Tree Preorder Traversal\", \"titleSlug\": \"binary-tree-preorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u524d\\u5e8f\\u904d\\u5386\"}, {\"title\": \"Binary Tree Postorder Traversal\", \"titleSlug\": \"binary-tree-postorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u540e\\u5e8f\\u904d\\u5386\"}, {\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u8fed\\u4ee3\\u5668\"}, {\"title\": \"Kth Smallest Element in a BST\", \"titleSlug\": \"kth-smallest-element-in-a-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u4e2d\\u7b2cK\\u5c0f\\u7684\\u5143\\u7d20\"}, {\"title\": \"Closest Binary Search Tree Value II\", \"titleSlug\": \"closest-binary-search-tree-value-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6700\\u63a5\\u8fd1\\u7684\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u503c II\"}, {\"title\": \"Inorder Successor in BST\", \"titleSlug\": \"inorder-successor-in-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u4e2d\\u7684\\u4e2d\\u5e8f\\u540e\\u7ee7\"}, {\"title\": \"Convert Binary Search Tree to Sorted Doubly Linked List\", \"titleSlug\": \"convert-binary-search-tree-to-sorted-doubly-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5c06\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u8f6c\\u5316\\u4e3a\\u6392\\u5e8f\\u7684\\u53cc\\u5411\\u94fe\\u8868\"}, {\"title\": \"Minimum Distance Between BST Nodes\", \"titleSlug\": \"minimum-distance-between-bst-nodes\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u8282\\u70b9\\u6700\\u5c0f\\u8ddd\\u79bb\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个二叉树的根节点 \u003ccode\u003eroot\u003c/code\u003e ，返回 \u003cem\u003e它的 \u003cstrong\u003e中序\u003c/strong\u003e\u0026nbsp;遍历\u003c/em\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"height: 200px; width: 125px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,null,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,3,2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = []\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数目在范围 \u003ccode\u003e[0, 100]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶:\u003c/strong\u003e\u0026nbsp;递归算法很简单，你可以通过迭代算法完成吗？\u003c/p\u003e\n",
   "translatedTitle": "二叉树的中序遍历"
  },
  "binary-tree-level-order-traversal": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe level order traversal of its nodes\u0026#39; values\u003c/em\u003e. (i.e., from left to right, level by level).\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[3],[9,20],[15,7]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 2000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "102",
   "similarQuestions": "[{\"title\": \"Binary Tree Zigzag Level Order Traversal\", \"titleSlug\": \"binary-tree-zigzag-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u952f\\u9f7f\\u5f62\\u5c42\\u5e8f\\u904d\\u5386\"}, {\"title\": \"Binary Tree Level Order Traversal II\", \"titleSlug\": \"binary-tree-level-order-traversal-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u5c42\\u5e8f\\u904d\\u5386 II\"}, {\"title\": \"Minimum Depth of Binary Tree\", \"titleSlug\": \"minimum-depth-of-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u6700\\u5c0f\\u6df1\\u5ea6\"}, {\"title\": \"Binary Tree Vertical Order Traversal\", \"titleSlug\": \"binary-tree-vertical-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u5782\\u76f4\\u904d\\u5386\"}, {\"title\": \"Average of Levels in Binary Tree\", \"titleSlug\": \"average-of-levels-in-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u5c42\\u5e73\\u5747\\u503c\"}, {\"title\": \"N-ary Tree Level Order Traversal\", \"titleSlug\": \"n-ary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": \"N \\u53c9\\u6811\\u7684\\u5c42\\u5e8f\\u904d\\u5386\"}, {\"title\": \"Cousins in Binary Tree\", \"titleSlug\": \"cousins-in-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u5802\\u5144\\u5f1f\\u8282\\u70b9\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给你二叉树的根节点 \u003ccode\u003eroot\u003c/code\u003e ，返回其节点值的 \u003cstrong\u003e层序遍历\u003c/strong\u003e 。 （即逐层地，从左到右访问所有节点）。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [3,9,20,null,null,15,7]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[3],[9,20],[15,7]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = []\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数目在范围 \u003ccode\u003e[0, 2000]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树的层序遍历"
  },
  "binary-tree-level-order-traversal-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "binary-tree-maximum-path-sum": {
   "content": "\u003cp\u003eA \u003cstrong\u003epath\u003c/strong\u003e in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence \u003cstrong\u003eat most once\u003c/strong\u003e. Note that the path does not need to pass through the root.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003epath sum\u003c/strong\u003e of a path is the sum of the node\u0026#39;s values in the path.\u003c/p\u003e\n\n\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe maximum \u003cstrong\u003epath sum\u003c/strong\u003e of any \u003cstrong\u003enon-empty\u003c/strong\u003e path\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The optimal path is 2 -\u0026gt; 1 -\u0026gt; 3 with a path sum of 2 + 1 + 3 = 6.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [-10,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 42\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The optimal path is 15 -\u0026gt; 20 -\u0026gt; 7 with a path sum of 15 + 20 + 7 = 42.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 3 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "124",
   "similarQuestions": "[{\"title\": \"Path Sum\", \"titleSlug\": \"path-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u8def\\u5f84\\u603b\\u548c\"}, {\"title\": \"Sum Root to Leaf Numbers\", \"titleSlug\": \"sum-root-to-leaf-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6c42\\u6839\\u8282\\u70b9\\u5230\\u53f6\\u8282\\u70b9\\u6570\\u5b57\\u4e4b\\u548c\"}, {\"title\": \"Path Sum IV\", \"titleSlug\": \"path-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u8def\\u5f84\\u603b\\u548c IV\"}, {\"title\": \"Longest Univalue Path\", \"titleSlug\": \"longest-univalue-path\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u957f\\u540c\\u503c\\u8def\\u5f84\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e\u003cstrong\u003e路径\u003c/strong\u003e 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 \u003cstrong\u003e至多出现一次\u003c/strong\u003e 。该路径\u003cstrong\u003e 至少包含一个 \u003c/strong\u003e节点，且不一定经过根节点。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e路径和\u003c/strong\u003e 是路径中各节点值的总和。\u003c/p\u003e\n\n\u003cp\u003e给你一个二叉树的根节点 \u003ccode\u003eroot\u003c/code\u003e ，返回其 \u003cstrong\u003e最大路径和\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e6\n\u003cstrong\u003e解释：\u003c/strong\u003e最优路径是 2 -\u003e 1 -\u003e 3 ，路径和为 2 + 1 + 3 = 6\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [-10,9,20,null,null,15,7]\n\u003cstrong\u003e输出：\u003c/strong\u003e42\n\u003cstrong\u003e解释：\u003c/strong\u003e最优路径是 15 -\u003e 20 -\u003e 7 ，路径和为 15 + 20 + 7 = 42\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数目范围是 \u003ccode\u003e[1, 3 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u003c= Node.val \u003c= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树中的最大路径和"
  },
  "binary-tree-paths": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "binary-tree-postorder-traversal": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "binary-tree-preorder-traversal": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "binary-tree-pruning": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, return \u003cem\u003ethe same tree where every subtree (of the given tree) not containing a \u003c/em\u003e\u003ccode\u003e1\u003c/code\u003e\u003cem\u003e has been removed\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eA subtree of a node \u003ccode\u003enode\u003c/code\u003e is \u003ccode\u003enode\u003c/code\u003e plus every node that is a descendant of \u003ccode\u003enode\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width: 500px; height: 140px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,0,0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,null,0,null,1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nOnly the red nodes satisfy the property \u0026quot;every subtree not containing a 1\u0026quot;.\nThe diagram on the right represents the answer.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width: 500px; height: 115px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,0,1,0,0,0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,null,1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width: 500px; height: 134px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,1,0,1,1,0,1,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,1,0,1,1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 200]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eNode.val\u003c/code\u003e is either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "832",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给你二叉树的根结点\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;，此外树的每个结点的值要么是 \u003ccode\u003e0\u003c/code\u003e ，要么是 \u003ccode\u003e1\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e返回移除了所有不包含 \u003ccode\u003e1\u003c/code\u003e 的子树的原二叉树。\u003c/p\u003e\n\n\u003cp\u003e节点 \u003ccode\u003enode\u003c/code\u003e 的子树为 \u003ccode\u003enode\u003c/code\u003e 本身加上所有 \u003ccode\u003enode\u003c/code\u003e 的后代。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width: 500px; height: 140px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,null,0,0,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,null,0,null,1]\n\u003cstrong\u003e解释：\u003c/strong\u003e\n只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width: 500px; height: 115px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,0,1,0,0,0,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,null,1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width: 500px; height: 134px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,1,0,1,1,0,1,0]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,1,0,1,1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点的数目在范围 \u003ccode\u003e[1, 200]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eNode.val\u003c/code\u003e 为 \u003ccode\u003e0\u003c/code\u003e 或 \u003ccode\u003e1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树剪枝"
  },
  "binary-tree-right-side-view": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, imagine yourself standing on the \u003cstrong\u003eright side\u003c/strong\u003e of it, return \u003cem\u003ethe values of the nodes you can see ordered from top to bottom\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 401px; height: 301px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,null,5,null,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,3,4]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "199",
   "similarQuestions": "[{\"title\": \"Populating Next Right Pointers in Each Node\", \"titleSlug\": \"populating-next-right-pointers-in-each-node\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u586b\\u5145\\u6bcf\\u4e2a\\u8282\\u70b9\\u7684\\u4e0b\\u4e00\\u4e2a\\u53f3\\u4fa7\\u8282\\u70b9\\u6307\\u9488\"}, {\"title\": \"Boundary of Binary Tree\", \"titleSlug\": \"boundary-of-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u8fb9\\u754c\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个二叉树的 \u003cstrong\u003e根节点\u003c/strong\u003e \u003ccode\u003eroot\u003c/code\u003e，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 270px; \" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e [1,2,3,null,5,null,4]\n\u003cstrong\u003e输出:\u003c/strong\u003e [1,3,4]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e [1,null,3]\n\u003cstrong\u003e输出:\u003c/strong\u003e [1,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e []\n\u003cstrong\u003e输出:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e二叉树的节点个数的范围是 \u003ccode\u003e[0,100]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003ccode\u003e-100 \u003c= Node.val \u003c= 100\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树的右视图"
  },
  "binary-tree-zigzag-level-order-traversal": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "build-an-array-with-stack-operations": {
   "content": "\u003cp\u003eYou are given an array \u003ccode\u003etarget\u003c/code\u003e and an integer \u003ccode\u003en\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn each iteration, you will read a number from \u003ccode\u003elist = [1, 2, 3, ..., n]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eBuild the \u003ccode\u003etarget\u003c/code\u003e array using the following operations:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e\u0026quot;Push\u0026quot;\u003c/code\u003e: Reads a new element from the beginning list, and pushes it in the array.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e\u0026quot;Pop\u0026quot;\u003c/code\u003e: Deletes the last element of the array.\u003c/li\u003e\n\t\u003cli\u003eIf the target array is already built, stop reading more elements.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003cem\u003ea list of the operations needed to build \u003c/em\u003e\u003ccode\u003etarget\u003c/code\u003e. The test cases are generated so that the answer is \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e target = [1,3], n = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\u0026quot;Push\u0026quot;,\u0026quot;Push\u0026quot;,\u0026quot;Pop\u0026quot;,\u0026quot;Push\u0026quot;]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nRead number 1 and automatically push in the array -\u0026gt; [1]\nRead number 2 and automatically push in the array then Pop it -\u0026gt; [1]\nRead number 3 and automatically push in the array -\u0026gt; [1,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e target = [1,2,3], n = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\u0026quot;Push\u0026quot;,\u0026quot;Push\u0026quot;,\u0026quot;Push\u0026quot;]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e target = [1,2], n = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\u0026quot;Push\u0026quot;,\u0026quot;Push\u0026quot;]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e You only need to read the first 2 numbers and stop.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= target.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= target[i] \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etarget\u003c/code\u003e is strictly increasing.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Use “Push” for numbers to be kept in target array and [“Push”, “Pop”] for numbers to be discarded."
   ],
   "questionId": "1552",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Simulation",
     "slug": "simulation",
     "translatedName": "模拟"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个目标数组 \u003ccode\u003etarget\u003c/code\u003e 和一个整数 \u003ccode\u003en\u003c/code\u003e。每次迭代，需要从\u0026nbsp; \u003ccode\u003elist = {1,2,3..., n}\u003c/code\u003e 中依序读取一个数字。\u003c/p\u003e\n\n\u003cp\u003e请使用下述操作来构建目标数组 \u003ccode\u003etarget\u003c/code\u003e ：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003cstrong\u003ePush\u003c/strong\u003e：从 \u003ccode\u003elist\u003c/code\u003e 中读取一个新元素， 并将其推入数组中。\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003ePop\u003c/strong\u003e：删除数组中的最后一个元素。\u003c/li\u003e\n\t\u003cli\u003e如果目标数组构建完成，就停止读取更多元素。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e题目数据保证目标数组严格递增，并且只包含 \u003ccode\u003e1\u003c/code\u003e 到 \u003ccode\u003en\u003c/code\u003e 之间的数字。\u003c/p\u003e\n\n\u003cp\u003e请返回构建目标数组所用的操作序列。\u003c/p\u003e\n\n\u003cp\u003e题目数据保证答案是唯一的。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etarget = [1,3], n = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e[\"Push\",\"Push\",\"Pop\",\"Push\"]\n\u003cstrong\u003e解释： \n\u003c/strong\u003e读取 1 并自动推入数组 -\u0026gt; [1]\n读取 2 并自动推入数组，然后删除它 -\u0026gt; [1]\n读取 3 并自动推入数组 -\u0026gt; [1,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etarget = [1,2,3], n = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e[\"Push\",\"Push\",\"Push\"]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etarget = [1,2], n = 4\n\u003cstrong\u003e输出：\u003c/strong\u003e[\"Push\",\"Push\"]\n\u003cstrong\u003e解释：\u003c/strong\u003e只需要读取前 2 个数字就可以停止。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= target.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= target[i]\u0026nbsp;\u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etarget\u003c/code\u003e 是严格递增的\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "用栈操作构建数组"
  },
  "building-h2o": {
   "content": "\u003cp\u003eThere are two kinds of threads: \u003ccode\u003eoxygen\u003c/code\u003e and \u003ccode\u003ehydrogen\u003c/code\u003e. Your goal is to group these threads to form water molecules.\u003c/p\u003e\n\n\u003cp\u003eThere is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given \u003ccode\u003ereleaseHydrogen\u003c/code\u003e and \u003ccode\u003ereleaseOxygen\u003c/code\u003e methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.\u003c/p\u003e\n\n\u003cp\u003eIn other words:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eIf an oxygen thread arrives at the barrier when no hydrogen threads are present, it must wait for two hydrogen threads.\u003c/li\u003e\n\t\u003cli\u003eIf a hydrogen thread arrives at the barrier when no other threads are present, it must wait for an oxygen thread and another hydrogen thread.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWe do not have to worry about matching the threads up explicitly; the threads do not necessarily know which other threads they are paired up with. The key is that threads pass the barriers in complete sets; thus, if we examine the sequence of threads that bind and divide them into groups of three, each group should contain one oxygen and two hydrogen threads.\u003c/p\u003e\n\n\u003cp\u003eWrite synchronization code for oxygen and hydrogen molecules that enforces these constraints.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e water = \u0026quot;HOH\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;HHO\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026quot;HOH\u0026quot; and \u0026quot;OHH\u0026quot; are also valid answers.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e water = \u0026quot;OOHHHH\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;HHOHHO\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026quot;HOHHHO\u0026quot;, \u0026quot;OHHHHO\u0026quot;, \u0026quot;HHOHOH\u0026quot;, \u0026quot;HOHHOH\u0026quot;, \u0026quot;OHHHOH\u0026quot;, \u0026quot;HHOOHH\u0026quot;, \u0026quot;HOHOHH\u0026quot; and \u0026quot;OHHOHH\u0026quot; are also valid answers.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 * n == water.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ewater[i]\u003c/code\u003e is either \u003ccode\u003e\u0026#39;H\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;O\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThere will be exactly \u003ccode\u003e2 * n\u003c/code\u003e \u003ccode\u003e\u0026#39;H\u0026#39;\u003c/code\u003e in \u003ccode\u003ewater\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThere will be exactly \u003ccode\u003en\u003c/code\u003e \u003ccode\u003e\u0026#39;O\u0026#39;\u003c/code\u003e in \u003ccode\u003ewater\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "1186",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Concurrency",
     "slug": "concurrency",
     "translatedName": "多线程"
    }
   ],
   "translatedContent": "\u003cp\u003e现在有两种线程，氧 \u003ccode\u003eoxygen\u003c/code\u003e 和氢 \u003ccode\u003ehydrogen\u003c/code\u003e，你的目标是组织这两种线程来产生水分子。\u003c/p\u003e\n\n\u003cp\u003e存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。\u003c/p\u003e\n\n\u003cp\u003e氢和氧线程会被分别给予 \u003ccode\u003ereleaseHydrogen\u003c/code\u003e 和 \u003ccode\u003ereleaseOxygen\u003c/code\u003e 方法来允许它们突破屏障。\u003c/p\u003e\n\n\u003cp\u003e这些线程应该三三成组突破屏障并能立即组合产生一个水分子。\u003c/p\u003e\n\n\u003cp\u003e你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。\u003c/p\u003e\n\n\u003cp\u003e换句话说:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。\u003c/li\u003e\n\t\u003cli\u003e如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e书写满足这些限制条件的氢、氧线程同步代码。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003ewater = \"HOH\"\n\u003cstrong\u003e输出: \u003c/strong\u003e\"HHO\"\n\u003cstrong\u003e解释:\u003c/strong\u003e \"HOH\" 和 \"OHH\" 依然都是有效解。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003ewater = \"OOHHHH\"\n\u003cstrong\u003e输出: \u003c/strong\u003e\"HHOHHO\"\n\u003cstrong\u003e解释:\u003c/strong\u003e \"HOHHHO\", \"OHHHHO\", \"HHOHOH\", \"HOHHOH\", \"OHHHOH\", \"HHOOHH\", \"HOHOHH\" 和 \"OHHOHH\" 依然都是有效解。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 * n == water.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ewater[i] == 'O' or 'H'\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e输入字符串\u0026nbsp;\u003ccode\u003ewater\u003c/code\u003e\u0026nbsp;中的 \u003cfont color=\"#c7254e\"\u003e\u003cfont face=\"Menlo, Monaco, Consolas, Courier New, monospace\"\u003e\u003cspan style=\"font-size:12.6px\"\u003e\u003cspan style=\"background-color:#f9f2f4\"\u003e'H'\u003c/span\u003e\u003c/span\u003e\u003c/font\u003e\u003c/font\u003e\u0026nbsp;总数将会是 \u003ccode\u003e2 * n\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e输入字符串\u0026nbsp;\u003ccode\u003ewater\u003c/code\u003e\u0026nbsp;中的 \u003cfont color=\"#c7254e\"\u003e\u003cfont face=\"Menlo, Monaco, Consolas, Courier New, monospace\"\u003e\u003cspan style=\"font-size:12.6px\"\u003e\u003cspan style=\"background-color:#f9f2f4\"\u003e'O'\u003c/span\u003e\u003c/span\u003e\u003c/font\u003e\u003c/font\u003e\u0026nbsp;总数将会是 \u003ccode\u003en\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "H2O 生成"
  },
  "check-if-a-number-is-majority-element-in-a-sorted-array": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "check-if-it-is-a-straight-line": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "climbing-stairs": {
   "content": "\u003cp\u003eYou are climbing a staircase. It takes \u003ccode\u003en\u003c/code\u003e steps to reach the top.\u003c/p\u003e\n\n\u003cp\u003eEach time you can either climb \u003ccode\u003e1\u003c/code\u003e or \u003ccode\u003e2\u003c/code\u003e steps. In how many distinct ways can you climb to the top?\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 45\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "To reach nth step, what could have been your previous steps? (Think about the step sizes)"
   ],
   "questionId": "70",
   "similarQuestions": "[{\"title\": \"Min Cost Climbing Stairs\", \"titleSlug\": \"min-cost-climbing-stairs\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4f7f\\u7528\\u6700\\u5c0f\\u82b1\\u8d39\\u722c\\u697c\\u68af\"}, {\"title\": \"Fibonacci Number\", \"titleSlug\": \"fibonacci-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6590\\u6ce2\\u90a3\\u5951\\u6570\"}, {\"title\": \"N-th Tribonacci Number\", \"titleSlug\": \"n-th-tribonacci-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u7b2c N \\u4e2a\\u6cf0\\u6ce2\\u90a3\\u5951\\u6570\"}]",
   "topicTags": [
    {
     "name": "Memoization",
     "slug": "memoization",
     "translatedName": "记忆化搜索"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e假设你正在爬楼梯。需要 \u003ccode\u003en\u003c/code\u003e\u0026nbsp;阶你才能到达楼顶。\u003c/p\u003e\n\n\u003cp\u003e每次你可以爬 \u003ccode\u003e1\u003c/code\u003e 或 \u003ccode\u003e2\u003c/code\u003e 个台阶。你有多少种不同的方法可以爬到楼顶呢？\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 45\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "爬楼梯"
  },
  "clone-n-ary-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "closest-binary-search-tree-value": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary search tree and a \u003ccode\u003etarget\u003c/code\u003e value, return \u003cem\u003ethe value in the BST that is closest to the\u003c/em\u003e \u003ccode\u003etarget\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg\" style=\"width: 292px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,2,5,1,3], target = 3.714286\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1], target = 4.428571\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= target \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "270",
   "similarQuestions": "[{\"title\": \"Count Complete Tree Nodes\", \"titleSlug\": \"count-complete-tree-nodes\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b8c\\u5168\\u4e8c\\u53c9\\u6811\\u7684\\u8282\\u70b9\\u4e2a\\u6570\"}, {\"title\": \"Closest Binary Search Tree Value II\", \"titleSlug\": \"closest-binary-search-tree-value-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6700\\u63a5\\u8fd1\\u7684\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u503c II\"}, {\"title\": \"Search in a Binary Search Tree\", \"titleSlug\": \"search-in-a-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u4e2d\\u7684\\u641c\\u7d22\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的数值。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e给定的目标值 target 是一个浮点数\u003c/li\u003e\n\t\u003cli\u003e题目保证在该二叉搜索树中只会存在一个最接近目标值的数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e root = [4,2,5,1,3]，目标值 target = 3.714286\n\n    4\n   / \\\n  2   5\n / \\\n1   3\n\n\u003cstrong\u003e输出:\u003c/strong\u003e 4\n\u003c/pre\u003e\n",
   "translatedTitle": "最接近的二叉搜索树值"
  },
  "combination-sum": {
   "content": "\u003cp\u003eGiven an array of \u003cstrong\u003edistinct\u003c/strong\u003e integers \u003ccode\u003ecandidates\u003c/code\u003e and a target integer \u003ccode\u003etarget\u003c/code\u003e, return \u003cem\u003ea list of all \u003cstrong\u003eunique combinations\u003c/strong\u003e of \u003c/em\u003e\u003ccode\u003ecandidates\u003c/code\u003e\u003cem\u003e where the chosen numbers sum to \u003c/em\u003e\u003ccode\u003etarget\u003c/code\u003e\u003cem\u003e.\u003c/em\u003e You may return the combinations in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003esame\u003c/strong\u003e number may be chosen from \u003ccode\u003ecandidates\u003c/code\u003e an \u003cstrong\u003eunlimited number of times\u003c/strong\u003e. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\u003c/p\u003e\n\n\u003cp\u003eIt is \u003cstrong\u003eguaranteed\u003c/strong\u003e that the number of unique combinations that sum up to \u003ccode\u003etarget\u003c/code\u003e is less than \u003ccode\u003e150\u003c/code\u003e combinations for the given input.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e candidates = [2,3,6,7], target = 7\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[2,2,3],[7]]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e candidates = [2,3,5], target = 8\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[2,2,2,2],[2,3,3],[3,5]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e candidates = [2], target = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= candidates.length \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= candidates[i] \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll elements of \u003ccode\u003ecandidates\u003c/code\u003e are \u003cstrong\u003edistinct\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= target \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "39",
   "similarQuestions": "[{\"title\": \"Letter Combinations of a Phone Number\", \"titleSlug\": \"letter-combinations-of-a-phone-number\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7535\\u8bdd\\u53f7\\u7801\\u7684\\u5b57\\u6bcd\\u7ec4\\u5408\"}, {\"title\": \"Combination Sum II\", \"titleSlug\": \"combination-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7ec4\\u5408\\u603b\\u548c II\"}, {\"title\": \"Combinations\", \"titleSlug\": \"combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7ec4\\u5408\"}, {\"title\": \"Combination Sum III\", \"titleSlug\": \"combination-sum-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7ec4\\u5408\\u603b\\u548c III\"}, {\"title\": \"Factor Combinations\", \"titleSlug\": \"factor-combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u56e0\\u5b50\\u7684\\u7ec4\\u5408\"}, {\"title\": \"Combination Sum IV\", \"titleSlug\": \"combination-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7ec4\\u5408\\u603b\\u548c \\u2163\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Backtracking",
     "slug": "backtracking",
     "translatedName": "回溯"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个 \u003cstrong\u003e无重复元素\u003c/strong\u003e 的整数数组\u0026nbsp;\u003ccode\u003ecandidates\u003c/code\u003e 和一个目标整数\u0026nbsp;\u003ccode\u003etarget\u003c/code\u003e\u0026nbsp;，找出\u0026nbsp;\u003ccode\u003ecandidates\u003c/code\u003e\u0026nbsp;中可以使数字和为目标数\u0026nbsp;\u003ccode\u003etarget\u003c/code\u003e 的 \u003cem\u003e所有\u0026nbsp;\u003c/em\u003e\u003cstrong\u003e不同组合\u003c/strong\u003e ，并以列表形式返回。你可以按 \u003cstrong\u003e任意顺序\u003c/strong\u003e 返回这些组合。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ecandidates\u003c/code\u003e 中的 \u003cstrong\u003e同一个\u003c/strong\u003e 数字可以 \u003cstrong\u003e无限制重复被选取\u003c/strong\u003e 。如果至少一个数字的被选数量不同，则两种组合是不同的。\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e对于给定的输入，保证和为\u0026nbsp;\u003ccode\u003etarget\u003c/code\u003e 的不同组合数少于 \u003ccode\u003e150\u003c/code\u003e 个。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ecandidates = \u003ccode\u003e[2,3,6,7], \u003c/code\u003etarget = \u003ccode\u003e7\u003c/code\u003e\n\u003cstrong\u003e输出：\u003c/strong\u003e[[2,2,3],[7]]\n\u003cstrong\u003e解释：\u003c/strong\u003e\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003ecandidates = [2,3,5]\u003ccode\u003e, \u003c/code\u003etarget = 8\n\u003cstrong\u003e输出: \u003c/strong\u003e[[2,2,2,2],[2,3,3],[3,5]]\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003ecandidates = \u003ccode\u003e[2], \u003c/code\u003etarget = 1\n\u003cstrong\u003e输出: \u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= candidates.length \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= candidates[i] \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ecandidate\u003c/code\u003e 中的每个元素都 \u003cstrong\u003e互不相同\u003c/strong\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= target \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "组合总和"
  },
  "combinations": {
   "content": "\u003cp\u003eGiven two integers \u003ccode\u003en\u003c/code\u003e and \u003ccode\u003ek\u003c/code\u003e, return \u003cem\u003eall possible combinations of\u003c/em\u003e \u003ccode\u003ek\u003c/code\u003e \u003cem\u003enumbers out of the range\u003c/em\u003e \u003ccode\u003e[1, n]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou may return the answer in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 4, k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 1, k = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "77",
   "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7ec4\\u5408\\u603b\\u548c\"}, {\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5168\\u6392\\u5217\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Backtracking",
     "slug": "backtracking",
     "translatedName": "回溯"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个整数 \u003ccode\u003en\u003c/code\u003e 和 \u003ccode\u003ek\u003c/code\u003e，返回范围 \u003ccode\u003e[1, n]\u003c/code\u003e 中所有可能的 \u003ccode\u003ek\u003c/code\u003e 个数的组合。\u003c/p\u003e\n\n\u003cp\u003e你可以按 \u003cstrong\u003e任何顺序\u003c/strong\u003e 返回答案。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 4, k = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 1, k = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1]]\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= n \u003c= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= k \u003c= n\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "组合"
  },
  "cong-wei-dao-tou-da-yin-lian-biao-lcof": {
   "content": "\u003cp\u003eEnglish description is not available for the problem. Please switch to Chinese.\u003c/p\u003e",
   "hints": [],
   "questionId": "100282",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,3,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e[2,3,1]\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e限制：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e0 \u0026lt;= 链表长度 \u0026lt;= 10000\u003c/code\u003e\u003c/p\u003e\n",
   "translatedTitle": "从尾到头打印链表"
  },
  "construct-string-from-binary-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "container-with-most-water": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "contains-duplicate": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if any value appears \u003cstrong\u003eat least twice\u003c/strong\u003e in the array, and return \u003ccode\u003efalse\u003c/code\u003e if every element is distinct.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,1,1,3,3,4,3,2,4,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "217",
   "similarQuestions": "[{\"title\": \"Contains Duplicate II\", \"titleSlug\": \"contains-duplicate-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5b58\\u5728\\u91cd\\u590d\\u5143\\u7d20 II\"}, {\"title\": \"Contains Duplicate III\", \"titleSlug\": \"contains-duplicate-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b58\\u5728\\u91cd\\u590d\\u5143\\u7d20 III\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "给你一个整数数组 \u003ccode\u003enums\u003c/code\u003e 。如果任一值在数组中出现 \u003cstrong\u003e至少两次\u003c/strong\u003e ，返回 \u003ccode\u003etrue\u003c/code\u003e ；如果数组中每个元素互不相同，返回 \u003ccode\u003efalse\u003c/code\u003e 。\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,2,3,1]\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,2,3,4]\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,1,1,3,3,4,3,2,4,2]\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "存在重复元素"
  },
  "contains-duplicate-ii": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e and an integer \u003ccode\u003ek\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if there are two \u003cstrong\u003edistinct indices\u003c/strong\u003e \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ej\u003c/code\u003e in the array such that \u003ccode\u003enums[i] == nums[j]\u003c/code\u003e and \u003ccode\u003eabs(i - j) \u0026lt;= k\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3,1], k = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,0,1,1], k = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3,1,2,3], k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= k \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "219",
   "similarQuestions": "[{\"title\": \"Contains Duplicate\", \"titleSlug\": \"contains-duplicate\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5b58\\u5728\\u91cd\\u590d\\u5143\\u7d20\"}, {\"title\": \"Contains Duplicate III\", \"titleSlug\": \"contains-duplicate-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b58\\u5728\\u91cd\\u590d\\u5143\\u7d20 III\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Sliding Window",
     "slug": "sliding-window",
     "translatedName": "滑动窗口"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数数组\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e 和一个整数\u0026nbsp;\u003ccode\u003ek\u003c/code\u003e ，判断数组中是否存在两个 \u003cstrong\u003e不同的索引\u003c/strong\u003e\u003cem\u003e\u0026nbsp;\u003c/em\u003e\u003ccode\u003ei\u003c/code\u003e\u0026nbsp;和\u003cem\u003e\u0026nbsp;\u003c/em\u003e\u003ccode\u003ej\u003c/code\u003e ，满足 \u003ccode\u003enums[i] == nums[j]\u003c/code\u003e 且 \u003ccode\u003eabs(i - j) \u0026lt;= k\u003c/code\u003e 。如果存在，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,2,3,1], k\u003cem\u003e \u003c/em\u003e= 3\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,0,1,1], k\u003cem\u003e \u003c/em\u003e=\u003cem\u003e \u003c/em\u003e1\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,2,3,1,2,3], k\u003cem\u003e \u003c/em\u003e=\u003cem\u003e \u003c/em\u003e2\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= k \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "存在重复元素 II"
  },
  "continuous-subarray-sum": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e and an integer \u003ccode\u003ek\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e \u003cem\u003eif \u003c/em\u003e\u003ccode\u003enums\u003c/code\u003e\u003cem\u003e has a continuous subarray of size \u003cstrong\u003eat least two\u003c/strong\u003e whose elements sum up to a multiple of\u003c/em\u003e \u003ccode\u003ek\u003c/code\u003e\u003cem\u003e, or \u003c/em\u003e\u003ccode\u003efalse\u003c/code\u003e\u003cem\u003e otherwise\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eAn integer \u003ccode\u003ex\u003c/code\u003e is a multiple of \u003ccode\u003ek\u003c/code\u003e if there exists an integer \u003ccode\u003en\u003c/code\u003e such that \u003ccode\u003ex = n * k\u003c/code\u003e. \u003ccode\u003e0\u003c/code\u003e is \u003cstrong\u003ealways\u003c/strong\u003e a multiple of \u003ccode\u003ek\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [23,\u003cu\u003e2,4\u003c/u\u003e,6,7], k = 6\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [\u003cu\u003e23,2,6,4,7\u003c/u\u003e], k = 6\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [23,2,6,4,7], k = 13\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= sum(nums[i]) \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "523",
   "similarQuestions": "[{\"title\": \"Subarray Sum Equals K\", \"titleSlug\": \"subarray-sum-equals-k\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u548c\\u4e3a K \\u7684\\u5b50\\u6570\\u7ec4\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Prefix Sum",
     "slug": "prefix-sum",
     "translatedName": "前缀和"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数数组 \u003ccode\u003enums\u003c/code\u003e 和一个整数 \u003ccode\u003ek\u003c/code\u003e ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e子数组大小 \u003cstrong\u003e至少为 2\u003c/strong\u003e ，且\u003c/li\u003e\n\t\u003cli\u003e子数组元素总和为 \u003ccode\u003ek\u003c/code\u003e 的倍数。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果存在，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e如果存在一个整数 \u003ccode\u003en\u003c/code\u003e ，令整数 \u003ccode\u003ex\u003c/code\u003e 符合 \u003ccode\u003ex = n * k\u003c/code\u003e ，则称 \u003ccode\u003ex\u003c/code\u003e 是 \u003ccode\u003ek\u003c/code\u003e 的一个倍数。\u003ccode\u003e0\u003c/code\u003e 始终视为 \u003ccode\u003ek\u003c/code\u003e 的一个倍数。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [23\u003cu\u003e,2,4\u003c/u\u003e,6,7], k = 6\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003cstrong\u003e解释：\u003c/strong\u003e[2,4] 是一个大小为 2 的子数组，并且和为 6 。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [\u003cu\u003e23,2,6,4,7\u003c/u\u003e], k = 6\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003cstrong\u003e解释：\u003c/strong\u003e[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [23,2,6,4,7], k = 13\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= nums.length \u003c= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= nums[i] \u003c= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= sum(nums[i]) \u003c= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= k \u003c= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "连续的子数组和"
  },
  "convert-binary-number-in-a-linked-list-to-integer": {
   "content": "\u003cp\u003eGiven \u003ccode\u003ehead\u003c/code\u003e which is a reference node to a singly-linked list. The value of each node in the linked list is either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e. The linked list holds the binary representation of a number.\u003c/p\u003e\n\n\u003cp\u003eReturn the \u003cem\u003edecimal value\u003c/em\u003e of the number in the linked list.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/05/graph-1.png\" style=\"width: 426px; height: 108px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003cstrong\u003eExplanation:\u003c/strong\u003e (101) in base 2 = (5) in base 10\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe Linked List is not empty.\u003c/li\u003e\n\t\u003cli\u003eNumber of nodes\u0026nbsp;will not exceed \u003ccode\u003e30\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eEach node\u0026#39;s value is either\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Traverse the linked list and store all values in a string or array. convert the values obtained to decimal value.",
    "You can solve the problem in O(1) memory using bits operation. use shift left operation ( \u003c\u003c ) and or operation ( | ) to get the decimal value in one operation."
   ],
   "questionId": "1411",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个单链表的引用结点\u0026nbsp;\u003ccode\u003ehead\u003c/code\u003e。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。\u003c/p\u003e\n\n\u003cp\u003e请你返回该链表所表示数字的 \u003cstrong\u003e十进制值\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/graph-1.png\" style=\"height: 108px; width: 426px;\"\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,0,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e5\n\u003cstrong\u003e解释：\u003c/strong\u003e二进制数 (101) 转化为十进制数 (5)\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003ehead = [0]\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1]\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]\n\u003cstrong\u003e输出：\u003c/strong\u003e18880\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 5：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003ehead = [0,0]\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表不为空。\u003c/li\u003e\n\t\u003cli\u003e链表的结点总数不超过\u0026nbsp;\u003ccode\u003e30\u003c/code\u003e。\u003c/li\u003e\n\t\u003cli\u003e每个结点的值不是\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e 就是 \u003ccode\u003e1\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二进制链表转整数"
  },
  "convert-binary-search-tree-to-sorted-doubly-linked-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "convert-bst-to-greater-tree": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\u003c/p\u003e\n\n\u003cp\u003eAs a reminder, a \u003cem\u003ebinary search tree\u003c/em\u003e is a tree that satisfies these constraints:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe left subtree of a node contains only nodes with keys \u003cstrong\u003eless than\u003c/strong\u003e the node\u0026#39;s key.\u003c/li\u003e\n\t\u003cli\u003eThe right subtree of a node contains only nodes with keys \u003cstrong\u003egreater than\u003c/strong\u003e the node\u0026#39;s key.\u003c/li\u003e\n\t\u003cli\u003eBoth the left and right subtrees must also be binary search trees.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/02/tree.png\" style=\"width: 500px; height: 341px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values in the tree are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e is guaranteed to be a valid binary search tree.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This question is the same as 1038: \u003ca href=\"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\" target=\"_blank\"\u003ehttps://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\u003c/a\u003e\u003c/p\u003e\n",
   "hints": [],
   "questionId": "538",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给出二叉\u003cstrong\u003e 搜索 \u003c/strong\u003e树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 \u003ccode\u003enode\u003c/code\u003e\u0026nbsp;的新值等于原树中大于或等于\u0026nbsp;\u003ccode\u003enode.val\u003c/code\u003e\u0026nbsp;的值之和。\u003c/p\u003e\n\n\u003cp\u003e提醒一下，二叉搜索树满足下列约束条件：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e节点的左子树仅包含键\u003cstrong\u003e 小于 \u003c/strong\u003e节点键的节点。\u003c/li\u003e\n\t\u003cli\u003e节点的右子树仅包含键\u003cstrong\u003e 大于\u003c/strong\u003e 节点键的节点。\u003c/li\u003e\n\t\u003cli\u003e左右子树也必须是二叉搜索树。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e本题和 1038:\u0026nbsp;\u003ca href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\"\u003ehttps://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\u003c/a\u003e 相同\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height: 364px; width: 534px;\"\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003e[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n\u003cstrong\u003e输出：\u003c/strong\u003e[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003eroot = [0,null,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,null,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,0,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e[3,3,2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003eroot = [3,2,4,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[7,9,4,10]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中的节点数介于 \u003ccode\u003e0\u003c/code\u003e\u0026nbsp;和 \u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003csup\u003e\u0026nbsp;\u003c/sup\u003e之间。\u003c/li\u003e\n\t\u003cli\u003e每个节点的值介于 \u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u0026nbsp;之间。\u003c/li\u003e\n\t\u003cli\u003e树中的所有值 \u003cstrong\u003e互不相同\u003c/strong\u003e 。\u003c/li\u003e\n\t\u003cli\u003e给定的树为二叉搜索树。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "把二叉搜索树转换为累加树"
  },
  "convert-sorted-array-to-binary-search-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "convert-sorted-list-to-binary-search-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "copy-list-with-random-pointer": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "count-and-say": {
   "content": "\u003cp\u003eThe \u003cstrong\u003ecount-and-say\u003c/strong\u003e sequence is a sequence of digit strings defined by the recursive formula:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003ecountAndSay(1) = \u0026quot;1\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ecountAndSay(n)\u003c/code\u003e is the way you would \u0026quot;say\u0026quot; the digit string from \u003ccode\u003ecountAndSay(n-1)\u003c/code\u003e, which is then converted into a different digit string.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTo determine how you \u0026quot;say\u0026quot; a digit string, split it into the \u003cstrong\u003eminimal\u003c/strong\u003e number of groups so that each group is a contiguous section all of the \u003cstrong\u003esame character.\u003c/strong\u003e Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.\u003c/p\u003e\n\n\u003cp\u003eFor example, the saying and conversion for digit string \u003ccode\u003e\u0026quot;3322251\u0026quot;\u003c/code\u003e:\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg\" style=\"width: 581px; height: 172px;\" /\u003e\n\u003cp\u003eGiven a positive integer \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003ethe \u003c/em\u003e\u003ccode\u003en\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e\u003cem\u003e term of the \u003cstrong\u003ecount-and-say\u003c/strong\u003e sequence\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;1\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e This is the base case.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;1211\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\ncountAndSay(1) = \u0026quot;1\u0026quot;\ncountAndSay(2) = say \u0026quot;1\u0026quot; = one 1 = \u0026quot;11\u0026quot;\ncountAndSay(3) = say \u0026quot;11\u0026quot; = two 1\u0026#39;s = \u0026quot;21\u0026quot;\ncountAndSay(4) = say \u0026quot;21\u0026quot; = one 2 + one 1 = \u0026quot;12\u0026quot; + \u0026quot;11\u0026quot; = \u0026quot;1211\u0026quot;\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "The following are the terms from n=1 to n=10 of the count-and-say sequence:\r\n\u003cpre\u003e\r\n 1.     1\r\n 2.     11\r\n 3.     21\r\n 4.     1211\r\n 5.     111221 \r\n 6.     312211\r\n 7.     13112221\r\n 8.     1113213211\r\n 9.     31131211131221\r\n10.     13211311123113112211\r\n\u003c/pre\u003e",
    "To generate the \u003ci\u003en\u003c/i\u003e\u003csup\u003eth\u003c/sup\u003e term, just \u003ci\u003ecount and say\u003c/i\u003e the \u003ci\u003en\u003c/i\u003e-1\u003csup\u003eth\u003c/sup\u003e term."
   ],
   "questionId": "38",
   "similarQuestions": "[{\"title\": \"Encode and Decode Strings\", \"titleSlug\": \"encode-and-decode-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b57\\u7b26\\u4e32\\u7684\\u7f16\\u7801\\u4e0e\\u89e3\\u7801\"}, {\"title\": \"String Compression\", \"titleSlug\": \"string-compression\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u538b\\u7f29\\u5b57\\u7b26\\u4e32\"}]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个正整数 \u003ccode\u003en\u003c/code\u003e ，输出外观数列的第 \u003ccode\u003en\u003c/code\u003e 项。\u003c/p\u003e\n\n\u003cp\u003e「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。\u003c/p\u003e\n\n\u003cp\u003e你可以将其视作是由递归公式定义的数字字符串序列：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003ecountAndSay(1) = \"1\"\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ecountAndSay(n)\u003c/code\u003e 是对 \u003ccode\u003ecountAndSay(n-1)\u003c/code\u003e 的描述，然后转换成另一个数字字符串。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e前五项如下：\u003c/p\u003e\n\n\u003cpre\u003e\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n第一项是数字 1 \n描述前一项，这个数是 \u003ccode\u003e1\u003c/code\u003e 即 “ 一 个 1 ”，记作 \u003ccode\u003e\"11\"\n\u003c/code\u003e描述前一项，这个数是 \u003ccode\u003e11\u003c/code\u003e 即 “ 二 个 1 ” ，记作 \u003ccode\u003e\"21\"\n\u003c/code\u003e描述前一项，这个数是 \u003ccode\u003e21\u003c/code\u003e 即 “ 一 个 2 + 一 个 1 ” ，记作 \"\u003ccode\u003e1211\"\n\u003c/code\u003e描述前一项，这个数是 \u003ccode\u003e1211\u003c/code\u003e 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \"\u003ccode\u003e111221\"\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e要 \u003cstrong\u003e描述\u003c/strong\u003e 一个数字字符串，首先要将字符串分割为 \u003cstrong\u003e最小\u003c/strong\u003e 数量的组，每个组都由连续的最多 \u003cstrong\u003e相同字符\u003c/strong\u003e 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。\u003c/p\u003e\n\n\u003cp\u003e例如，数字字符串 \u003ccode\u003e\"3322251\"\u003c/code\u003e 的描述如下图：\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png\" style=\"width: 581px; height: 172px;\" /\u003e\n\u003cul\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e\"1\"\n\u003cstrong\u003e解释：\u003c/strong\u003e这是一个基本样例。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 4\n\u003cstrong\u003e输出：\u003c/strong\u003e\"1211\"\n\u003cstrong\u003e解释：\u003c/strong\u003e\ncountAndSay(1) = \"1\"\ncountAndSay(2) = 读 \"1\" = 一 个 1 = \"11\"\ncountAndSay(3) = 读 \"11\" = 二 个 1 = \"21\"\ncountAndSay(4) = 读 \"21\" = 一 个 2 + 一 个 1 = \"12\" + \"11\" = \"1211\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "外观数列"
  },
  "count-binary-substrings": {
   "content": "\u003cp\u003eGive a binary string \u003ccode\u003es\u003c/code\u003e, return the number of non-empty substrings that have the same number of \u003ccode\u003e0\u003c/code\u003e\u0026#39;s and \u003ccode\u003e1\u003c/code\u003e\u0026#39;s, and all the \u003ccode\u003e0\u003c/code\u003e\u0026#39;s and all the \u003ccode\u003e1\u003c/code\u003e\u0026#39;s in these substrings are grouped consecutively.\u003c/p\u003e\n\n\u003cp\u003eSubstrings that occur multiple times are counted the number of times they occur.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;00110011\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are 6 substrings that have equal number of consecutive 1\u0026#39;s and 0\u0026#39;s: \u0026quot;0011\u0026quot;, \u0026quot;01\u0026quot;, \u0026quot;1100\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;0011\u0026quot;, and \u0026quot;01\u0026quot;.\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \u0026quot;00110011\u0026quot; is not a valid substring because all the 0\u0026#39;s (and 1\u0026#39;s) are not grouped together.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;10101\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are 4 substrings: \u0026quot;10\u0026quot;, \u0026quot;01\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;01\u0026quot; that have equal number of consecutive 1\u0026#39;s and 0\u0026#39;s.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es[i]\u003c/code\u003e is either \u003ccode\u003e\u0026#39;0\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;1\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "How many valid binary substrings exist in \"000111\", and how many in \"11100\"?  What about \"00011100\"?"
   ],
   "questionId": "696",
   "similarQuestions": "[{\"title\": \"Encode and Decode Strings\", \"titleSlug\": \"encode-and-decode-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b57\\u7b26\\u4e32\\u7684\\u7f16\\u7801\\u4e0e\\u89e3\\u7801\"}]",
   "topicTags": [
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个字符串\u0026nbsp;\u003ccode\u003es\u003c/code\u003e，统计并返回具有相同数量 \u003ccode\u003e0\u003c/code\u003e 和 \u003ccode\u003e1\u003c/code\u003e 的非空（连续）子字符串的数量，并且这些子字符串中的所有 \u003ccode\u003e0\u003c/code\u003e 和所有 \u003ccode\u003e1\u003c/code\u003e 都是成组连续的。\u003c/p\u003e\n\n\u003cp\u003e重复出现（不同位置）的子串也要统计它们出现的次数。\u003c/p\u003e\n\u0026nbsp;\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"00110011\"\n\u003cstrong\u003e输出：\u003c/strong\u003e6\n\u003cstrong\u003e解释：\u003c/strong\u003e6 个子串满足具有相同数量的连续 1 和 0 ：\"0011\"、\"01\"、\"1100\"、\"10\"、\"0011\" 和 \"01\" 。\n注意，一些重复出现的子串（不同位置）要统计它们出现的次数。\n另外，\"00110011\" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"10101\"\n\u003cstrong\u003e输出：\u003c/strong\u003e4\n\u003cstrong\u003e解释：\u003c/strong\u003e有 4 个子串：\"10\"、\"01\"、\"10\"、\"01\" ，具有相同数量的连续 1 和 0 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es[i]\u003c/code\u003e 为 \u003ccode\u003e'0'\u003c/code\u003e 或 \u003ccode\u003e'1'\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "计数二进制子串"
  },
  "count-elements-with-strictly-smaller-and-greater-elements": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e, return \u003cem\u003ethe number of elements that have \u003cstrong\u003eboth\u003c/strong\u003e a strictly smaller and a strictly greater element appear in \u003c/em\u003e\u003ccode\u003enums\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [11,7,2,15]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\nElement 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\nIn total there are 2 elements having both a strictly smaller and a strictly greater element appear in \u003ccode\u003enums\u003c/code\u003e.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [-3,3,3,90]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.\nSince there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in \u003ccode\u003enums\u003c/code\u003e.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "All the elements in the array should be counted except for the minimum and maximum elements.",
    "If the array has n elements, the answer will be n - count(min(nums)) - count(max(nums))",
    "This formula will not work in case the array has all the elements equal, why?"
   ],
   "questionId": "2269",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数数组 \u003ccode\u003enums\u003c/code\u003e ，统计并返回在 \u003ccode\u003enums\u003c/code\u003e 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [11,7,2,15]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。\n元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。\n总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [-3,3,3,90]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。\n由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "元素计数"
  },
  "count-primes": {
   "content": "\u003cp\u003eGiven an integer \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003ethe number of prime numbers that are strictly less than\u003c/em\u003e \u003ccode\u003en\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 10\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= n \u0026lt;= 5 * 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "\u003cp\u003eLet's start with a \u003ci\u003eisPrime\u003c/i\u003e function. To determine if a number is prime, we need to check if it is not divisible by any number less than \u003ci\u003en\u003c/i\u003e. The runtime complexity of \u003ci\u003eisPrime\u003c/i\u003e function would be O(\u003ci\u003en\u003c/i\u003e) and hence counting the total prime numbers up to \u003ci\u003en\u003c/i\u003e would be O(\u003ci\u003en\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e). Could we do better?\u003c/p\u003e",
    "\u003cp\u003eAs we know the number must not be divisible by any number \u003e \u003ci\u003en\u003c/i\u003e / 2, we can immediately cut the total iterations half by dividing only up to \u003ci\u003en\u003c/i\u003e / 2. Could we still do better?\u003c/p\u003e",
    "\u003cp\u003eLet's write down all of 12's factors:\u003c/p\u003e\r\n\u003cpre\u003e\r\n2 × 6 = 12\r\n3 × 4 = 12\r\n4 × 3 = 12\r\n6 × 2 = 12\r\n\u003c/pre\u003e\r\n\r\n\u003cp\u003eAs you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to \u0026radic;\u003ci\u003en\u003c/i\u003e because, if \u003ci\u003en\u003c/i\u003e is divisible by some number \u003ci\u003ep\u003c/i\u003e, then \u003ci\u003en\u003c/i\u003e = \u003ci\u003ep\u003c/i\u003e × \u003ci\u003eq\u003c/i\u003e and since \u003ci\u003ep\u003c/i\u003e \u0026le; \u003ci\u003eq\u003c/i\u003e, we could derive that \u003ci\u003ep\u003c/i\u003e \u0026le; \u0026radic;\u003ci\u003en\u003c/i\u003e.\u003c/p\u003e\r\n\r\n\u003cp\u003eOur total runtime has now improved to O(\u003ci\u003en\u003c/i\u003e\u003csup\u003e1.5\u003c/sup\u003e), which is slightly better. Is there a faster approach?\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\npublic int countPrimes(int n) {\r\n   int count = 0;\r\n   for (int i = 1; i \u003c n; i++) {\r\n      if (isPrime(i)) count++;\r\n   }\r\n   return count;\r\n}\r\n\r\nprivate boolean isPrime(int num) {\r\n   if (num \u003c= 1) return false;\r\n   // Loop's ending condition is i * i \u003c= num instead of i \u003c= sqrt(num)\r\n   // to avoid repeatedly calling an expensive function sqrt().\r\n   for (int i = 2; i * i \u003c= num; i++) {\r\n      if (num % i == 0) return false;\r\n   }\r\n   return true;\r\n}\r\n\u003c/pre\u003e",
    "\u003cp\u003eThe \u003ca href=\"http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\" target=\"_blank\"\u003eSieve of Eratosthenes\u003c/a\u003e is one of the most efficient ways to find all prime numbers up to \u003ci\u003en\u003c/i\u003e. But don't let that name scare you, I promise that the concept is surprisingly simple.\u003c/p\u003e\r\n\r\n\u003cp\u003e\r\n\u003cimg src=\"/static/images/solutions/Sieve_of_Eratosthenes_animation.gif\" /\u003e\u003cbr /\u003e\r\n\u003csmall\u003eSieve of Eratosthenes: algorithm steps for primes below 121. \"\u003ca href=\"http://commons.wikimedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif\" target=\"_blank\"\u003eSieve of Eratosthenes Animation\u003c/a\u003e\" by \u003ca href=\"http://de.wikipedia.org/wiki/Benutzer:SKopp\" target=\"_blank\"\u003eSKopp\u003c/a\u003e is licensed under \u003ca href=\"http://creativecommons.org/licenses/by/2.0/\" target=\"_blank\"\u003eCC BY 2.0\u003c/a\u003e.\u003c/small\u003e\r\n\u003c/p\u003e\r\n\r\n\u003cp\u003eWe start off with a table of \u003ci\u003en\u003c/i\u003e numbers. Let's look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, ... must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well?\u003c/p\u003e",
    "\u003cp\u003e4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, ... can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off?\u003c/p\u003e",
    "\u003cp\u003eIn fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is \u003ci\u003ep\u003c/i\u003e, we can always mark off multiples of \u003ci\u003ep\u003c/i\u003e starting at \u003ci\u003ep\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e, then in increments of \u003ci\u003ep\u003c/i\u003e: \u003ci\u003ep\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e + \u003ci\u003ep\u003c/i\u003e, \u003ci\u003ep\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e + 2\u003ci\u003ep\u003c/i\u003e, ... Now what should be the terminating loop condition?\u003c/p\u003e",
    "\u003cp\u003eIt is easy to say that the terminating loop condition is \u003ci\u003ep\u003c/i\u003e \u003c \u003ci\u003en\u003c/i\u003e, which is certainly correct but not efficient. Do you still remember \u003ci\u003eHint #3\u003c/i\u003e?\u003c/p\u003e",
    "\u003cp\u003eYes, the terminating loop condition can be \u003ci\u003ep\u003c/i\u003e \u003c \u0026radic;\u003ci\u003en\u003c/i\u003e, as all non-primes \u0026ge; \u0026radic;\u003ci\u003en\u003c/i\u003e must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime.\u003c/p\u003e\r\n\r\n\u003cp\u003eThe Sieve of Eratosthenes uses an extra O(\u003ci\u003en\u003c/i\u003e) memory and its runtime complexity is O(\u003ci\u003en\u003c/i\u003e log log \u003ci\u003en\u003c/i\u003e). For the more mathematically inclined readers, you can read more about its algorithm complexity on \u003ca href=\"http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity\" target=\"_blank\"\u003eWikipedia\u003c/a\u003e.\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\npublic int countPrimes(int n) {\r\n   boolean[] isPrime = new boolean[n];\r\n   for (int i = 2; i \u003c n; i++) {\r\n      isPrime[i] = true;\r\n   }\r\n   // Loop's ending condition is i * i \u003c n instead of i \u003c sqrt(n)\r\n   // to avoid repeatedly calling an expensive function sqrt().\r\n   for (int i = 2; i * i \u003c n; i++) {\r\n      if (!isPrime[i]) continue;\r\n      for (int j = i * i; j \u003c n; j += i) {\r\n         isPrime[j] = false;\r\n      }\r\n   }\r\n   int count = 0;\r\n   for (int i = 2; i \u003c n; i++) {\r\n      if (isPrime[i]) count++;\r\n   }\r\n   return count;\r\n}\r\n\u003c/pre\u003e"
   ],
   "questionId": "204",
   "similarQuestions": "[{\"title\": \"Ugly Number\", \"titleSlug\": \"ugly-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e11\\u6570\"}, {\"title\": \"Ugly Number II\", \"titleSlug\": \"ugly-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e11\\u6570 II\"}, {\"title\": \"Perfect Squares\", \"titleSlug\": \"perfect-squares\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b8c\\u5168\\u5e73\\u65b9\\u6570\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Enumeration",
     "slug": "enumeration",
     "translatedName": "枚举"
    },
    {
     "name": "Number Theory",
     "slug": "number-theory",
     "translatedName": "数论"
    }
   ],
   "translatedContent": "\u003cp\u003e给定整数 \u003ccode\u003en\u003c/code\u003e ，返回 \u003cem\u003e所有小于非负整数\u0026nbsp;\u003ccode\u003en\u003c/code\u003e\u0026nbsp;的质数的数量\u003c/em\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 10\n\u003cstrong\u003e输出：\u003c/strong\u003e4\n\u003cstrong\u003e解释：\u003c/strong\u003e小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 0\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 1\n\u003cstrong\u003e输出\u003c/strong\u003e：0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= n \u0026lt;= 5 * 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "计数质数"
  },
  "counting-bits": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "daily-temperatures": {
   "content": "\u003cp\u003eGiven an array of integers \u003ccode\u003etemperatures\u003c/code\u003e represents the daily temperatures, return \u003cem\u003ean array\u003c/em\u003e \u003ccode\u003eanswer\u003c/code\u003e \u003cem\u003esuch that\u003c/em\u003e \u003ccode\u003eanswer[i]\u003c/code\u003e \u003cem\u003eis the number of days you have to wait after the\u003c/em\u003e \u003ccode\u003ei\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e \u003cem\u003eday to get a warmer temperature\u003c/em\u003e. If there is no future day for which this is possible, keep \u003ccode\u003eanswer[i] == 0\u003c/code\u003e instead.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e temperatures = [73,74,75,71,69,72,76,73]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,1,4,2,1,1,0,0]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e temperatures = [30,40,50,60]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,1,1,0]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e temperatures = [30,60,90]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,1,0]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;=\u0026nbsp;temperatures.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e30 \u0026lt;=\u0026nbsp;temperatures[i] \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "If the temperature is say, 70 today, then in the future a warmer temperature must be either 71, 72, 73, ..., 99, or 100.  We could remember when all of them occur next."
   ],
   "questionId": "739",
   "similarQuestions": "[{\"title\": \"Next Greater Element I\", \"titleSlug\": \"next-greater-element-i\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e0b\\u4e00\\u4e2a\\u66f4\\u5927\\u5143\\u7d20 I\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Monotonic Stack",
     "slug": "monotonic-stack",
     "translatedName": "单调栈"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个整数数组\u0026nbsp;\u003ccode\u003etemperatures\u003c/code\u003e\u0026nbsp;，表示每天的温度，返回一个数组\u0026nbsp;\u003ccode\u003eanswer\u003c/code\u003e\u0026nbsp;，其中\u0026nbsp;\u003ccode\u003eanswer[i]\u003c/code\u003e\u0026nbsp;是指在第 \u003ccode\u003ei\u003c/code\u003e 天之后，\u003cspan style=\"font-size:10.5pt\"\u003e\u003cspan style=\"font-family:Calibri\"\u003e\u003cspan style=\"font-size:10.5000pt\"\u003e\u003cspan style=\"font-family:宋体\"\u003e\u003cfont face=\"宋体\"\u003e才会有更高的温度\u003c/font\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e。如果气温在这之后都不会升高，请在该位置用\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e 来代替。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003etemperatures\u003c/code\u003e = [73,74,75,71,69,72,76,73]\n\u003cstrong\u003e输出:\u003c/strong\u003e\u0026nbsp;[1,1,4,2,1,1,0,0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e temperatures = [30,40,50,60]\n\u003cstrong\u003e输出:\u003c/strong\u003e\u0026nbsp;[1,1,1,0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e temperatures = [30,60,90]\n\u003cstrong\u003e输出: \u003c/strong\u003e[1,1,0]\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;=\u0026nbsp;temperatures.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e30 \u0026lt;=\u0026nbsp;temperatures[i]\u0026nbsp;\u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "每日温度"
  },
  "decode-string": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "decompress-run-length-encoded-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "delete-node-in-a-linked-list": {
   "content": "\u003cp\u003eWrite a function to \u003cstrong\u003edelete a node\u003c/strong\u003e in a singly-linked list. You will \u003cstrong\u003enot\u003c/strong\u003e be given access to the \u003ccode\u003ehead\u003c/code\u003e of the list, instead you will be given access to \u003cstrong\u003ethe node to be deleted\u003c/strong\u003e directly.\u003c/p\u003e\n\n\u003cp\u003eIt is \u003cstrong\u003eguaranteed\u003c/strong\u003e that the node to be deleted is \u003cstrong\u003enot a tail node\u003c/strong\u003e in the list.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" style=\"width: 300px; height: 215px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [4,5,1,9], node = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e [4,1,9]\n\u003cstrong\u003eExplanation: \u003c/strong\u003eYou are given the second node with value 5, the linked list should become 4 -\u0026gt; 1 -\u0026gt; 9 after calling your function.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" style=\"width: 300px; height: 236px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [4,5,1,9], node = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e [4,5,9]\n\u003cstrong\u003eExplanation: \u003c/strong\u003eYou are given the third node with value 1, the linked list should become 4 -\u0026gt; 5 -\u0026gt; 9 after calling your function.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of the nodes in the given list is in the range \u003ccode\u003e[2, 1000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe value of each node in the list is \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe \u003ccode\u003enode\u003c/code\u003e to be deleted is \u003cstrong\u003ein the list\u003c/strong\u003e and is \u003cstrong\u003enot a tail\u003c/strong\u003e node\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "237",
   "similarQuestions": "[{\"title\": \"Remove Linked List Elements\", \"titleSlug\": \"remove-linked-list-elements\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u79fb\\u9664\\u94fe\\u8868\\u5143\\u7d20\"}]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    }
   ],
   "translatedContent": "\u003cp\u003e请编写一个函数，用于 \u003cstrong\u003e删除单链表中某个特定节点\u003c/strong\u003e 。在设计函数时需要注意，你无法访问链表的头节点\u0026nbsp;\u003ccode\u003ehead\u003c/code\u003e ，只能直接访问 \u003cstrong\u003e要被删除的节点\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e题目数据保证需要删除的节点 \u003cstrong\u003e不是末尾节点\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" style=\"height: 215px; width: 300px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [4,5,1,9], node = 5\n\u003cstrong\u003e输出：\u003c/strong\u003e[4,1,9]\n\u003cstrong\u003e解释：\u003c/strong\u003e指定链表中值为\u0026nbsp;5\u0026nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 1 -\u0026gt; 9\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" style=\"height: 236px; width: 300px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [4,5,1,9], node = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[4,5,9]\n\u003cstrong\u003e解释：\u003c/strong\u003e指定链表中值为\u0026nbsp;1\u0026nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 5 -\u0026gt; 9\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点的数目范围是 \u003ccode\u003e[2, 1000]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e链表中每个节点的值都是 \u003cstrong\u003e唯一\u003c/strong\u003e 的\u003c/li\u003e\n\t\u003cli\u003e需要删除的节点 \u003ccode\u003enode\u003c/code\u003e 是 \u003cstrong\u003e链表中的节点\u003c/strong\u003e ，且 \u003cstrong\u003e不是末尾节点\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "删除链表中的节点"
  },
  "delete-operation-for-two-strings": {
   "content": "\u003cp\u003eGiven two strings \u003ccode\u003eword1\u003c/code\u003e and \u003ccode\u003eword2\u003c/code\u003e, return \u003cem\u003ethe minimum number of \u003cstrong\u003esteps\u003c/strong\u003e required to make\u003c/em\u003e \u003ccode\u003eword1\u003c/code\u003e \u003cem\u003eand\u003c/em\u003e \u003ccode\u003eword2\u003c/code\u003e \u003cem\u003ethe same\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn one \u003cstrong\u003estep\u003c/strong\u003e, you can delete exactly one character in either string.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e word1 = \u0026quot;sea\u0026quot;, word2 = \u0026quot;eat\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e You need one step to make \u0026quot;sea\u0026quot; to \u0026quot;ea\u0026quot; and another step to make \u0026quot;eat\u0026quot; to \u0026quot;ea\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e word1 = \u0026quot;leetcode\u0026quot;, word2 = \u0026quot;etco\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= word1.length, word2.length \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword1\u003c/code\u003e and \u003ccode\u003eword2\u003c/code\u003e consist of only lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "583",
   "similarQuestions": "[{\"title\": \"Edit Distance\", \"titleSlug\": \"edit-distance\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u7f16\\u8f91\\u8ddd\\u79bb\"}, {\"title\": \"Minimum ASCII Delete Sum for Two Strings\", \"titleSlug\": \"minimum-ascii-delete-sum-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e24\\u4e2a\\u5b57\\u7b26\\u4e32\\u7684\\u6700\\u5c0fASCII\\u5220\\u9664\\u548c\"}]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个单词\u0026nbsp;\u003ccode\u003eword1\u003c/code\u003e\u0026nbsp;和\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003eword2\u003c/code\u003e\u0026nbsp;，返回使得\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003eword1\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003eword2\u003c/code\u003e\u003cem\u003e\u0026nbsp;\u003c/em\u003e\u003cstrong\u003e相同\u003c/strong\u003e所需的\u003cstrong\u003e最小步数\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e每步\u0026nbsp;\u003c/strong\u003e可以删除任意一个字符串中的一个字符。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e word1 = \"sea\", word2 = \"eat\"\n\u003cstrong\u003e输出:\u003c/strong\u003e 2\n\u003cstrong\u003e解释:\u003c/strong\u003e 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 \u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003eword1 = \"leetcode\", word2 = \"etco\"\n\u003cb\u003e输出：\u003c/b\u003e4\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\u003cmeta charset=\"UTF-8\" /\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= word1.length, word2.length \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword1\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003eword2\u003c/code\u003e\u0026nbsp;只包含小写英文字母\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "两个字符串的删除操作"
  },
  "delete-the-middle-node-of-a-linked-list": {
   "content": "\u003cp\u003eYou are given the \u003ccode\u003ehead\u003c/code\u003e of a linked list. \u003cstrong\u003eDelete\u003c/strong\u003e the \u003cstrong\u003emiddle node\u003c/strong\u003e, and return \u003cem\u003ethe\u003c/em\u003e \u003ccode\u003ehead\u003c/code\u003e \u003cem\u003eof the modified linked list\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003emiddle node\u003c/strong\u003e of a linked list of size \u003ccode\u003en\u003c/code\u003e is the \u003ccode\u003e\u0026lfloor;n / 2\u0026rfloor;\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e node from the \u003cb\u003estart\u003c/b\u003e using \u003cstrong\u003e0-based indexing\u003c/strong\u003e, where \u003ccode\u003e\u0026lfloor;x\u0026rfloor;\u003c/code\u003e denotes the largest integer less than or equal to \u003ccode\u003ex\u003c/code\u003e.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor \u003ccode\u003en\u003c/code\u003e = \u003ccode\u003e1\u003c/code\u003e, \u003ccode\u003e2\u003c/code\u003e, \u003ccode\u003e3\u003c/code\u003e, \u003ccode\u003e4\u003c/code\u003e, and \u003ccode\u003e5\u003c/code\u003e, the middle nodes are \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003e1\u003c/code\u003e, \u003ccode\u003e1\u003c/code\u003e, \u003ccode\u003e2\u003c/code\u003e, and \u003ccode\u003e2\u003c/code\u003e, respectively.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png\" style=\"width: 500px; height: 77px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,3,4,7,1,2,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,3,4,1,2,6]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nThe above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node. \n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png\" style=\"width: 250px; height: 43px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,4]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nThe above figure represents the given linked list.\nFor n = 4, node 2 with value 3 is the middle node, which is marked in red.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png\" style=\"width: 150px; height: 58px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [2,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nThe above figure represents the given linked list.\nFor n = 2, node 1 with value 1 is the middle node, which is marked in red.\nNode 0 with value 2 is the only node remaining after removing node 1.\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is in the range \u003ccode\u003e[1, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "If a point with a speed s moves n units in a given time, a point with speed 2 * s will move 2 * n units at the same time. Can you use this to find the middle node of a linked list?",
    "If you are given the middle node, the node before it, and the node after it, how can you modify the linked list?"
   ],
   "questionId": "2216",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个链表的头节点 \u003ccode\u003ehead\u003c/code\u003e 。\u003cstrong\u003e删除\u003c/strong\u003e 链表的 \u003cstrong\u003e中间节点\u003c/strong\u003e ，并返回修改后的链表的头节点 \u003ccode\u003ehead\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e长度为 \u003ccode\u003en\u003c/code\u003e 链表的中间节点是从头数起第 \u003ccode\u003e⌊n / 2⌋\u003c/code\u003e 个节点（下标从 \u003cstrong\u003e0\u003c/strong\u003e 开始），其中 \u003ccode\u003e⌊x⌋\u003c/code\u003e 表示小于或等于 \u003ccode\u003ex\u003c/code\u003e 的最大整数。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e对于 \u003ccode\u003en\u003c/code\u003e = \u003ccode\u003e1\u003c/code\u003e、\u003ccode\u003e2\u003c/code\u003e、\u003ccode\u003e3\u003c/code\u003e、\u003ccode\u003e4\u003c/code\u003e 和 \u003ccode\u003e5\u003c/code\u003e 的情况，中间节点的下标分别是 \u003ccode\u003e0\u003c/code\u003e、\u003ccode\u003e1\u003c/code\u003e、\u003ccode\u003e1\u003c/code\u003e、\u003ccode\u003e2\u003c/code\u003e 和 \u003ccode\u003e2\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png\" style=\"width: 500px; height: 77px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,3,4,7,1,2,6]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,3,4,1,2,6]\n\u003cstrong\u003e解释：\u003c/strong\u003e\n上图表示给出的链表。节点的下标分别标注在每个节点的下方。\n由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。\n返回结果为移除节点后的新链表。 \n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png\" style=\"width: 250px; height: 43px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2,4]\n\u003cstrong\u003e解释：\u003c/strong\u003e\n上图表示给出的链表。\n对于 n = 4 ，值为 3 的节点 2 是中间节点，用红色标注。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png\" style=\"width: 150px; height: 58px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [2,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[2]\n\u003cstrong\u003e解释：\u003c/strong\u003e\n上图表示给出的链表。\n对于 n = 2 ，值为 1 的节点 1 是中间节点，用红色标注。\n值为 2 的节点 0 是移除节点 1 后剩下的唯一一个节点。\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点的数目在范围 \u003ccode\u003e[1, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "删除链表的中间节点"
  },
  "design-add-and-search-words-data-structure": {
   "content": "\u003cp\u003eDesign a data structure that supports adding new words and finding if a string matches any previously added string.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eWordDictionary\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eWordDictionary()\u003c/code\u003e\u0026nbsp;Initializes the object.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid addWord(word)\u003c/code\u003e Adds \u003ccode\u003eword\u003c/code\u003e to the data structure, it can be matched later.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebool search(word)\u003c/code\u003e\u0026nbsp;Returns \u003ccode\u003etrue\u003c/code\u003e if there is any string in the data structure that matches \u003ccode\u003eword\u003c/code\u003e\u0026nbsp;or \u003ccode\u003efalse\u003c/code\u003e otherwise. \u003ccode\u003eword\u003c/code\u003e may contain dots \u003ccode\u003e\u0026#39;.\u0026#39;\u003c/code\u003e where dots can be matched with any letter.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;WordDictionary\u0026quot;,\u0026quot;addWord\u0026quot;,\u0026quot;addWord\u0026quot;,\u0026quot;addWord\u0026quot;,\u0026quot;search\u0026quot;,\u0026quot;search\u0026quot;,\u0026quot;search\u0026quot;,\u0026quot;search\u0026quot;]\n[[],[\u0026quot;bad\u0026quot;],[\u0026quot;dad\u0026quot;],[\u0026quot;mad\u0026quot;],[\u0026quot;pad\u0026quot;],[\u0026quot;bad\u0026quot;],[\u0026quot;.ad\u0026quot;],[\u0026quot;b..\u0026quot;]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null,null,null,null,false,true,true,true]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\u0026quot;bad\u0026quot;);\nwordDictionary.addWord(\u0026quot;dad\u0026quot;);\nwordDictionary.addWord(\u0026quot;mad\u0026quot;);\nwordDictionary.search(\u0026quot;pad\u0026quot;); // return False\nwordDictionary.search(\u0026quot;bad\u0026quot;); // return True\nwordDictionary.search(\u0026quot;.ad\u0026quot;); // return True\nwordDictionary.search(\u0026quot;b..\u0026quot;); // return True\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= word.length \u0026lt;= 25\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword\u003c/code\u003e in \u003ccode\u003eaddWord\u003c/code\u003e consists of lowercase English letters.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword\u003c/code\u003e in \u003ccode\u003esearch\u003c/code\u003e consist of \u003ccode\u003e\u0026#39;.\u0026#39;\u003c/code\u003e or lowercase English letters.\u003c/li\u003e\n\t\u003cli\u003eThere will be at most \u003ccode\u003e3\u003c/code\u003e dots in \u003ccode\u003eword\u003c/code\u003e for \u003ccode\u003esearch\u003c/code\u003e queries.\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls will be made to \u003ccode\u003eaddWord\u003c/code\u003e and \u003ccode\u003esearch\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "You should be familiar with how a Trie works. If not, please work on this problem: \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\"\u003eImplement Trie (Prefix Tree)\u003c/a\u003e first."
   ],
   "questionId": "211",
   "similarQuestions": "[{\"title\": \"Implement Trie (Prefix Tree)\", \"titleSlug\": \"implement-trie-prefix-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b9e\\u73b0 Trie (\\u524d\\u7f00\\u6811)\"}, {\"title\": \"Prefix and Suffix Search\", \"titleSlug\": \"prefix-and-suffix-search\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u524d\\u7f00\\u548c\\u540e\\u7f00\\u641c\\u7d22\"}]",
   "topicTags": [
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Trie",
     "slug": "trie",
     "translatedName": "字典树"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\u003c/p\u003e\n\n\u003cp\u003e实现词典类 \u003ccode\u003eWordDictionary\u003c/code\u003e ：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eWordDictionary()\u003c/code\u003e 初始化词典对象\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid addWord(word)\u003c/code\u003e 将 \u003ccode\u003eword\u003c/code\u003e 添加到数据结构中，之后可以对它进行匹配\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebool search(word)\u003c/code\u003e 如果数据结构中存在字符串与\u0026nbsp;\u003ccode\u003eword\u003c/code\u003e 匹配，则返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回\u0026nbsp; \u003ccode\u003efalse\u003c/code\u003e 。\u003ccode\u003eword\u003c/code\u003e 中可能包含一些 \u003ccode\u003e'.'\u003c/code\u003e ，每个\u0026nbsp;\u003ccode\u003e.\u003c/code\u003e 都可以表示任何一个字母。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n\u003cstrong\u003e输出：\u003c/strong\u003e\n[null,null,null,null,false,true,true,true]\n\n\u003cstrong\u003e解释：\u003c/strong\u003e\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // 返回 False\nwordDictionary.search(\"bad\"); // 返回 True\nwordDictionary.search(\".ad\"); // 返回 True\nwordDictionary.search(\"b..\"); // 返回 True\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= word.length \u0026lt;= 25\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eaddWord\u003c/code\u003e 中的 \u003ccode\u003eword\u003c/code\u003e 由小写英文字母组成\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003esearch\u003c/code\u003e 中的 \u003ccode\u003eword\u003c/code\u003e 由 '.' 或小写英文字母组成\u003c/li\u003e\n\t\u003cli\u003e最多调用 \u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e 次 \u003ccode\u003eaddWord\u003c/code\u003e 和 \u003ccode\u003esearch\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "添加与搜索单词 - 数据结构设计"
  },
  "design-bounded-blocking-queue": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "design-circular-queue": {
   "content": "\u003cp\u003eDesign your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called \u0026quot;Ring Buffer\u0026quot;.\u003c/p\u003e\n\n\u003cp\u003eOne of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.\u003c/p\u003e\n\n\u003cp\u003eImplementation the \u003ccode\u003eMyCircularQueue\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eMyCircularQueue(k)\u003c/code\u003e Initializes the object with the size of the queue to be \u003ccode\u003ek\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint Front()\u003c/code\u003e Gets the front item from the queue. If the queue is empty, return \u003ccode\u003e-1\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint Rear()\u003c/code\u003e Gets the last item from the queue. If the queue is empty, return \u003ccode\u003e-1\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean enQueue(int value)\u003c/code\u003e Inserts an element into the circular queue. Return \u003ccode\u003etrue\u003c/code\u003e if the operation is successful.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean deQueue()\u003c/code\u003e Deletes an element from the circular queue. Return \u003ccode\u003etrue\u003c/code\u003e if the operation is successful.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean isEmpty()\u003c/code\u003e Checks whether the circular queue is empty or not.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean isFull()\u003c/code\u003e Checks whether the circular queue is full or not.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eYou must solve the problem without using the built-in queue data structure in your programming language.\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;MyCircularQueue\u0026quot;, \u0026quot;enQueue\u0026quot;, \u0026quot;enQueue\u0026quot;, \u0026quot;enQueue\u0026quot;, \u0026quot;enQueue\u0026quot;, \u0026quot;Rear\u0026quot;, \u0026quot;isFull\u0026quot;, \u0026quot;deQueue\u0026quot;, \u0026quot;enQueue\u0026quot;, \u0026quot;Rear\u0026quot;]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, true, true, true, false, 3, true, true, true, 4]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nMyCircularQueue myCircularQueue = new MyCircularQueue(3);\nmyCircularQueue.enQueue(1); // return True\nmyCircularQueue.enQueue(2); // return True\nmyCircularQueue.enQueue(3); // return True\nmyCircularQueue.enQueue(4); // return False\nmyCircularQueue.Rear();     // return 3\nmyCircularQueue.isFull();   // return True\nmyCircularQueue.deQueue();  // return True\nmyCircularQueue.enQueue(4); // return True\nmyCircularQueue.Rear();     // return 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= value \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e3000\u003c/code\u003e calls will be made to\u0026nbsp;\u003ccode\u003eenQueue\u003c/code\u003e, \u003ccode\u003edeQueue\u003c/code\u003e,\u0026nbsp;\u003ccode\u003eFront\u003c/code\u003e,\u0026nbsp;\u003ccode\u003eRear\u003c/code\u003e,\u0026nbsp;\u003ccode\u003eisEmpty\u003c/code\u003e, and\u0026nbsp;\u003ccode\u003eisFull\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "860",
   "similarQuestions": "[{\"title\": \"Design Circular Deque\", \"titleSlug\": \"design-circular-deque\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u8bbe\\u8ba1\\u5faa\\u73af\\u53cc\\u7aef\\u961f\\u5217\"}]",
   "topicTags": [
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Queue",
     "slug": "queue",
     "translatedName": "队列"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    }
   ],
   "translatedContent": "\u003cp\u003e设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为\u0026ldquo;环形缓冲器\u0026rdquo;。\u003c/p\u003e\n\n\u003cp\u003e循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。\u003c/p\u003e\n\n\u003cp\u003e你的实现应该支持如下操作：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eMyCircularQueue(k)\u003c/code\u003e: 构造器，设置队列长度为 k 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eFront\u003c/code\u003e: 从队首获取元素。如果队列为空，返回 -1 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eRear\u003c/code\u003e: 获取队尾元素。如果队列为空，返回 -1 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eenQueue(value)\u003c/code\u003e: 向循环队列插入一个元素。如果成功插入则返回真。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003edeQueue()\u003c/code\u003e: 从循环队列中删除一个元素。如果成功删除则返回真。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eisEmpty()\u003c/code\u003e: 检查循环队列是否为空。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eisFull()\u003c/code\u003e: 检查循环队列是否已满。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003eMyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3\ncircularQueue.enQueue(1); \u0026nbsp;// 返回 true\ncircularQueue.enQueue(2); \u0026nbsp;// 返回 true\ncircularQueue.enQueue(3); \u0026nbsp;// 返回 true\ncircularQueue.enQueue(4); \u0026nbsp;// 返回 false，队列已满\ncircularQueue.Rear(); \u0026nbsp;// 返回 3\ncircularQueue.isFull(); \u0026nbsp;// 返回 true\ncircularQueue.deQueue(); \u0026nbsp;// 返回 true\ncircularQueue.enQueue(4); \u0026nbsp;// 返回 true\ncircularQueue.Rear(); \u0026nbsp;// 返回 4\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e所有的值都在 0\u0026nbsp;至 1000 的范围内；\u003c/li\u003e\n\t\u003cli\u003e操作数将在 1 至 1000 的范围内；\u003c/li\u003e\n\t\u003cli\u003e请不要使用内置的队列库。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "设计循环队列"
  },
  "design-compressed-string-iterator": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "design-hashmap": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "design-hashset": {
   "content": "\u003cp\u003eDesign a HashSet without using any built-in hash table libraries.\u003c/p\u003e\n\n\u003cp\u003eImplement \u003ccode\u003eMyHashSet\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003evoid add(key)\u003c/code\u003e Inserts the value \u003ccode\u003ekey\u003c/code\u003e into the HashSet.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebool contains(key)\u003c/code\u003e Returns whether the value \u003ccode\u003ekey\u003c/code\u003e exists in the HashSet or not.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid remove(key)\u003c/code\u003e Removes the value \u003ccode\u003ekey\u003c/code\u003e in the HashSet. If \u003ccode\u003ekey\u003c/code\u003e does not exist in the HashSet, do nothing.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;MyHashSet\u0026quot;, \u0026quot;add\u0026quot;, \u0026quot;add\u0026quot;, \u0026quot;contains\u0026quot;, \u0026quot;contains\u0026quot;, \u0026quot;add\u0026quot;, \u0026quot;contains\u0026quot;, \u0026quot;remove\u0026quot;, \u0026quot;contains\u0026quot;]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, null, null, true, false, null, true, null, false]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // return False, (already removed)\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= key \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls will be made to \u003ccode\u003eadd\u003c/code\u003e, \u003ccode\u003eremove\u003c/code\u003e, and \u003ccode\u003econtains\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "816",
   "similarQuestions": "[{\"title\": \"Design HashMap\", \"titleSlug\": \"design-hashmap\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u8bbe\\u8ba1\\u54c8\\u5e0c\\u6620\\u5c04\"}]",
   "topicTags": [
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Hash Function",
     "slug": "hash-function",
     "translatedName": "哈希函数"
    }
   ],
   "translatedContent": "\u003cp\u003e不使用任何内建的哈希表库设计一个哈希集合（HashSet）。\u003c/p\u003e\n\n\u003cp\u003e实现 \u003ccode\u003eMyHashSet\u003c/code\u003e 类：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003evoid add(key)\u003c/code\u003e 向哈希集合中插入值 \u003ccode\u003ekey\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebool contains(key)\u003c/code\u003e 返回哈希集合中是否存在这个值 \u003ccode\u003ekey\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid remove(key)\u003c/code\u003e 将给定值 \u003ccode\u003ekey\u003c/code\u003e 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。\u003c/li\u003e\n\u003c/ul\u003e\n\u0026nbsp;\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n\u003cstrong\u003e输出：\u003c/strong\u003e\n[null, null, null, true, false, null, true, null, false]\n\n\u003cstrong\u003e解释：\u003c/strong\u003e\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // 返回 True\nmyHashSet.contains(3); // 返回 False ，（未找到）\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // 返回 True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // 返回 False ，（已移除）\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= key \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e最多调用 \u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e 次 \u003ccode\u003eadd\u003c/code\u003e、\u003ccode\u003eremove\u003c/code\u003e 和 \u003ccode\u003econtains\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "设计哈希集合"
  },
  "design-linked-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "design-skiplist": {
   "content": "\u003cp\u003eDesign a \u003cstrong\u003eSkiplist\u003c/strong\u003e without using any built-in libraries.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003eskiplist\u003c/strong\u003e is a data structure that takes \u003ccode\u003eO(log(n))\u003c/code\u003e time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.\u003c/p\u003e\n\n\u003cp\u003eFor example, we have a Skiplist containing \u003ccode\u003e[30,40,50,60,70,90]\u003c/code\u003e and we want to add \u003ccode\u003e80\u003c/code\u003e and \u003ccode\u003e45\u003c/code\u003e into it. The Skiplist works this way:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif\" style=\"width: 500px; height: 173px;\" /\u003e\u003cbr /\u003e\n\u003csmall\u003eArtyom Kalinin [CC BY-SA 3.0], via \u003ca href=\"https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif\" target=\"_blank\" title=\"Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons\"\u003eWikimedia Commons\u003c/a\u003e\u003c/small\u003e\u003c/p\u003e\n\n\u003cp\u003eYou can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than \u003ccode\u003eO(n)\u003c/code\u003e. It can be proven that the average time complexity for each operation is \u003ccode\u003eO(log(n))\u003c/code\u003e and space complexity is \u003ccode\u003eO(n)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSee more about Skiplist: \u003ca href=\"https://en.wikipedia.org/wiki/Skip_list\" target=\"_blank\"\u003ehttps://en.wikipedia.org/wiki/Skip_list\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eSkiplist\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eSkiplist()\u003c/code\u003e Initializes the object of the skiplist.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebool search(int target)\u003c/code\u003e Returns \u003ccode\u003etrue\u003c/code\u003e if the integer \u003ccode\u003etarget\u003c/code\u003e exists in the Skiplist or \u003ccode\u003efalse\u003c/code\u003e otherwise.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid add(int num)\u003c/code\u003e Inserts the value \u003ccode\u003enum\u003c/code\u003e into the SkipList.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebool erase(int num)\u003c/code\u003e Removes the value \u003ccode\u003enum\u003c/code\u003e from the Skiplist and returns \u003ccode\u003etrue\u003c/code\u003e. If \u003ccode\u003enum\u003c/code\u003e does not exist in the Skiplist, do nothing and return \u003ccode\u003efalse\u003c/code\u003e. If there exist multiple \u003ccode\u003enum\u003c/code\u003e values, removing any one of them is fine.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eNote that duplicates may exist in the Skiplist, your code needs to handle this situation.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;Skiplist\u0026quot;, \u0026quot;add\u0026quot;, \u0026quot;add\u0026quot;, \u0026quot;add\u0026quot;, \u0026quot;search\u0026quot;, \u0026quot;add\u0026quot;, \u0026quot;search\u0026quot;, \u0026quot;erase\u0026quot;, \u0026quot;erase\u0026quot;, \u0026quot;search\u0026quot;]\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, null, null, null, false, null, true, false, true, false]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0); // return False\nskiplist.add(4);\nskiplist.search(1); // return True\nskiplist.erase(0);  // return False, 0 is not in skiplist.\nskiplist.erase(1);  // return True\nskiplist.search(1); // return False, 1 has already been erased.\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= num, target \u0026lt;= 2 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls will be made to \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003eadd\u003c/code\u003e, and \u003ccode\u003eerase\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "1337",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    }
   ],
   "translatedContent": "\u003cp\u003e不使用任何库函数，设计一个 \u003cstrong\u003e跳表\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e跳表\u003c/strong\u003e 是在 \u003ccode\u003eO(log(n))\u003c/code\u003e 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。\u003c/p\u003e\n\n\u003cp\u003e例如，一个跳表包含 \u003ccode\u003e[30, 40, 50, 60, 70, 90]\u003c/code\u003e ，然后增加 \u003ccode\u003e80\u003c/code\u003e、\u003ccode\u003e45\u003c/code\u003e 到跳表中，以下图的方式操作：\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif\" /\u003e\u003cbr /\u003e\n\u003csmall\u003eArtyom Kalinin [CC BY-SA 3.0], via \u003ca href=\"https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif\" target=\"_blank\" title=\"Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons\"\u003eWikimedia Commons\u003c/a\u003e\u003c/small\u003e\u003c/p\u003e\n\n\u003cp\u003e跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 \u003ccode\u003eO(n)\u003c/code\u003e。跳表的每一个操作的平均时间复杂度是 \u003ccode\u003eO(log(n))\u003c/code\u003e，空间复杂度是 \u003ccode\u003eO(n)\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e了解更多 :\u0026nbsp;\u003ca href=\"https://en.wikipedia.org/wiki/Skip_list\" target=\"_blank\"\u003ehttps://en.wikipedia.org/wiki/Skip_list\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e在本题中，你的设计应该要包含这些函数：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003ebool search(int target)\u003c/code\u003e : 返回target是否存在于跳表中。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid add(int num)\u003c/code\u003e:\u0026nbsp;插入一个元素到跳表。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ebool erase(int num)\u003c/code\u003e: 在跳表中删除一个值，如果\u0026nbsp;\u003ccode\u003enum\u003c/code\u003e\u0026nbsp;不存在，直接返回false. 如果存在多个\u0026nbsp;\u003ccode\u003enum\u003c/code\u003e\u0026nbsp;，删除其中任意一个即可。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cb\u003e输入\u003c/b\u003e\n[\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"]\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\n\u003cstrong\u003e输出\u003c/strong\u003e\n[null, null, null, null, false, null, true, false, true, false]\n\n\u003cstrong\u003e解释\u003c/strong\u003e\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0);   // 返回 false\nskiplist.add(4);\nskiplist.search(1);   // 返回 true\nskiplist.erase(0);    // 返回 false，0 不在跳表中\nskiplist.erase(1);    // 返回 true\nskiplist.search(1);   // 返回 false，1 已被擦除\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= num, target \u0026lt;= 2 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e调用\u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003eadd\u003c/code\u003e, \u0026nbsp;\u003ccode\u003eerase\u003c/code\u003e操作次数不大于\u0026nbsp;\u003ccode\u003e5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u0026nbsp;\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "设计跳表"
  },
  "design-twitter": {
   "content": "\u003cp\u003eDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the \u003ccode\u003e10\u003c/code\u003e most recent tweets in the user\u0026#39;s news feed.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eTwitter\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eTwitter()\u003c/code\u003e Initializes your twitter object.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid postTweet(int userId, int tweetId)\u003c/code\u003e Composes a new tweet with ID \u003ccode\u003etweetId\u003c/code\u003e by the user \u003ccode\u003euserId\u003c/code\u003e. Each call to this function will be made with a unique \u003ccode\u003etweetId\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eList\u0026lt;Integer\u0026gt; getNewsFeed(int userId)\u003c/code\u003e Retrieves the \u003ccode\u003e10\u003c/code\u003e most recent tweet IDs in the user\u0026#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be \u003cstrong\u003eordered from most recent to least recent\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid follow(int followerId, int followeeId)\u003c/code\u003e The user with ID \u003ccode\u003efollowerId\u003c/code\u003e started following the user with ID \u003ccode\u003efolloweeId\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid unfollow(int followerId, int followeeId)\u003c/code\u003e The user with ID \u003ccode\u003efollowerId\u003c/code\u003e started unfollowing the user with ID \u003ccode\u003efolloweeId\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;Twitter\u0026quot;, \u0026quot;postTweet\u0026quot;, \u0026quot;getNewsFeed\u0026quot;, \u0026quot;follow\u0026quot;, \u0026quot;postTweet\u0026quot;, \u0026quot;getNewsFeed\u0026quot;, \u0026quot;unfollow\u0026quot;, \u0026quot;getNewsFeed\u0026quot;]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, null, [5], null, null, [6, 5], null, [5]]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1\u0026#39;s news feed should return a list with 1 tweet id -\u0026gt; [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1\u0026#39;s news feed should return a list with 2 tweet ids -\u0026gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1\u0026#39;s news feed should return a list with 1 tweet id -\u0026gt; [5], since user 1 is no longer following user 2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= userId, followerId, followeeId \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= tweetId \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the tweets have \u003cstrong\u003eunique\u003c/strong\u003e IDs.\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls will be made to \u003ccode\u003epostTweet\u003c/code\u003e, \u003ccode\u003egetNewsFeed\u003c/code\u003e, \u003ccode\u003efollow\u003c/code\u003e, and \u003ccode\u003eunfollow\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "355",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Heap (Priority Queue)",
     "slug": "heap-priority-queue",
     "translatedName": "堆（优先队列）"
    }
   ],
   "translatedContent": "\u003cp\u003e设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 \u003ccode\u003e10\u003c/code\u003e 条推文。\u003c/p\u003e\n\n\u003cp\u003e实现 \u003ccode\u003eTwitter\u003c/code\u003e 类：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eTwitter()\u003c/code\u003e 初始化简易版推特对象\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid postTweet(int userId, int tweetId)\u003c/code\u003e 根据给定的 \u003ccode\u003etweetId\u003c/code\u003e 和 \u003ccode\u003euserId\u003c/code\u003e 创建一条新推文。每次调用此函数都会使用一个不同的 \u003ccode\u003etweetId\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eList\u0026lt;Integer\u0026gt; getNewsFeed(int userId)\u003c/code\u003e 检索当前用户新闻推送中最近\u0026nbsp; \u003ccode\u003e10\u003c/code\u003e 条推文的 ID 。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须 \u003cstrong\u003e按照时间顺序由最近到最远排序\u003c/strong\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid follow(int followerId, int followeeId)\u003c/code\u003e ID 为 \u003ccode\u003efollowerId\u003c/code\u003e 的用户开始关注 ID 为 \u003ccode\u003efolloweeId\u003c/code\u003e 的用户。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid unfollow(int followerId, int followeeId)\u003c/code\u003e ID 为 \u003ccode\u003efollowerId\u003c/code\u003e 的用户不再关注 ID 为 \u003ccode\u003efolloweeId\u003c/code\u003e 的用户。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入\u003c/strong\u003e\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n\u003cstrong\u003e输出\u003c/strong\u003e\n[null, null, [5], null, null, [6, 5], null, [5]]\n\n\u003cstrong\u003e解释\u003c/strong\u003e\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5)\ntwitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文\ntwitter.follow(1, 2);    // 用户 1 关注了用户 2\ntwitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6)\ntwitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -\u0026gt; [6, 5] 。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的\ntwitter.unfollow(1, 2);  // 用户 1 取消关注了用户 2\ntwitter.getNewsFeed(1);  // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= userId, followerId, followeeId \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= tweetId \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e所有推特的 ID 都互不相同\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epostTweet\u003c/code\u003e、\u003ccode\u003egetNewsFeed\u003c/code\u003e、\u003ccode\u003efollow\u003c/code\u003e 和 \u003ccode\u003eunfollow\u003c/code\u003e 方法最多调用 \u003ccode\u003e3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e 次\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "设计推特"
  },
  "detect-capital": {
   "content": "\u003cp\u003eWe define the usage of capitals in a word to be right when one of the following cases holds:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eAll letters in this word are capitals, like \u003ccode\u003e\u0026quot;USA\u0026quot;\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eAll letters in this word are not capitals, like \u003ccode\u003e\u0026quot;leetcode\u0026quot;\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eOnly the first letter in this word is capital, like \u003ccode\u003e\u0026quot;Google\u0026quot;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eGiven a string \u003ccode\u003eword\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if the usage of capitals in it is right.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e word = \"USA\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e word = \"FlaG\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= word.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword\u003c/code\u003e consists of lowercase and uppercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "520",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e我们定义，在以下情况时，单词的大写用法是正确的：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e全部字母都是大写，比如 \u003ccode\u003e\"USA\"\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e单词中所有字母都不是大写，比如 \u003ccode\u003e\"leetcode\"\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e如果单词不只含有一个字母，只有首字母大写，\u0026nbsp;比如\u0026nbsp;\u003ccode\u003e\"Google\"\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e给你一个字符串 \u003ccode\u003eword\u003c/code\u003e 。如果大写用法正确，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eword = \"USA\"\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eword = \"FlaG\"\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= word.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword\u003c/code\u003e 由小写和大写英文字母组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "检测大写字母"
  },
  "diameter-of-binary-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "diameter-of-n-ary-tree": {
   "content": "\u003cp\u003eGiven a \u003ccode\u003eroot\u003c/code\u003e of an \u003ca href=\"https://leetcode.com/articles/introduction-to-n-ary-trees/\" target=\"_blank\"\u003eN-ary tree\u003c/a\u003e, you need to compute the length of the diameter of the tree.\u003c/p\u003e\n\n\u003cp\u003eThe diameter of an N-ary tree is the length of the \u003cstrong\u003elongest\u003c/strong\u003e path between any two nodes in the tree. This path may or may not pass through the root.\u003c/p\u003e\n\n\u003cp\u003e(\u003cem\u003eNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value.)\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/19/sample_2_1897.png\" style=\"width: 324px; height: 173px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,3,2,4,null,5,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation: \u003c/strong\u003eDiameter is shown in red color.\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/19/sample_1_1897.png\" style=\"width: 253px; height: 246px;\" /\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,2,null,3,4,null,5,null,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/19/sample_3_1897.png\" style=\"width: 369px; height: 326px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 7\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe depth of the n-ary tree is less than or equal to \u003ccode\u003e1000\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe total number of nodes is between \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "For the node i, calculate the height of each of its children and keep the first and second maximum heights (max1_i , max2_i).",
    "Check all nodes and return max( 2 + max1_i  +  max2_i )."
   ],
   "questionId": "1665",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一棵 N 叉树的根节点\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;，计算这棵树的直径长度。\u003c/p\u003e\n\n\u003cp\u003eN 叉树的直径指的是树中任意两个节点间路径中\u003cstrong\u003e 最长 \u003c/strong\u003e路径的长度。这条路径可能经过根节点，也可能不经过根节点。\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003e（N 叉树的输入序列以层序遍历的形式给出，每组子节点用 null 分隔）\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/19/sample_2_1897.png\" style=\"height:173px; width:324px\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,null,3,2,4,null,5,6]\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e直径如图中红线所示。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/19/sample_1_1897.png\" style=\"height:246px; width:253px\" /\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,null,2,null,3,4,null,5,null,6]\n\u003cstrong\u003e输出：\u003c/strong\u003e4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/19/sample_3_1897.png\" style=\"height:326px; width:369px\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\u003cstrong\u003e输出:\u003c/strong\u003e 7\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eN 叉树的深度小于或等于\u0026nbsp;\u003ccode\u003e1000\u003c/code\u003e\u0026nbsp;。\u003c/li\u003e\n\t\u003cli\u003e节点的总个数在\u0026nbsp;\u003ccode\u003e[0,\u0026nbsp;10^4]\u003c/code\u003e\u0026nbsp;间。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "N 叉树的直径"
  },
  "distribute-candies": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "divide-two-integers": {
   "content": "\u003cp\u003eGiven two integers \u003ccode\u003edividend\u003c/code\u003e and \u003ccode\u003edivisor\u003c/code\u003e, divide two integers \u003cstrong\u003ewithout\u003c/strong\u003e using multiplication, division, and mod operator.\u003c/p\u003e\n\n\u003cp\u003eThe integer division should truncate toward zero, which means losing its fractional part. For example, \u003ccode\u003e8.345\u003c/code\u003e would be truncated to \u003ccode\u003e8\u003c/code\u003e, and \u003ccode\u003e-2.7335\u003c/code\u003e would be truncated to \u003ccode\u003e-2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe \u003cstrong\u003equotient\u003c/strong\u003e after dividing \u003c/em\u003e\u003ccode\u003edividend\u003c/code\u003e\u003cem\u003e by \u003c/em\u003e\u003ccode\u003edivisor\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote: \u003c/strong\u003eAssume we are dealing with an environment that could only store integers within the \u003cstrong\u003e32-bit\u003c/strong\u003e signed integer range: \u003ccode\u003e[\u0026minus;2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e \u0026minus; 1]\u003c/code\u003e. For this problem, if the quotient is \u003cstrong\u003estrictly greater than\u003c/strong\u003e \u003ccode\u003e2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e, then return \u003ccode\u003e2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e, and if the quotient is \u003cstrong\u003estrictly less than\u003c/strong\u003e \u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e\u003c/code\u003e, then return \u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e dividend = 10, divisor = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e 10/3 = 3.33333.. which is truncated to 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e dividend = 7, divisor = -3\n\u003cstrong\u003eOutput:\u003c/strong\u003e -2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e 7/-3 = -2.33333.. which is truncated to -2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= dividend, divisor \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003edivisor != 0\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "29",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个整数，被除数\u0026nbsp;\u003ccode\u003edividend\u003c/code\u003e\u0026nbsp;和除数\u0026nbsp;\u003ccode\u003edivisor\u003c/code\u003e。将两数相除，要求不使用乘法、除法和 mod 运算符。\u003c/p\u003e\n\n\u003cp\u003e返回被除数\u0026nbsp;\u003ccode\u003edividend\u003c/code\u003e\u0026nbsp;除以除数\u0026nbsp;\u003ccode\u003edivisor\u003c/code\u003e\u0026nbsp;得到的商。\u003c/p\u003e\n\n\u003cp\u003e整数除法的结果应当截去（\u003ccode\u003etruncate\u003c/code\u003e）其小数部分，例如：\u003ccode\u003etruncate(8.345) = 8\u003c/code\u003e 以及 \u003ccode\u003etruncate(-2.7335) = -2\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e dividend = 10, divisor = 3\n\u003cstrong\u003e输出:\u003c/strong\u003e 3\n\u003cstrong\u003e解释: \u003c/strong\u003e10/3 = truncate(3.33333..) = truncate(3) = 3\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e dividend = 7, divisor = -3\n\u003cstrong\u003e输出:\u003c/strong\u003e -2\n\u003cstrong\u003e解释:\u003c/strong\u003e 7/-3 = truncate(-2.33333..) = -2\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e被除数和除数均为 32 位有符号整数。\u003c/li\u003e\n\t\u003cli\u003e除数不为\u0026nbsp;0。\u003c/li\u003e\n\t\u003cli\u003e假设我们的环境只能存储 32 位有符号整数，其数值范围是 [\u0026minus;2\u003csup\u003e31\u003c/sup\u003e,\u0026nbsp; 2\u003csup\u003e31\u0026nbsp;\u003c/sup\u003e\u0026minus; 1]。本题中，如果除法结果溢出，则返回 2\u003csup\u003e31\u0026nbsp;\u003c/sup\u003e\u0026minus; 1。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "两数相除"
  },
  "edit-distance": {
   "content": "\u003cp\u003eGiven two strings \u003ccode\u003eword1\u003c/code\u003e and \u003ccode\u003eword2\u003c/code\u003e, return \u003cem\u003ethe minimum number of operations required to convert \u003ccode\u003eword1\u003c/code\u003e to \u003ccode\u003eword2\u003c/code\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou have the following three operations permitted on a word:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eInsert a character\u003c/li\u003e\n\t\u003cli\u003eDelete a character\u003c/li\u003e\n\t\u003cli\u003eReplace a character\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e word1 = \u0026quot;horse\u0026quot;, word2 = \u0026quot;ros\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nhorse -\u0026gt; rorse (replace \u0026#39;h\u0026#39; with \u0026#39;r\u0026#39;)\nrorse -\u0026gt; rose (remove \u0026#39;r\u0026#39;)\nrose -\u0026gt; ros (remove \u0026#39;e\u0026#39;)\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e word1 = \u0026quot;intention\u0026quot;, word2 = \u0026quot;execution\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \nintention -\u0026gt; inention (remove \u0026#39;t\u0026#39;)\ninention -\u0026gt; enention (replace \u0026#39;i\u0026#39; with \u0026#39;e\u0026#39;)\nenention -\u0026gt; exention (replace \u0026#39;n\u0026#39; with \u0026#39;x\u0026#39;)\nexention -\u0026gt; exection (replace \u0026#39;n\u0026#39; with \u0026#39;c\u0026#39;)\nexection -\u0026gt; execution (insert \u0026#39;u\u0026#39;)\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= word1.length, word2.length \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword1\u003c/code\u003e and \u003ccode\u003eword2\u003c/code\u003e consist of lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "72",
   "similarQuestions": "[{\"title\": \"One Edit Distance\", \"titleSlug\": \"one-edit-distance\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u76f8\\u9694\\u4e3a 1 \\u7684\\u7f16\\u8f91\\u8ddd\\u79bb\"}, {\"title\": \"Delete Operation for Two Strings\", \"titleSlug\": \"delete-operation-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e24\\u4e2a\\u5b57\\u7b26\\u4e32\\u7684\\u5220\\u9664\\u64cd\\u4f5c\"}, {\"title\": \"Minimum ASCII Delete Sum for Two Strings\", \"titleSlug\": \"minimum-ascii-delete-sum-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e24\\u4e2a\\u5b57\\u7b26\\u4e32\\u7684\\u6700\\u5c0fASCII\\u5220\\u9664\\u548c\"}, {\"title\": \"Uncrossed Lines\", \"titleSlug\": \"uncrossed-lines\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e0d\\u76f8\\u4ea4\\u7684\\u7ebf\"}]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e给你两个单词\u0026nbsp;\u003ccode\u003eword1\u003c/code\u003e 和\u0026nbsp;\u003ccode\u003eword2\u003c/code\u003e， \u003cem\u003e请返回将\u0026nbsp;\u003ccode\u003eword1\u003c/code\u003e\u0026nbsp;转换成\u0026nbsp;\u003ccode\u003eword2\u003c/code\u003e 所使用的最少操作数\u003c/em\u003e \u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e你可以对一个单词进行如下三种操作：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e插入一个字符\u003c/li\u003e\n\t\u003cli\u003e删除一个字符\u003c/li\u003e\n\t\u003cli\u003e替换一个字符\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eword1 = \"horse\", word2 = \"ros\"\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e\nhorse -\u0026gt; rorse (将 'h' 替换为 'r')\nrorse -\u0026gt; rose (删除 'r')\nrose -\u0026gt; ros (删除 'e')\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eword1 = \"intention\", word2 = \"execution\"\n\u003cstrong\u003e输出：\u003c/strong\u003e5\n\u003cstrong\u003e解释：\u003c/strong\u003e\nintention -\u0026gt; inention (删除 't')\ninention -\u0026gt; enention (将 'i' 替换为 'e')\nenention -\u0026gt; exention (将 'n' 替换为 'x')\nexention -\u0026gt; exection (将 'n' 替换为 'c')\nexection -\u0026gt; execution (插入 'u')\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= word1.length, word2.length \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword1\u003c/code\u003e 和 \u003ccode\u003eword2\u003c/code\u003e 由小写英文字母组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "编辑距离"
  },
  "encode-and-decode-tinyurl": {
   "content": "\u003cblockquote\u003eNote: This is a companion problem to the \u003ca href=\"https://leetcode.com/discuss/interview-question/system-design/\" target=\"_blank\"\u003eSystem Design\u003c/a\u003e problem: \u003ca href=\"https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/\" target=\"_blank\"\u003eDesign TinyURL\u003c/a\u003e.\u003c/blockquote\u003e\n\n\u003cp\u003eTinyURL is a URL shortening service where you enter a URL such as \u003ccode\u003ehttps://leetcode.com/problems/design-tinyurl\u003c/code\u003e and it returns a short URL such as \u003ccode\u003ehttp://tinyurl.com/4e9iAk\u003c/code\u003e. Design a class to encode a URL and decode a tiny URL.\u003c/p\u003e\n\n\u003cp\u003eThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eSolution\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eSolution()\u003c/code\u003e Initializes the object of the system.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eString encode(String longUrl)\u003c/code\u003e Returns a tiny URL for the given \u003ccode\u003elongUrl\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eString decode(String shortUrl)\u003c/code\u003e Returns the original long URL for the given \u003ccode\u003eshortUrl\u003c/code\u003e. It is guaranteed that the given \u003ccode\u003eshortUrl\u003c/code\u003e was encoded by the same object.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e url = \u0026quot;https://leetcode.com/problems/design-tinyurl\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;https://leetcode.com/problems/design-tinyurl\u0026quot;\n\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after deconding it.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= url.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eurl\u003c/code\u003e is guranteed to be a valid URL.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "535",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Hash Function",
     "slug": "hash-function",
     "translatedName": "哈希函数"
    }
   ],
   "translatedContent": "\u003cp\u003eTinyURL是一种URL简化服务， 比如：当你输入一个URL\u0026nbsp;\u003ccode\u003ehttps://leetcode.com/problems/design-tinyurl\u003c/code\u003e\u0026nbsp;时，它将返回一个简化的URL\u0026nbsp;\u003ccode\u003ehttp://tinyurl.com/4e9iAk\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e要求：设计一个 TinyURL 的加密\u0026nbsp;\u003ccode\u003eencode\u003c/code\u003e\u0026nbsp;和解密\u0026nbsp;\u003ccode\u003edecode\u003c/code\u003e\u0026nbsp;的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。\u003c/p\u003e\n",
   "translatedTitle": "TinyURL 的加密与解密"
  },
  "er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof": {
   "content": "English description is not available for the problem. Please switch to Chinese.",
   "hints": [],
   "questionId": "100333",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一棵二叉搜索树，请找出其中第 \u003ccode\u003ek\u003c/code\u003e 大的节点的值。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n\u0026nbsp;  2\n\u003cstrong\u003e输出:\u003c/strong\u003e 4\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n\u003cstrong\u003e输出:\u003c/strong\u003e 4\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e限制：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e1 ≤ k ≤ 二叉搜索树元素个数\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉搜索树的第k大节点"
  },
  "er-jin-zhi-zhong-1de-ge-shu-lcof": {
   "content": "English description is not available for the problem. Please switch to Chinese.",
   "hints": [],
   "questionId": "100292",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    }
   ],
   "translatedContent": "\u003cp\u003e编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 \u003ca href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\"\u003e汉明重量\u003c/a\u003e).）。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\u003c/li\u003e\n\t\u003cli\u003e在 Java 中，编译器使用 \u003ca href=\"https://baike.baidu.com/item/二进制补码/5295284\"\u003e二进制补码\u003c/a\u003e 记法来表示有符号整数。因此，在上面的 \u003cstrong\u003e示例 3 \u003c/strong\u003e中，输入表示有符号整数 \u003ccode\u003e-3\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 11 (控制台输入 00000000000000000000000000001011)\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e输入的二进制串 \u003ccode\u003e\u003cstrong\u003e00000000000000000000000000001011\u003c/strong\u003e 中，共有三位为 '1'。\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 128 (控制台输入 00000000000000000000000010000000)\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003cstrong\u003e解释：\u003c/strong\u003e输入的二进制串 \u003cstrong\u003e00000000000000000000000010000000\u003c/strong\u003e 中，共有一位为 '1'。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）\n\u003cstrong\u003e输出：\u003c/strong\u003e31\n\u003cstrong\u003e解释：\u003c/strong\u003e输入的二进制串 \u003cstrong\u003e11111111111111111111111111111101\u003c/strong\u003e 中，共有 31 位为 '1'。\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e输入必须是长度为 \u003ccode\u003e32\u003c/code\u003e 的 \u003cstrong\u003e二进制串\u003c/strong\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e注意：本题与主站 191 题相同：\u003ca href=\"https://leetcode-cn.com/problems/number-of-1-bits/\"\u003ehttps://leetcode-cn.com/problems/number-of-1-bits/\u003c/a\u003e\u003c/p\u003e\n",
   "translatedTitle": "二进制中1的个数"
  },
  "evaluate-reverse-polish-notation": {
   "content": "\u003cp\u003eEvaluate the value of an arithmetic expression in \u003ca href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\"\u003eReverse Polish Notation\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eValid operators are \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, and \u003ccode\u003e/\u003c/code\u003e. Each operand may be an integer or another expression.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that division between two integers should truncate toward zero.\u003c/p\u003e\n\n\u003cp\u003eIt is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e tokens = [\u0026quot;2\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;*\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 9\n\u003cstrong\u003eExplanation:\u003c/strong\u003e ((2 + 1) * 3) = 9\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e tokens = [\u0026quot;4\u0026quot;,\u0026quot;13\u0026quot;,\u0026quot;5\u0026quot;,\u0026quot;/\u0026quot;,\u0026quot;+\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003cstrong\u003eExplanation:\u003c/strong\u003e (4 + (13 / 5)) = 6\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e tokens = [\u0026quot;10\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;-11\u0026quot;,\u0026quot;*\u0026quot;,\u0026quot;/\u0026quot;,\u0026quot;*\u0026quot;,\u0026quot;17\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;5\u0026quot;,\u0026quot;+\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 22\n\u003cstrong\u003eExplanation:\u003c/strong\u003e ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= tokens.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etokens[i]\u003c/code\u003e is either an operator: \u003ccode\u003e\u0026quot;+\u0026quot;\u003c/code\u003e, \u003ccode\u003e\u0026quot;-\u0026quot;\u003c/code\u003e, \u003ccode\u003e\u0026quot;*\u0026quot;\u003c/code\u003e, or \u003ccode\u003e\u0026quot;/\u0026quot;\u003c/code\u003e, or an integer in the range \u003ccode\u003e[-200, 200]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "150",
   "similarQuestions": "[{\"title\": \"Basic Calculator\", \"titleSlug\": \"basic-calculator\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u57fa\\u672c\\u8ba1\\u7b97\\u5668\"}, {\"title\": \"Expression Add Operators\", \"titleSlug\": \"expression-add-operators\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u7ed9\\u8868\\u8fbe\\u5f0f\\u6dfb\\u52a0\\u8fd0\\u7b97\\u7b26\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e根据\u003ca href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\" target=\"_blank\"\u003e 逆波兰表示法\u003c/a\u003e，求表达式的值。\u003c/p\u003e\n\n\u003cp\u003e有效的算符包括\u0026nbsp;\u003ccode\u003e+\u003c/code\u003e、\u003ccode\u003e-\u003c/code\u003e、\u003ccode\u003e*\u003c/code\u003e、\u003ccode\u003e/\u003c/code\u003e\u0026nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e注意\u0026nbsp;\u003c/b\u003e两个整数之间的除法只保留整数部分。\u003c/p\u003e\n\n\u003cp\u003e可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n\u003cstrong\u003e输出：\u003c/strong\u003e9\n\u003cstrong\u003e解释：\u003c/strong\u003e该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n\u003cstrong\u003e输出：\u003c/strong\u003e6\n\u003cstrong\u003e解释：\u003c/strong\u003e该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n\u003cstrong\u003e输出：\u003c/strong\u003e22\n\u003cstrong\u003e解释：\u003c/strong\u003e该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= tokens.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etokens[i]\u003c/code\u003e\u0026nbsp;是一个算符（\u003ccode\u003e\"+\"\u003c/code\u003e、\u003ccode\u003e\"-\"\u003c/code\u003e、\u003ccode\u003e\"*\"\u003c/code\u003e 或 \u003ccode\u003e\"/\"\u003c/code\u003e），或是在范围 \u003ccode\u003e[-200, 200]\u003c/code\u003e 内的一个整数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e逆波兰表达式：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e平常使用的算式则是一种中缀表达式，如 \u003ccode\u003e( 1 + 2 ) * ( 3 + 4 )\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e该算式的逆波兰表达式写法为 \u003ccode\u003e( ( 1 2 + ) ( 3 4 + ) * )\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e逆波兰表达式主要有以下两个优点：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e去掉括号后表达式无歧义，上式即便写成 \u003ccode\u003e1 2 + 3 4 + * \u003c/code\u003e也可以依据次序计算出正确结果。\u003c/li\u003e\n\t\u003cli\u003e适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "逆波兰表达式求值"
  },
  "excel-sheet-column-number": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003ecolumnTitle\u003c/code\u003e that represents the column title as appear in an Excel sheet, return \u003cem\u003eits corresponding column number\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eFor example:\u003c/p\u003e\n\n\u003cpre\u003e\nA -\u0026gt; 1\nB -\u0026gt; 2\nC -\u0026gt; 3\n...\nZ -\u0026gt; 26\nAA -\u0026gt; 27\nAB -\u0026gt; 28 \n...\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e columnTitle = \u0026quot;A\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e columnTitle = \u0026quot;AB\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 28\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e columnTitle = \u0026quot;ZY\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 701\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= columnTitle.length \u0026lt;= 7\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ecolumnTitle\u003c/code\u003e consists only of uppercase English letters.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ecolumnTitle\u003c/code\u003e is in the range \u003ccode\u003e[\u0026quot;A\u0026quot;, \u0026quot;FXSHRXW\u0026quot;]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "171",
   "similarQuestions": "[{\"title\": \"Excel Sheet Column Title\", \"titleSlug\": \"excel-sheet-column-title\", \"difficulty\": \"Easy\", \"translatedTitle\": \"Excel\\u8868\\u5217\\u540d\\u79f0\"}]",
   "topicTags": [
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个字符串\u0026nbsp;\u003ccode\u003ecolumnTitle\u003c/code\u003e ，表示 Excel 表格中的列名称。返回 \u003cem\u003e该列名称对应的列序号\u003c/em\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e例如：\u003c/p\u003e\n\n\u003cpre\u003e\nA -\u0026gt; 1\nB -\u0026gt; 2\nC -\u0026gt; 3\n...\nZ -\u0026gt; 26\nAA -\u0026gt; 27\nAB -\u0026gt; 28 \n...\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e columnTitle = \"A\"\n\u003cstrong\u003e输出:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003ecolumnTitle = \"AB\"\n\u003cstrong\u003e输出:\u003c/strong\u003e 28\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003ecolumnTitle = \"ZY\"\n\u003cstrong\u003e输出:\u003c/strong\u003e 701\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= columnTitle.length \u0026lt;= 7\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ecolumnTitle\u003c/code\u003e 仅由大写英文组成\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ecolumnTitle\u003c/code\u003e 在范围 \u003ccode\u003e[\"A\", \"FXSHRXW\"]\u003c/code\u003e 内\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "Excel 表列序号"
  },
  "factor-combinations": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "fan-zhuan-lian-biao-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "fei-bo-na-qi-shu-lie-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "fibonacci-number": {
   "content": "\u003cp\u003eThe \u003cb\u003eFibonacci numbers\u003c/b\u003e, commonly denoted \u003ccode\u003eF(n)\u003c/code\u003e form a sequence, called the \u003cb\u003eFibonacci sequence\u003c/b\u003e, such that each number is the sum of the two preceding ones, starting from \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e1\u003c/code\u003e. That is,\u003c/p\u003e\n\n\u003cpre\u003e\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n \u0026gt; 1.\n\u003c/pre\u003e\n\n\u003cp\u003eGiven \u003ccode\u003en\u003c/code\u003e, calculate \u003ccode\u003eF(n)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003cstrong\u003eExplanation:\u003c/strong\u003e F(2) = F(1) + F(0) = 1 + 0 = 1.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e F(3) = F(2) + F(1) = 1 + 1 = 2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e F(4) = F(3) + F(2) = 2 + 1 = 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= n \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "1013",
   "similarQuestions": "[{\"title\": \"Climbing Stairs\", \"titleSlug\": \"climbing-stairs\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u722c\\u697c\\u68af\"}, {\"title\": \"Split Array into Fibonacci Sequence\", \"titleSlug\": \"split-array-into-fibonacci-sequence\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5c06\\u6570\\u7ec4\\u62c6\\u5206\\u6210\\u6590\\u6ce2\\u90a3\\u5951\\u5e8f\\u5217\"}, {\"title\": \"Length of Longest Fibonacci Subsequence\", \"titleSlug\": \"length-of-longest-fibonacci-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u957f\\u7684\\u6590\\u6ce2\\u90a3\\u5951\\u5b50\\u5e8f\\u5217\\u7684\\u957f\\u5ea6\"}]",
   "topicTags": [
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Memoization",
     "slug": "memoization",
     "translatedName": "记忆化搜索"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e\u003cstrong\u003e斐波那契数\u003c/strong\u003e\u0026nbsp;（通常用\u0026nbsp;\u003ccode\u003eF(n)\u003c/code\u003e 表示）形成的序列称为 \u003cstrong\u003e斐波那契数列\u003c/strong\u003e 。该数列由\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e 和 \u003ccode\u003e1\u003c/code\u003e 开始，后面的每一项数字都是前面两项数字的和。也就是：\u003c/p\u003e\n\n\u003cpre\u003e\nF(0) = 0，F(1)\u0026nbsp;= 1\nF(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1\n\u003c/pre\u003e\n\n\u003cp\u003e给定\u0026nbsp;\u003ccode\u003en\u003c/code\u003e ，请计算 \u003ccode\u003eF(n)\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003cstrong\u003e解释：\u003c/strong\u003eF(2) = F(1) + F(0) = 1 + 0 = 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003eF(3) = F(2) + F(1) = 1 + 1 = 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 4\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003eF(4) = F(3) + F(2) = 2 + 1 = 3\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= n \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "斐波那契数"
  },
  "find-all-numbers-disappeared-in-an-array": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "find-first-and-last-position-of-element-in-sorted-array": {
   "content": "\u003cp\u003eGiven an array of integers \u003ccode\u003enums\u003c/code\u003e sorted in non-decreasing order, find the starting and ending position of a given \u003ccode\u003etarget\u003c/code\u003e value.\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003etarget\u003c/code\u003e is not found in the array, return \u003ccode\u003e[-1, -1]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou must\u0026nbsp;write an algorithm with\u0026nbsp;\u003ccode\u003eO(log n)\u003c/code\u003e runtime complexity.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [5,7,7,8,8,10], target = 8\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3,4]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [5,7,7,8,8,10], target = 6\n\u003cstrong\u003eOutput:\u003c/strong\u003e [-1,-1]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [], target = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e [-1,-1]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e\u0026nbsp;\u0026lt;= nums[i]\u0026nbsp;\u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e is a non-decreasing array.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e\u0026nbsp;\u0026lt;= target\u0026nbsp;\u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "34",
   "similarQuestions": "[{\"title\": \"First Bad Version\", \"titleSlug\": \"first-bad-version\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u7b2c\\u4e00\\u4e2a\\u9519\\u8bef\\u7684\\u7248\\u672c\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个按照升序排列的整数数组 \u003ccode\u003enums\u003c/code\u003e，和一个目标值 \u003ccode\u003etarget\u003c/code\u003e。找出给定目标值在数组中的开始位置和结束位置。\u003c/p\u003e\n\n\u003cp\u003e如果数组中不存在目标值 \u003ccode\u003etarget\u003c/code\u003e，返回 \u003ccode\u003e[-1, -1]\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e你可以设计并实现时间复杂度为 \u003ccode\u003eO(log n)\u003c/code\u003e 的算法解决此问题吗？\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [\u003ccode\u003e5,7,7,8,8,10]\u003c/code\u003e, target = 8\n\u003cstrong\u003e输出：\u003c/strong\u003e[3,4]\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [\u003ccode\u003e5,7,7,8,8,10]\u003c/code\u003e, target = 6\n\u003cstrong\u003e输出：\u003c/strong\u003e[-1,-1]\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [], target = 0\n\u003cstrong\u003e输出：\u003c/strong\u003e[-1,-1]\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= nums.length \u003c= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u003c= nums[i] \u003c= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e 是一个非递减数组\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u003c= target \u003c= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "在排序数组中查找元素的第一个和最后一个位置"
  },
  "find-numbers-with-even-number-of-digits": {
   "content": "\u003cp\u003eGiven an array \u003ccode\u003enums\u003c/code\u003e of integers, return how many of them contain an \u003cstrong\u003eeven number\u003c/strong\u003e of digits.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [12,345,2,6,7896]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation: \n\u003c/strong\u003e12 contains 2 digits (even number of digits).\u0026nbsp;\n345 contains 3 digits (odd number of digits).\u0026nbsp;\n2 contains 1 digit (odd number of digits).\u0026nbsp;\n6 contains 1 digit (odd number of digits).\u0026nbsp;\n7896 contains 4 digits (even number of digits).\u0026nbsp;\nTherefore only 12 and 7896 contain an even number of digits.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [555,901,482,1771]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1 \n\u003cstrong\u003eExplanation: \u003c/strong\u003e\nOnly 1771 contains an even number of digits.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "How to compute the number of digits of a number ?",
    "Divide the number by 10 again and again to get the number of digits."
   ],
   "questionId": "1421",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数数组\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e，请你返回其中位数为\u0026nbsp;\u003cstrong\u003e偶数\u003c/strong\u003e\u0026nbsp;的数字的个数。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003enums = [12,345,2,6,7896]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\n\u003c/strong\u003e12 是 2 位数字（位数为偶数）\u0026nbsp;\n345 是 3 位数字（位数为奇数）\u0026nbsp;\u0026nbsp;\n2 是 1 位数字（位数为奇数）\u0026nbsp;\n6 是 1 位数字 位数为奇数）\u0026nbsp;\n7896 是 4 位数字（位数为偶数）\u0026nbsp;\u0026nbsp;\n因此只有 12 和 7896 是位数为偶数的数字\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003enums = [555,901,482,1771]\n\u003cstrong\u003e输出：\u003c/strong\u003e1 \n\u003cstrong\u003e解释： \u003c/strong\u003e\n只有 1771 是位数为偶数的数字。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums[i] \u0026lt;= 10^5\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "统计位数为偶数的数字"
  },
  "find-peak-element": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "find-pivot-index": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "find-smallest-letter-greater-than-target": {
   "content": "\u003cp\u003eGiven a characters array \u003ccode\u003eletters\u003c/code\u003e that is sorted in \u003cstrong\u003enon-decreasing\u003c/strong\u003e order and a character \u003ccode\u003etarget\u003c/code\u003e, return \u003cem\u003ethe smallest character in the array that is larger than \u003c/em\u003e\u003ccode\u003etarget\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that the letters wrap around.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, if \u003ccode\u003etarget == \u0026#39;z\u0026#39;\u003c/code\u003e and \u003ccode\u003eletters == [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]\u003c/code\u003e, the answer is \u003ccode\u003e\u0026#39;a\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e letters = [\u0026quot;c\u0026quot;,\u0026quot;f\u0026quot;,\u0026quot;j\u0026quot;], target = \u0026quot;a\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;c\u0026quot;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e letters = [\u0026quot;c\u0026quot;,\u0026quot;f\u0026quot;,\u0026quot;j\u0026quot;], target = \u0026quot;c\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;f\u0026quot;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e letters = [\u0026quot;c\u0026quot;,\u0026quot;f\u0026quot;,\u0026quot;j\u0026quot;], target = \u0026quot;d\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;f\u0026quot;\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e2 \u0026lt;= letters.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eletters[i]\u003c/code\u003e is a lowercase English letter.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eletters\u003c/code\u003e is sorted in \u003cstrong\u003enon-decreasing\u003c/strong\u003e order.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eletters\u003c/code\u003e contains at least two different characters.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etarget\u003c/code\u003e is a lowercase English letter.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Try to find whether each of 26 next letters are in the given string array."
   ],
   "questionId": "745",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个排序后的字符列表 \u003ccode\u003eletters\u003c/code\u003e ，列表中只包含小写英文字母。另给出一个目标字母\u0026nbsp;\u003ccode\u003etarget\u003c/code\u003e，请你寻找在这一有序列表里比目标字母大的最小字母。\u003c/p\u003e\n\n\u003cp\u003e在比较时，字母是依序循环出现的。举个例子：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e如果目标字母 \u003ccode\u003etarget = 'z'\u003c/code\u003e 并且字符列表为\u0026nbsp;\u003ccode\u003eletters = ['a', 'b']\u003c/code\u003e，则答案返回\u0026nbsp;\u003ccode\u003e'a'\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003eletters = [\"c\", \"f\", \"j\"]，target = \"a\"\n\u003cstrong\u003e输出:\u003c/strong\u003e \"c\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e letters = [\"c\",\"f\",\"j\"], target = \"c\"\n\u003cstrong\u003e输出:\u003c/strong\u003e \"f\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e letters = [\"c\",\"f\",\"j\"], target = \"d\"\n\u003cstrong\u003e输出:\u003c/strong\u003e \"f\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e2 \u0026lt;= letters.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eletters[i]\u003c/code\u003e\u0026nbsp;是一个小写字母\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eletters\u003c/code\u003e 按非递减顺序排序\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eletters\u003c/code\u003e 最少包含两个不同的字母\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etarget\u003c/code\u003e 是一个小写字母\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "寻找比目标字母大的最小字母"
  },
  "find-the-difference": {
   "content": "\u003cp\u003eYou are given two strings \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eString \u003ccode\u003et\u003c/code\u003e is generated by random shuffling string \u003ccode\u003es\u003c/code\u003e and then add one more letter at a random position.\u003c/p\u003e\n\n\u003cp\u003eReturn the letter that was added to \u003ccode\u003et\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;abcd\u0026quot;, t = \u0026quot;abcde\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;e\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026#39;e\u0026#39; is the letter that was added.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;\u0026quot;, t = \u0026quot;y\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;y\u0026quot;\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= s.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003et.length == s.length + 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e consist of lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "389",
   "similarQuestions": "[{\"title\": \"Single Number\", \"titleSlug\": \"single-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u53ea\\u51fa\\u73b0\\u4e00\\u6b21\\u7684\\u6570\\u5b57\"}]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个字符串 \u003ccode\u003es\u003c/code\u003e 和 \u003ccode\u003et\u003c/code\u003e\u0026nbsp;，它们只包含小写字母。\u003c/p\u003e\n\n\u003cp\u003e字符串 \u003ccode\u003et\u003c/code\u003e\u0026nbsp;由字符串 \u003ccode\u003es\u003c/code\u003e 随机重排，然后在随机位置添加一个字母。\u003c/p\u003e\n\n\u003cp\u003e请找出在 \u003ccode\u003et\u003c/code\u003e\u0026nbsp;中被添加的字母。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"abcd\", t = \"abcde\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"e\"\n\u003cstrong\u003e解释：\u003c/strong\u003e'e' 是那个被添加的字母。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"\", t = \"y\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"y\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= s.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003et.length == s.length + 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 和 \u003ccode\u003et\u003c/code\u003e 只包含小写字母\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "找不同"
  },
  "find-the-distance-value-between-two-arrays": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "first-bad-version": {
   "content": "\u003cp\u003eYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\u003c/p\u003e\n\n\u003cp\u003eSuppose you have \u003ccode\u003en\u003c/code\u003e versions \u003ccode\u003e[1, 2, ..., n]\u003c/code\u003e and you want to find out the first bad one, which causes all the following ones to be bad.\u003c/p\u003e\n\n\u003cp\u003eYou are given an API \u003ccode\u003ebool isBadVersion(version)\u003c/code\u003e which returns whether \u003ccode\u003eversion\u003c/code\u003e is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 5, bad = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\ncall isBadVersion(3) -\u0026gt; false\ncall isBadVersion(5)\u0026nbsp;-\u0026gt; true\ncall isBadVersion(4)\u0026nbsp;-\u0026gt; true\nThen 4 is the first bad version.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 1, bad = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= bad \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "278",
   "similarQuestions": "[{\"title\": \"Find First and Last Position of Element in Sorted Array\", \"titleSlug\": \"find-first-and-last-position-of-element-in-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5728\\u6392\\u5e8f\\u6570\\u7ec4\\u4e2d\\u67e5\\u627e\\u5143\\u7d20\\u7684\\u7b2c\\u4e00\\u4e2a\\u548c\\u6700\\u540e\\u4e00\\u4e2a\\u4f4d\\u7f6e\"}, {\"title\": \"Search Insert Position\", \"titleSlug\": \"search-insert-position\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u641c\\u7d22\\u63d2\\u5165\\u4f4d\\u7f6e\"}, {\"title\": \"Guess Number Higher or Lower\", \"titleSlug\": \"guess-number-higher-or-lower\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u731c\\u6570\\u5b57\\u5927\\u5c0f\"}]",
   "topicTags": [
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Interactive",
     "slug": "interactive",
     "translatedName": "交互"
    }
   ],
   "translatedContent": "\u003cp\u003e你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\u003c/p\u003e\n\n\u003cp\u003e假设你有 \u003ccode\u003en\u003c/code\u003e 个版本 \u003ccode\u003e[1, 2, ..., n]\u003c/code\u003e，你想找出导致之后所有版本出错的第一个错误的版本。\u003c/p\u003e\n\n\u003cp\u003e你可以通过调用 \u003ccode\u003ebool isBadVersion(version)\u003c/code\u003e 接口来判断版本号 \u003ccode\u003eversion\u003c/code\u003e 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\u003c/p\u003e\n \n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 5, bad = 4\n\u003cstrong\u003e输出：\u003c/strong\u003e4\n\u003cstrong\u003e解释：\u003c/strong\u003e\n\u003ccode\u003e调用 isBadVersion(3) -\u003e false \n调用 isBadVersion(5) -\u003e true \n调用 isBadVersion(4) -\u003e true\u003c/code\u003e\n\u003ccode\u003e所以，4 是第一个错误的版本。\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 1, bad = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= bad \u003c= n \u003c= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "第一个错误的版本"
  },
  "first-unique-character-in-a-string": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e, \u003cem\u003efind the first non-repeating character in it and return its index\u003c/em\u003e. If it does not exist, return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"leetcode\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"loveleetcode\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"aabb\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consists of only lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "387",
   "similarQuestions": "[{\"title\": \"Sort Characters By Frequency\", \"titleSlug\": \"sort-characters-by-frequency\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6839\\u636e\\u5b57\\u7b26\\u51fa\\u73b0\\u9891\\u7387\\u6392\\u5e8f\"}]",
   "topicTags": [
    {
     "name": "Queue",
     "slug": "queue",
     "translatedName": "队列"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Counting",
     "slug": "counting",
     "translatedName": "计数"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个字符串\u0026nbsp;\u003ccode\u003es\u003c/code\u003e\u0026nbsp;，找到 \u003cem\u003e它的第一个不重复的字符，并返回它的索引\u003c/em\u003e 。如果不存在，则返回 \u003ccode\u003e-1\u003c/code\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s = \"leetcode\"\n\u003cstrong\u003e输出:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s = \"loveleetcode\"\n\u003cstrong\u003e输出:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s = \"aabb\"\n\u003cstrong\u003e输出:\u003c/strong\u003e -1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e\u0026nbsp;只包含小写字母\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "字符串中的第一个唯一字符"
  },
  "fixed-point": {
   "content": "\u003cp\u003eGiven an array of distinct integers \u003ccode\u003earr\u003c/code\u003e, where \u003ccode\u003earr\u003c/code\u003e is sorted in \u003cstrong\u003eascending order\u003c/strong\u003e, return the smallest index \u003ccode\u003ei\u003c/code\u003e that satisfies \u003ccode\u003earr[i] == i\u003c/code\u003e. If there is no such index, return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e arr = [-10,-5,0,3,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e For the given array, \u003ccode\u003earr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3\u003c/code\u003e, thus the output is 3.\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e arr = [0,2,5,8,17]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u003ccode\u003earr[0] = 0\u003c/code\u003e, thus the output is 0.\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e arr = [-10,-5,3,4,7,9]\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There is no such \u003ccode\u003ei\u003c/code\u003e that \u003ccode\u003earr[i] == i\u003c/code\u003e, thus the output is -1.\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= arr.length \u0026lt; 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= arr[i] \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e The \u003ccode\u003eO(n)\u003c/code\u003e solution is very straightforward. Can we do better?",
   "hints": [
    "Loop over the array and check the first index i such A[i] == i"
   ],
   "questionId": "1066",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给定已经按 \u003cstrong\u003e升序\u003c/strong\u003e 排列、由不同整数组成的数组 \u003ccode\u003earr\u003c/code\u003e，返回满足 \u003ccode\u003earr[i] == i\u003c/code\u003e 的最小索引 \u003ccode\u003ei\u003c/code\u003e。如果不存在这样的 \u003ccode\u003ei\u003c/code\u003e，返回 \u003ccode\u003e-1\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003earr = [-10,-5,0,3,7]\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e对于给定的数组，\u003ccode\u003earr[0] = -10，arr[1] = -5，arr[2] = 0，arr[3] = 3\u003c/code\u003e，因此输出为 3 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003earr = [0,2,5,8,17]\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003cstrong\u003e解释：\u003c/strong\u003e\u003ccode\u003earr[0] = 0\u003c/code\u003e，因此输出为 0 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003earr = [-10,-5,3,4,7,9]\n\u003cstrong\u003e输出：\u003c/strong\u003e-1\n\u003cstrong\u003e解释：\u003c/strong\u003e不存在这样的 i 满足 \u003ccode\u003earr[i] = i\u003c/code\u003e，因此输出为 -1 。\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= arr.length \u003c 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u003c= arr[i] \u003c= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e时间复杂度为 \u003ccode\u003eO(n)\u003c/code\u003e 的解决方案很直观也很简单。你可以设计更优的解决方案吗？\u003c/p\u003e\n",
   "translatedTitle": "不动点"
  },
  "fizz-buzz": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "fizz-buzz-multithreaded": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "flatten-2d-vector": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "flatten-a-multilevel-doubly-linked-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "flatten-binary-tree-to-linked-list": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, flatten the tree into a \u0026quot;linked list\u0026quot;:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe \u0026quot;linked list\u0026quot; should use the same \u003ccode\u003eTreeNode\u003c/code\u003e class where the \u003ccode\u003eright\u003c/code\u003e child pointer points to the next node in the list and the \u003ccode\u003eleft\u003c/code\u003e child pointer is always \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe \u0026quot;linked list\u0026quot; should be in the same order as a \u003ca href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR\" target=\"_blank\"\u003e\u003cstrong\u003epre-order\u003c/strong\u003e\u003cstrong\u003e traversal\u003c/strong\u003e\u003c/a\u003e of the binary tree.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,5,3,4,null,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,null,2,null,3,null,4,null,5,null,6]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 2000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Can you flatten the tree in-place (with \u003ccode\u003eO(1)\u003c/code\u003e extra space)?",
   "hints": [
    "If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal."
   ],
   "questionId": "114",
   "similarQuestions": "[{\"title\": \"Flatten a Multilevel Doubly Linked List\", \"titleSlug\": \"flatten-a-multilevel-doubly-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6241\\u5e73\\u5316\\u591a\\u7ea7\\u53cc\\u5411\\u94fe\\u8868\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给你二叉树的根结点 \u003ccode\u003eroot\u003c/code\u003e ，请你将它展开为一个单链表：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e展开后的单链表应该同样使用 \u003ccode\u003eTreeNode\u003c/code\u003e ，其中 \u003ccode\u003eright\u003c/code\u003e 子指针指向链表中下一个结点，而左子指针始终为 \u003ccode\u003enull\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e展开后的单链表应该与二叉树 \u003ca href=\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\" target=\"_blank\"\u003e\u003cstrong\u003e先序遍历\u003c/strong\u003e\u003c/a\u003e 顺序相同。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2,5,3,4,null,6]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,null,2,null,3,null,4,null,5,null,6]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = []\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [0]\n\u003cstrong\u003e输出：\u003c/strong\u003e[0]\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中结点数在范围 \u003ccode\u003e[0, 2000]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u003c= Node.val \u003c= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你可以使用原地算法（\u003ccode\u003eO(1)\u003c/code\u003e 额外空间）展开这棵树吗？\u003c/p\u003e\n",
   "translatedTitle": "二叉树展开为链表"
  },
  "flipping-an-image": {
   "content": "\u003cp\u003eGiven an \u003ccode\u003en x n\u003c/code\u003e binary matrix \u003ccode\u003eimage\u003c/code\u003e, flip the image \u003cstrong\u003ehorizontally\u003c/strong\u003e, then invert it, and return \u003cem\u003ethe resulting image\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo flip an image horizontally means that each row of the image is reversed.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, flipping \u003ccode\u003e[1,1,0]\u003c/code\u003e horizontally results in \u003ccode\u003e[0,1,1]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTo invert an image means that each \u003ccode\u003e0\u003c/code\u003e is replaced by \u003ccode\u003e1\u003c/code\u003e, and each \u003ccode\u003e1\u003c/code\u003e is replaced by \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, inverting \u003ccode\u003e[0,1,1]\u003c/code\u003e results in \u003ccode\u003e[1,0,0]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e image = [[1,1,0],[1,0,1],[0,0,0]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1,0,0],[0,1,0],[1,1,1]]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003en == image.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == image[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eimages[i][j]\u003c/code\u003e is either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "861",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    },
    {
     "name": "Simulation",
     "slug": "simulation",
     "translatedName": "模拟"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003en x n\u003c/code\u003e\u0026nbsp;的二进制矩阵\u0026nbsp;\u003ccode\u003eimage\u003c/code\u003e\u0026nbsp;，先 \u003cstrong\u003e水平\u003c/strong\u003e 翻转图像，然后\u0026nbsp;\u003cstrong\u003e反转\u0026nbsp;\u003c/strong\u003e图像并返回\u0026nbsp;\u003cem\u003e结果\u003c/em\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e水平\u003c/strong\u003e翻转图片就是将图片的每一行都进行翻转，即逆序。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e例如，水平翻转\u0026nbsp;\u003ccode\u003e[1,1,0]\u003c/code\u003e\u0026nbsp;的结果是\u0026nbsp;\u003ccode\u003e[0,1,1]\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e反转\u003c/strong\u003e图片的意思是图片中的\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e\u0026nbsp;全部被\u0026nbsp;\u003ccode\u003e1\u003c/code\u003e\u0026nbsp;替换，\u0026nbsp;\u003ccode\u003e1\u003c/code\u003e\u0026nbsp;全部被\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e\u0026nbsp;替换。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e例如，反转\u0026nbsp;\u003ccode\u003e[0,1,1]\u003c/code\u003e\u0026nbsp;的结果是\u0026nbsp;\u003ccode\u003e[1,0,0]\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eimage = [[1,1,0],[1,0,1],[0,0,0]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1,0,0],[0,1,0],[1,1,1]]\n\u003cstrong\u003e解释：\u003c/strong\u003e首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eimage = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\u003cstrong\u003e解释：\u003c/strong\u003e首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003en == image.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == image[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eimages[i][j]\u003c/code\u003e\u0026nbsp;==\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e\u0026nbsp;或\u0026nbsp;\u003ccode\u003e1\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "翻转图像"
  },
  "game-of-life": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "generate-parentheses": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "gray-code": {
   "content": "\u003cp\u003eAn \u003cstrong\u003en-bit gray code sequence\u003c/strong\u003e is a sequence of \u003ccode\u003e2\u003csup\u003en\u003c/sup\u003e\u003c/code\u003e integers where:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eEvery integer is in the \u003cstrong\u003einclusive\u003c/strong\u003e range \u003ccode\u003e[0, 2\u003csup\u003en\u003c/sup\u003e - 1]\u003c/code\u003e,\u003c/li\u003e\n\t\u003cli\u003eThe first integer is \u003ccode\u003e0\u003c/code\u003e,\u003c/li\u003e\n\t\u003cli\u003eAn integer appears \u003cstrong\u003eno more than once\u003c/strong\u003e in the sequence,\u003c/li\u003e\n\t\u003cli\u003eThe binary representation of every pair of \u003cstrong\u003eadjacent\u003c/strong\u003e integers differs by \u003cstrong\u003eexactly one bit\u003c/strong\u003e, and\u003c/li\u003e\n\t\u003cli\u003eThe binary representation of the \u003cstrong\u003efirst\u003c/strong\u003e and \u003cstrong\u003elast\u003c/strong\u003e integers differs by \u003cstrong\u003eexactly one bit\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eGiven an integer \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003eany valid \u003cstrong\u003en-bit gray code sequence\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0,1,3,2]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 0\u003cu\u003e0\u003c/u\u003e and 0\u003cu\u003e1\u003c/u\u003e differ by one bit\n- \u003cu\u003e0\u003c/u\u003e1 and \u003cu\u003e1\u003c/u\u003e1 differ by one bit\n- 1\u003cu\u003e1\u003c/u\u003e and 1\u003cu\u003e0\u003c/u\u003e differ by one bit\n- \u003cu\u003e1\u003c/u\u003e0 and \u003cu\u003e0\u003c/u\u003e0 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- \u003cu\u003e0\u003c/u\u003e0 and \u003cu\u003e1\u003c/u\u003e0 differ by one bit\n- 1\u003cu\u003e0\u003c/u\u003e and 1\u003cu\u003e1\u003c/u\u003e differ by one bit\n- \u003cu\u003e1\u003c/u\u003e1 and \u003cu\u003e0\u003c/u\u003e1 differ by one bit\n- 0\u003cu\u003e1\u003c/u\u003e and 0\u003cu\u003e0\u003c/u\u003e differ by one bit\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 16\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "89",
   "similarQuestions": "[{\"title\": \"1-bit and 2-bit Characters\", \"titleSlug\": \"1-bit-and-2-bit-characters\", \"difficulty\": \"Easy\", \"translatedTitle\": \"1 \\u6bd4\\u7279\\u4e0e 2 \\u6bd4\\u7279\\u5b57\\u7b26\"}]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Backtracking",
     "slug": "backtracking",
     "translatedName": "回溯"
    }
   ],
   "translatedContent": "\u003cstrong\u003en 位格雷码序列\u003c/strong\u003e 是一个由 \u003ccode\u003e2\u003csup\u003en\u003c/sup\u003e\u003c/code\u003e 个整数组成的序列，其中：\n\u003cul\u003e\n\t\u003cli\u003e每个整数都在范围 \u003ccode\u003e[0, 2\u003csup\u003en\u003c/sup\u003e - 1]\u003c/code\u003e 内（含 \u003ccode\u003e0\u003c/code\u003e 和 \u003ccode\u003e2\u003csup\u003en\u003c/sup\u003e - 1\u003c/code\u003e）\u003c/li\u003e\n\t\u003cli\u003e第一个整数是 \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e一个整数在序列中出现 \u003cstrong\u003e不超过一次\u003c/strong\u003e\u003c/li\u003e\n\t\u003cli\u003e每对 \u003cstrong\u003e相邻\u003c/strong\u003e 整数的二进制表示 \u003cstrong\u003e恰好一位不同\u003c/strong\u003e ，且\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003e第一个\u003c/strong\u003e 和 \u003cstrong\u003e最后一个\u003c/strong\u003e 整数的二进制表示 \u003cstrong\u003e恰好一位不同\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e给你一个整数 \u003ccode\u003en\u003c/code\u003e ，返回任一有效的 \u003cstrong\u003en 位格雷码序列\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e[0,1,3,2]\n\u003cstrong\u003e解释：\u003c/strong\u003e\n[0,1,3,2] 的二进制表示是 [00,01,11,10] 。\n- 0\u003cstrong\u003e\u003cem\u003e0\u003c/em\u003e\u003c/strong\u003e 和 0\u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e 有一位不同\n- \u003cem\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/em\u003e1 和 \u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e1 有一位不同\n- 1\u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e 和 1\u003cem\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/em\u003e 有一位不同\n- \u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e0 和 \u003cem\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/em\u003e0 有一位不同\n[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。\n- \u003cem\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/em\u003e0 和 \u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e0 有一位不同\n- 1\u003cem\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/em\u003e 和 1\u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e 有一位不同\n- \u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e1 和 \u003cem\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/em\u003e1 有一位不同\n- 0\u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e 和 0\u003cem\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/em\u003e 有一位不同\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[0,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 16\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "格雷编码"
  },
  "group-anagrams": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "group-shifted-strings": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "guess-number-higher-or-lower": {
   "content": "\u003cp\u003eWe are playing the Guess Game. The game is as follows:\u003c/p\u003e\n\n\u003cp\u003eI pick a number from \u003ccode\u003e1\u003c/code\u003e to \u003ccode\u003en\u003c/code\u003e. You have to guess which number I picked.\u003c/p\u003e\n\n\u003cp\u003eEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\u003c/p\u003e\n\n\u003cp\u003eYou call a pre-defined API \u003ccode\u003eint guess(int num)\u003c/code\u003e, which returns three possible results:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-1\u003c/code\u003e: Your guess is higher than the number I picked (i.e. \u003ccode\u003enum \u0026gt; pick\u003c/code\u003e).\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1\u003c/code\u003e: Your guess is lower than the number I picked (i.e. \u003ccode\u003enum \u0026lt; pick\u003c/code\u003e).\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0\u003c/code\u003e: your guess is equal to the number I picked (i.e. \u003ccode\u003enum == pick\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe number that I picked\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 10, pick = 6\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 1, pick = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 2, pick = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= pick \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "374",
   "similarQuestions": "[{\"title\": \"First Bad Version\", \"titleSlug\": \"first-bad-version\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u7b2c\\u4e00\\u4e2a\\u9519\\u8bef\\u7684\\u7248\\u672c\"}, {\"title\": \"Guess Number Higher or Lower II\", \"titleSlug\": \"guess-number-higher-or-lower-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u731c\\u6570\\u5b57\\u5927\\u5c0f II\"}, {\"title\": \"Find K Closest Elements\", \"titleSlug\": \"find-k-closest-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u627e\\u5230 K \\u4e2a\\u6700\\u63a5\\u8fd1\\u7684\\u5143\\u7d20\"}]",
   "topicTags": [
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Interactive",
     "slug": "interactive",
     "translatedName": "交互"
    }
   ],
   "translatedContent": "\u003cp\u003e猜数字游戏的规则如下：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e每轮游戏，我都会从 \u003cstrong\u003e1\u003c/strong\u003e 到 \u003cem\u003e\u003cstrong\u003en\u003c/strong\u003e\u003c/em\u003e 随机选择一个数字。 请你猜选出的是哪个数字。\u003c/li\u003e\n\t\u003cli\u003e如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e你可以通过调用一个预先定义好的接口 \u003ccode\u003eint guess(int num)\u003c/code\u003e 来获取猜测结果，返回值一共有 3 种可能的情况（\u003ccode\u003e-1\u003c/code\u003e，\u003ccode\u003e1\u003c/code\u003e 或 \u003ccode\u003e0\u003c/code\u003e）：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e-1：我选出的数字比你猜的数字小 \u003ccode\u003epick \u003c num\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e1：我选出的数字比你猜的数字大 \u003ccode\u003epick \u003e num\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e0：我选出的数字和你猜的数字一样。恭喜！你猜对了！\u003ccode\u003epick == num\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e返回我选出的数字。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 10, pick = 6\n\u003cstrong\u003e输出：\u003c/strong\u003e6\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 1, pick = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 2, pick = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 2, pick = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= n \u003c= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= pick \u003c= n\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "猜数字大小"
  },
  "guess-numbers": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "hamming-distance": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "happy-number": {
   "content": "\u003cp\u003eWrite an algorithm to determine if a number \u003ccode\u003en\u003c/code\u003e is happy.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003ehappy number\u003c/strong\u003e is a number defined by the following process:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eStarting with any positive integer, replace the number by the sum of the squares of its digits.\u003c/li\u003e\n\t\u003cli\u003eRepeat the process until the number equals 1 (where it will stay), or it \u003cstrong\u003eloops endlessly in a cycle\u003c/strong\u003e which does not include 1.\u003c/li\u003e\n\t\u003cli\u003eThose numbers for which this process \u003cstrong\u003eends in 1\u003c/strong\u003e are happy.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003ccode\u003etrue\u003c/code\u003e \u003cem\u003eif\u003c/em\u003e \u003ccode\u003en\u003c/code\u003e \u003cem\u003eis a happy number, and\u003c/em\u003e \u003ccode\u003efalse\u003c/code\u003e \u003cem\u003eif not\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 19\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\n1\u003csup\u003e2\u003c/sup\u003e + 9\u003csup\u003e2\u003c/sup\u003e = 82\n8\u003csup\u003e2\u003c/sup\u003e + 2\u003csup\u003e2\u003c/sup\u003e = 68\n6\u003csup\u003e2\u003c/sup\u003e + 8\u003csup\u003e2\u003c/sup\u003e = 100\n1\u003csup\u003e2\u003c/sup\u003e + 0\u003csup\u003e2\u003c/sup\u003e + 0\u003csup\u003e2\u003c/sup\u003e = 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "202",
   "similarQuestions": "[{\"title\": \"Linked List Cycle\", \"titleSlug\": \"linked-list-cycle\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u73af\\u5f62\\u94fe\\u8868\"}, {\"title\": \"Add Digits\", \"titleSlug\": \"add-digits\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5404\\u4f4d\\u76f8\\u52a0\"}, {\"title\": \"Ugly Number\", \"titleSlug\": \"ugly-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e11\\u6570\"}]",
   "topicTags": [
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e编写一个算法来判断一个数 \u003ccode\u003en\u003c/code\u003e 是不是快乐数。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e「快乐数」\u003c/strong\u003e\u0026nbsp;定义为：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\u003c/li\u003e\n\t\u003cli\u003e然后重复这个过程直到这个数变为 1，也可能是 \u003cstrong\u003e无限循环\u003c/strong\u003e 但始终变不到 1。\u003c/li\u003e\n\t\u003cli\u003e如果这个过程 \u003cstrong\u003e结果为\u003c/strong\u003e\u0026nbsp;1，那么这个数就是快乐数。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果 \u003ccode\u003en\u003c/code\u003e 是 \u003cem\u003e快乐数\u003c/em\u003e 就返回 \u003ccode\u003etrue\u003c/code\u003e ；不是，则返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 19\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003cstrong\u003e解释：\n\u003c/strong\u003e1\u003csup\u003e2\u003c/sup\u003e + 9\u003csup\u003e2\u003c/sup\u003e = 82\n8\u003csup\u003e2\u003c/sup\u003e + 2\u003csup\u003e2\u003c/sup\u003e = 68\n6\u003csup\u003e2\u003c/sup\u003e + 8\u003csup\u003e2\u003c/sup\u003e = 100\n1\u003csup\u003e2\u003c/sup\u003e + 0\u003csup\u003e2\u003c/sup\u003e + 0\u003csup\u003e2\u003c/sup\u003e = 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 2\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "快乐数"
  },
  "he-bing-liang-ge-pai-xu-de-lian-biao-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "house-robber": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "house-robber-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "house-robber-iii": {
   "content": "\u003cp\u003eThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called \u003ccode\u003eroot\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eBesides the \u003ccode\u003eroot\u003c/code\u003e, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if \u003cstrong\u003etwo directly-linked houses were broken into on the same night\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of the binary tree, return \u003cem\u003ethe maximum amount of money the thief can rob \u003cstrong\u003ewithout alerting the police\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg\" style=\"width: 277px; height: 293px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,2,3,null,3,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 7\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg\" style=\"width: 357px; height: 293px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,4,5,1,3,null,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 9\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Maximum amount of money the thief can rob = 4 + 5 = 9.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "337",
   "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6253\\u5bb6\\u52ab\\u820d\"}, {\"title\": \"House Robber II\", \"titleSlug\": \"house-robber-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6253\\u5bb6\\u52ab\\u820d II\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e除了\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 \u003cstrong\u003e两个直接相连的房子在同一天晚上被打劫\u003c/strong\u003e ，房屋将自动报警。\u003c/p\u003e\n\n\u003cp\u003e给定二叉树的\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;。返回\u0026nbsp;\u003cem\u003e\u003cstrong\u003e在不触动警报的情况下\u003c/strong\u003e\u0026nbsp;，小偷能够盗取的最高金额\u003c/em\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003eroot = [3,2,3,null,3,null,1]\n\u003cstrong\u003e输出:\u003c/strong\u003e 7 \n\u003cstrong\u003e解释:\u003c/strong\u003e\u0026nbsp;小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003eroot = [3,4,5,1,3,null,1]\n\u003cstrong\u003e输出:\u003c/strong\u003e 9\n\u003cstrong\u003e解释:\u003c/strong\u003e\u0026nbsp;小偷一晚能够盗取的最高金额 4 + 5 = 9\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树的节点数在\u0026nbsp;\u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e 范围内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "打家劫舍 III"
  },
  "iIQa4I": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "image-smoother": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "implement-queue-using-stacks": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "implement-stack-using-queues": {
   "content": "\u003cp\u003eImplement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (\u003ccode\u003epush\u003c/code\u003e, \u003ccode\u003etop\u003c/code\u003e, \u003ccode\u003epop\u003c/code\u003e, and \u003ccode\u003eempty\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eMyStack\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003evoid push(int x)\u003c/code\u003e Pushes element x to the top of the stack.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint pop()\u003c/code\u003e Removes the element on the top of the stack and returns it.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint top()\u003c/code\u003e Returns the element on the top of the stack.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean empty()\u003c/code\u003e Returns \u003ccode\u003etrue\u003c/code\u003e if the stack is empty, \u003ccode\u003efalse\u003c/code\u003e otherwise.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cb\u003eNotes:\u003c/b\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eYou must use \u003cstrong\u003eonly\u003c/strong\u003e standard operations of a queue, which means that only \u003ccode\u003epush to back\u003c/code\u003e, \u003ccode\u003epeek/pop from front\u003c/code\u003e, \u003ccode\u003esize\u003c/code\u003e and \u003ccode\u003eis empty\u003c/code\u003e operations are valid.\u003c/li\u003e\n\t\u003cli\u003eDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue\u0026#39;s standard operations.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;MyStack\u0026quot;, \u0026quot;push\u0026quot;, \u0026quot;push\u0026quot;, \u0026quot;top\u0026quot;, \u0026quot;pop\u0026quot;, \u0026quot;empty\u0026quot;]\n[[], [1], [2], [], [], []]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, null, null, 2, 2, false]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= x \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e100\u003c/code\u003e calls will be made to \u003ccode\u003epush\u003c/code\u003e, \u003ccode\u003epop\u003c/code\u003e, \u003ccode\u003etop\u003c/code\u003e, and \u003ccode\u003eempty\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eAll the calls to \u003ccode\u003epop\u003c/code\u003e and \u003ccode\u003etop\u003c/code\u003e are valid.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow-up:\u003c/strong\u003e Can you implement the stack using only one queue?\u003c/p\u003e\n",
   "hints": [],
   "questionId": "225",
   "similarQuestions": "[{\"title\": \"Implement Queue using Stacks\", \"titleSlug\": \"implement-queue-using-stacks\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u7528\\u6808\\u5b9e\\u73b0\\u961f\\u5217\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Queue",
     "slug": "queue",
     "translatedName": "队列"
    }
   ],
   "translatedContent": "\u003cp\u003e请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（\u003ccode\u003epush\u003c/code\u003e、\u003ccode\u003etop\u003c/code\u003e、\u003ccode\u003epop\u003c/code\u003e 和 \u003ccode\u003eempty\u003c/code\u003e）。\u003c/p\u003e\n\n\u003cp\u003e实现 \u003ccode\u003eMyStack\u003c/code\u003e 类：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003evoid push(int x)\u003c/code\u003e 将元素 x 压入栈顶。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint pop()\u003c/code\u003e 移除并返回栈顶元素。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint top()\u003c/code\u003e 返回栈顶元素。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean empty()\u003c/code\u003e 如果栈是空的，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e你只能使用队列的基本操作 —— 也就是\u0026nbsp;\u003ccode\u003epush to back\u003c/code\u003e、\u003ccode\u003epeek/pop from front\u003c/code\u003e、\u003ccode\u003esize\u003c/code\u003e 和\u0026nbsp;\u003ccode\u003eis empty\u003c/code\u003e\u0026nbsp;这些操作。\u003c/li\u003e\n\t\u003cli\u003e你所使用的语言也许不支持队列。\u0026nbsp;你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列\u0026nbsp;, 只要是标准的队列操作即可。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n\u003cstrong\u003e输出：\u003c/strong\u003e\n[null, null, null, 2, 2, false]\n\n\u003cstrong\u003e解释：\u003c/strong\u003e\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // 返回 2\nmyStack.pop(); // 返回 2\nmyStack.empty(); // 返回 False\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= x \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e最多调用\u003ccode\u003e100\u003c/code\u003e 次 \u003ccode\u003epush\u003c/code\u003e、\u003ccode\u003epop\u003c/code\u003e、\u003ccode\u003etop\u003c/code\u003e 和 \u003ccode\u003eempty\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e每次调用 \u003ccode\u003epop\u003c/code\u003e 和 \u003ccode\u003etop\u003c/code\u003e 都保证栈不为空\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你能否仅用一个队列来实现栈。\u003c/p\u003e\n",
   "translatedTitle": "用队列实现栈"
  },
  "implement-strstr": {
   "content": "\u003cp\u003eImplement \u003ca href=\"http://www.cplusplus.com/reference/cstring/strstr/\" target=\"_blank\"\u003estrStr()\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eGiven two strings \u003ccode\u003eneedle\u003c/code\u003e and \u003ccode\u003ehaystack\u003c/code\u003e, return the index of the first occurrence of \u003ccode\u003eneedle\u003c/code\u003e in \u003ccode\u003ehaystack\u003c/code\u003e, or \u003ccode\u003e-1\u003c/code\u003e if \u003ccode\u003eneedle\u003c/code\u003e is not part of \u003ccode\u003ehaystack\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eClarification:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eWhat should we return when \u003ccode\u003eneedle\u003c/code\u003e is an empty string? This is a great question to ask during an interview.\u003c/p\u003e\n\n\u003cp\u003eFor the purpose of this problem, we will return 0 when \u003ccode\u003eneedle\u003c/code\u003e is an empty string. This is consistent to C\u0026#39;s \u003ca href=\"http://www.cplusplus.com/reference/cstring/strstr/\" target=\"_blank\"\u003estrstr()\u003c/a\u003e and Java\u0026#39;s \u003ca href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)\" target=\"_blank\"\u003eindexOf()\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e haystack = \u0026quot;hello\u0026quot;, needle = \u0026quot;ll\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e haystack = \u0026quot;aaaaa\u0026quot;, needle = \u0026quot;bba\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= haystack.length, needle.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ehaystack\u003c/code\u003e and \u003ccode\u003eneedle\u003c/code\u003e consist of only lowercase English characters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "28",
   "similarQuestions": "[{\"title\": \"Shortest Palindrome\", \"titleSlug\": \"shortest-palindrome\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6700\\u77ed\\u56de\\u6587\\u4e32\"}, {\"title\": \"Repeated Substring Pattern\", \"titleSlug\": \"repeated-substring-pattern\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u91cd\\u590d\\u7684\\u5b50\\u5b57\\u7b26\\u4e32\"}]",
   "topicTags": [
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "String Matching",
     "slug": "string-matching",
     "translatedName": "字符串匹配"
    }
   ],
   "translatedContent": "\u003cp\u003e实现\u0026nbsp;\u003ca href=\"https://baike.baidu.com/item/strstr/811469\" target=\"_blank\"\u003estrStr()\u003c/a\u003e\u0026nbsp;函数。\u003c/p\u003e\n\n\u003cp\u003e给你两个字符串\u0026nbsp;\u003ccode\u003ehaystack\u003c/code\u003e 和 \u003ccode\u003eneedle\u003c/code\u003e ，请你在 \u003ccode\u003ehaystack\u003c/code\u003e 字符串中找出 \u003ccode\u003eneedle\u003c/code\u003e 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回\u0026nbsp; \u003ccode\u003e-1\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e当\u0026nbsp;\u003ccode\u003eneedle\u003c/code\u003e\u0026nbsp;是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\u003c/p\u003e\n\n\u003cp\u003e对于本题而言，当\u0026nbsp;\u003ccode\u003eneedle\u003c/code\u003e\u0026nbsp;是空字符串时我们应当返回 0 。这与 C 语言的\u0026nbsp;\u003ca href=\"https://baike.baidu.com/item/strstr/811469\" target=\"_blank\"\u003estrstr()\u003c/a\u003e\u0026nbsp;以及 Java 的\u0026nbsp;\u003ca href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)\" target=\"_blank\"\u003eindexOf()\u003c/a\u003e\u0026nbsp;定义相符。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehaystack = \"hello\", needle = \"ll\"\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehaystack = \"aaaaa\", needle = \"bba\"\n\u003cstrong\u003e输出：\u003c/strong\u003e-1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehaystack = \"\", needle = \"\"\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= haystack.length, needle.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ehaystack\u003c/code\u003e 和 \u003ccode\u003eneedle\u003c/code\u003e 仅由小写英文字符组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "实现 strStr()"
  },
  "implement-trie-prefix-tree": {
   "content": "\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\" target=\"_blank\"\u003e\u003cstrong\u003etrie\u003c/strong\u003e\u003c/a\u003e (pronounced as \u0026quot;try\u0026quot;) or \u003cstrong\u003eprefix tree\u003c/strong\u003e is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\u003c/p\u003e\n\n\u003cp\u003eImplement the Trie class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eTrie()\u003c/code\u003e Initializes the trie object.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid insert(String word)\u003c/code\u003e Inserts the string \u003ccode\u003eword\u003c/code\u003e into the trie.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean search(String word)\u003c/code\u003e Returns \u003ccode\u003etrue\u003c/code\u003e if the string \u003ccode\u003eword\u003c/code\u003e is in the trie (i.e., was inserted before), and \u003ccode\u003efalse\u003c/code\u003e otherwise.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean startsWith(String prefix)\u003c/code\u003e Returns \u003ccode\u003etrue\u003c/code\u003e if there is a previously inserted string \u003ccode\u003eword\u003c/code\u003e that has the prefix \u003ccode\u003eprefix\u003c/code\u003e, and \u003ccode\u003efalse\u003c/code\u003e otherwise.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;Trie\u0026quot;, \u0026quot;insert\u0026quot;, \u0026quot;search\u0026quot;, \u0026quot;search\u0026quot;, \u0026quot;startsWith\u0026quot;, \u0026quot;insert\u0026quot;, \u0026quot;search\u0026quot;]\n[[], [\u0026quot;apple\u0026quot;], [\u0026quot;apple\u0026quot;], [\u0026quot;app\u0026quot;], [\u0026quot;app\u0026quot;], [\u0026quot;app\u0026quot;], [\u0026quot;app\u0026quot;]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, null, true, false, true, null, true]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nTrie trie = new Trie();\ntrie.insert(\u0026quot;apple\u0026quot;);\ntrie.search(\u0026quot;apple\u0026quot;);   // return True\ntrie.search(\u0026quot;app\u0026quot;);     // return False\ntrie.startsWith(\u0026quot;app\u0026quot;); // return True\ntrie.insert(\u0026quot;app\u0026quot;);\ntrie.search(\u0026quot;app\u0026quot;);     // return True\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= word.length, prefix.length \u0026lt;= 2000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword\u003c/code\u003e and \u003ccode\u003eprefix\u003c/code\u003e consist only of lowercase English letters.\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls \u003cstrong\u003ein total\u003c/strong\u003e will be made to \u003ccode\u003einsert\u003c/code\u003e, \u003ccode\u003esearch\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "208",
   "similarQuestions": "[{\"title\": \"Design Add and Search Words Data Structure\", \"titleSlug\": \"design-add-and-search-words-data-structure\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6dfb\\u52a0\\u4e0e\\u641c\\u7d22\\u5355\\u8bcd - \\u6570\\u636e\\u7ed3\\u6784\\u8bbe\\u8ba1\"}, {\"title\": \"Design Search Autocomplete System\", \"titleSlug\": \"design-search-autocomplete-system\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u8bbe\\u8ba1\\u641c\\u7d22\\u81ea\\u52a8\\u8865\\u5168\\u7cfb\\u7edf\"}, {\"title\": \"Replace Words\", \"titleSlug\": \"replace-words\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5355\\u8bcd\\u66ff\\u6362\"}, {\"title\": \"Implement Magic Dictionary\", \"titleSlug\": \"implement-magic-dictionary\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b9e\\u73b0\\u4e00\\u4e2a\\u9b54\\u6cd5\\u5b57\\u5178\"}]",
   "topicTags": [
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Trie",
     "slug": "trie",
     "translatedName": "字典树"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://baike.baidu.com/item/字典树/9825209?fr=aladdin\" target=\"_blank\"\u003eTrie\u003c/a\u003e\u003c/strong\u003e（发音类似 \"try\"）或者说 \u003cstrong\u003e前缀树\u003c/strong\u003e 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\u003c/p\u003e\n\n\u003cp\u003e请你实现 Trie 类：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eTrie()\u003c/code\u003e 初始化前缀树对象。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid insert(String word)\u003c/code\u003e 向前缀树中插入字符串 \u003ccode\u003eword\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean search(String word)\u003c/code\u003e 如果字符串 \u003ccode\u003eword\u003c/code\u003e 在前缀树中，返回 \u003ccode\u003etrue\u003c/code\u003e（即，在检索之前已经插入）；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboolean startsWith(String prefix)\u003c/code\u003e 如果之前已经插入的字符串 \u003ccode\u003eword\u003c/code\u003e 的前缀之一为 \u003ccode\u003eprefix\u003c/code\u003e ，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入\u003c/strong\u003e\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\n\u003cstrong\u003e输出\u003c/strong\u003e\n[null, null, true, false, true, null, true]\n\n\u003cstrong\u003e解释\u003c/strong\u003e\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 True\ntrie.search(\"app\");     // 返回 False\ntrie.startsWith(\"app\"); // 返回 True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // 返回 True\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= word.length, prefix.length \u003c= 2000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eword\u003c/code\u003e 和 \u003ccode\u003eprefix\u003c/code\u003e 仅由小写英文字母组成\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003einsert\u003c/code\u003e、\u003ccode\u003esearch\u003c/code\u003e 和 \u003ccode\u003estartsWith\u003c/code\u003e 调用次数 \u003cstrong\u003e总计\u003c/strong\u003e 不超过 \u003ccode\u003e3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e 次\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "实现 Trie (前缀树)"
  },
  "insert-into-a-sorted-circular-linked-list": {
   "content": "\u003cp\u003eGiven a Circular Linked List node, which is sorted in ascending order, write a function to insert a value \u003ccode\u003einsertVal\u003c/code\u003e into the list such that it remains a sorted circular list. The given node can be a reference to any single node in the list and may not necessarily be the smallest value in the circular list.\u003c/p\u003e\n\n\u003cp\u003eIf there are multiple suitable places for insertion, you may choose any place to insert the new value. After the insertion, the circular list should remain sorted.\u003c/p\u003e\n\n\u003cp\u003eIf the list is empty (i.e., the given node is \u003ccode\u003enull\u003c/code\u003e), you should create a new single circular list and return the reference to that single node. Otherwise, you should return the originally given node.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg\" style=\"width: 250px; height: 149px;\" /\u003e\u003cbr /\u003e\n\u0026nbsp;\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [3,4,1], insertVal = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3,4,1,2]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e In the figure above, there is a sorted circular list of three elements. You are given a reference to the node with value 3, and we need to insert 2 into the list. The new node should be inserted between node 1 and node 3. After the insertion, the list should look like this, and we should still return node 3.\n\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg\" style=\"width: 250px; height: 149px;\" /\u003e\n\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [], insertVal = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The list is empty (given head is\u0026nbsp;\u003ccode\u003enull\u003c/code\u003e). We create a new single circular list and return the reference to that single node.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1], insertVal = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is in the range \u003ccode\u003e[0, 5 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e6\u003c/sup\u003e \u0026lt;= Node.val, insertVal \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "850",
   "similarQuestions": "[{\"title\": \"Insertion Sort List\", \"titleSlug\": \"insertion-sort-list\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5bf9\\u94fe\\u8868\\u8fdb\\u884c\\u63d2\\u5165\\u6392\\u5e8f\"}]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    }
   ],
   "translatedContent": "\u003cp\u003e给定\u003cstrong\u003e循环单调非递减列表\u003c/strong\u003e中的一个点，写一个函数向这个列表中插入一个新元素\u0026nbsp;\u003ccode\u003einsertVal\u003c/code\u003e ，使这个列表仍然是循环非降序的。\u003c/p\u003e\n\n\u003cp\u003e给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。\u003c/p\u003e\n\n\u003cp\u003e如果有多个满足条件的插入位置，你可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。\u003c/p\u003e\n\n\u003cp\u003e如果列表为空（给定的节点是 \u003ccode\u003enull\u003c/code\u003e），你需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg\" style=\"height: 149px; width: 250px;\" /\u003e\u003cbr /\u003e\n\u0026nbsp;\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [3,4,1], insertVal = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e[3,4,1,2]\n\u003cstrong\u003e解释：\u003c/strong\u003e在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。\n\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg\" style=\"height: 149px; width: 250px;\" /\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [], insertVal = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[1]\n\u003cstrong\u003e解释：\u003c/strong\u003e列表为空（给定的节点是 \u003ccode\u003enull\u003c/code\u003e），创建一个循环有序列表并返回这个节点。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1], insertVal = 0\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Number of Nodes \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e6\u003c/sup\u003e \u0026lt;= Node.val, insertVal \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "循环有序列表的插入"
  },
  "insertion-sort-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "integer-break": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "intersection-of-two-arrays": {
   "content": "\u003cp\u003eGiven two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, return \u003cem\u003ean array of their intersection\u003c/em\u003e. Each element in the result must be \u003cstrong\u003eunique\u003c/strong\u003e and you may return the result in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums1 = [1,2,2,1], nums2 = [2,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [9,4]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e [4,9] is also accepted.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "349",
   "similarQuestions": "[{\"title\": \"Intersection of Two Arrays II\", \"titleSlug\": \"intersection-of-two-arrays-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e24\\u4e2a\\u6570\\u7ec4\\u7684\\u4ea4\\u96c6 II\"}, {\"title\": \"Intersection of Three Sorted Arrays\", \"titleSlug\": \"intersection-of-three-sorted-arrays\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e09\\u4e2a\\u6709\\u5e8f\\u6570\\u7ec4\\u7684\\u4ea4\\u96c6\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个数组\u0026nbsp;\u003ccode\u003enums1\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003enums2\u003c/code\u003e ，返回 \u003cem\u003e它们的交集\u003c/em\u003e\u0026nbsp;。输出结果中的每个元素一定是 \u003cstrong\u003e唯一\u003c/strong\u003e 的。我们可以 \u003cstrong\u003e不考虑输出结果的顺序\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums1 = [1,2,2,1], nums2 = [2,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e[2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e[9,4]\n\u003cstrong\u003e解释：\u003c/strong\u003e[4,9] 也是可通过的\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "两个数组的交集"
  },
  "intersection-of-two-arrays-ii": {
   "content": "\u003cp\u003eGiven two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, return \u003cem\u003ean array of their intersection\u003c/em\u003e. Each element in the result must appear as many times as it shows in both arrays and you may return the result in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums1 = [1,2,2,1], nums2 = [2,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2,2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [4,9]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e [9,4] is also accepted.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eWhat if the given array is already sorted? How would you optimize your algorithm?\u003c/li\u003e\n\t\u003cli\u003eWhat if \u003ccode\u003enums1\u003c/code\u003e\u0026#39;s size is small compared to \u003ccode\u003enums2\u003c/code\u003e\u0026#39;s size? Which algorithm is better?\u003c/li\u003e\n\t\u003cli\u003eWhat if elements of \u003ccode\u003enums2\u003c/code\u003e are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "350",
   "similarQuestions": "[{\"title\": \"Intersection of Two Arrays\", \"titleSlug\": \"intersection-of-two-arrays\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e24\\u4e2a\\u6570\\u7ec4\\u7684\\u4ea4\\u96c6\"}, {\"title\": \"Find Common Characters\", \"titleSlug\": \"find-common-characters\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u67e5\\u627e\\u5171\\u7528\\u5b57\\u7b26\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给你两个整数数组\u0026nbsp;\u003ccode\u003enums1\u003c/code\u003e 和 \u003ccode\u003enums2\u003c/code\u003e ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums1 = [1,2,2,1], nums2 = [2,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e[2,2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e[4,9]\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e进阶\u003c/strong\u003e：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e如果给定的数组已经排好序呢？你将如何优化你的算法？\u003c/li\u003e\n\t\u003cli\u003e如果\u0026nbsp;\u003ccode\u003enums1\u003c/code\u003e\u003cem\u003e\u0026nbsp;\u003c/em\u003e的大小比\u0026nbsp;\u003ccode\u003enums2\u003c/code\u003e 小，哪种方法更优？\u003c/li\u003e\n\t\u003cli\u003e如果\u0026nbsp;\u003ccode\u003enums2\u003c/code\u003e\u003cem\u003e\u0026nbsp;\u003c/em\u003e的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "两个数组的交集 II"
  },
  "intersection-of-two-linked-lists": {
   "content": "\u003cp\u003eGiven the heads of two singly linked-lists \u003ccode\u003eheadA\u003c/code\u003e and \u003ccode\u003eheadB\u003c/code\u003e, return \u003cem\u003ethe node at which the two lists intersect\u003c/em\u003e. If the two linked lists have no intersection at all, return \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFor example, the following two linked lists begin to intersect at node \u003ccode\u003ec1\u003c/code\u003e:\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_statement.png\" style=\"width: 500px; height: 162px;\" /\u003e\n\u003cp\u003eThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that the linked lists must \u003cstrong\u003eretain their original structure\u003c/strong\u003e after the function returns.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCustom Judge:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe inputs to the \u003cstrong\u003ejudge\u003c/strong\u003e are given as follows (your program is \u003cstrong\u003enot\u003c/strong\u003e given these inputs):\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eintersectVal\u003c/code\u003e - The value of the node where the intersection occurs. This is \u003ccode\u003e0\u003c/code\u003e if there is no intersected node.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003elistA\u003c/code\u003e - The first linked list.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003elistB\u003c/code\u003e - The second linked list.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eskipA\u003c/code\u003e - The number of nodes to skip ahead in \u003ccode\u003elistA\u003c/code\u003e (starting from the head) to get to the intersected node.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eskipB\u003c/code\u003e - The number of nodes to skip ahead in \u003ccode\u003elistB\u003c/code\u003e (starting from the head) to get to the intersected node.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe judge will then create the linked structure based on these inputs and pass the two heads, \u003ccode\u003eheadA\u003c/code\u003e and \u003ccode\u003eheadB\u003c/code\u003e\u0026nbsp;to your program. If you correctly return the intersected node, then your solution will be \u003cstrong\u003eaccepted\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png\" style=\"width: 500px; height: 162px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e Intersected at \u0026#39;8\u0026#39;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The intersected node\u0026#39;s value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png\" style=\"width: 500px; height: 194px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e Intersected at \u0026#39;2\u0026#39;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The intersected node\u0026#39;s value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png\" style=\"width: 300px; height: 189px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e No intersection\n\u003cstrong\u003eExplanation:\u003c/strong\u003e From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes of \u003ccode\u003elistA\u003c/code\u003e is in the \u003ccode\u003em\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe number of nodes of \u003ccode\u003elistB\u003c/code\u003e is in the \u003ccode\u003en\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= skipA \u0026lt;\u0026nbsp;m\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= skipB \u0026lt;\u0026nbsp;n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eintersectVal\u003c/code\u003e is \u003ccode\u003e0\u003c/code\u003e if \u003ccode\u003elistA\u003c/code\u003e and \u003ccode\u003elistB\u003c/code\u003e do not intersect.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eintersectVal == listA[skipA] == listB[skipB]\u003c/code\u003e if \u003ccode\u003elistA\u003c/code\u003e and \u003ccode\u003elistB\u003c/code\u003e intersect.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you write a solution that runs in \u003ccode\u003eO(m + n)\u003c/code\u003e time and use only \u003ccode\u003eO(1)\u003c/code\u003e memory?",
   "hints": [],
   "questionId": "160",
   "similarQuestions": "[{\"title\": \"Minimum Index Sum of Two Lists\", \"titleSlug\": \"minimum-index-sum-of-two-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e24\\u4e2a\\u5217\\u8868\\u7684\\u6700\\u5c0f\\u7d22\\u5f15\\u603b\\u548c\"}]",
   "topicTags": [
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你两个单链表的头节点\u0026nbsp;\u003ccode\u003eheadA\u003c/code\u003e 和 \u003ccode\u003eheadB\u003c/code\u003e ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 \u003ccode\u003enull\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e图示两个链表在节点 \u003ccode\u003ec1\u003c/code\u003e 开始相交\u003cstrong\u003e：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e题目数据 \u003cstrong\u003e保证\u003c/strong\u003e 整个链式结构中不存在环。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e，函数返回结果后，链表必须 \u003cstrong\u003e保持其原始结构\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e自定义评测：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e评测系统\u003c/strong\u003e 的输入如下（你设计的程序 \u003cstrong\u003e不适用\u003c/strong\u003e 此输入）：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eintersectVal\u003c/code\u003e - 相交的起始节点的值。如果不存在相交节点，这一值为 \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003elistA\u003c/code\u003e - 第一个链表\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003elistB\u003c/code\u003e - 第二个链表\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eskipA\u003c/code\u003e - 在 \u003ccode\u003elistA\u003c/code\u003e 中（从头节点开始）跳到交叉节点的节点数\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eskipB\u003c/code\u003e - 在 \u003ccode\u003elistB\u003c/code\u003e 中（从头节点开始）跳到交叉节点的节点数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e评测系统将根据这些输入创建链式数据结构，并将两个头节点 \u003ccode\u003eheadA\u003c/code\u003e 和 \u003ccode\u003eheadB\u003c/code\u003e 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 \u003cstrong\u003e视作正确答案\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png\" style=\"height: 130px; width: 400px;\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eintersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n\u003cstrong\u003e输出：\u003c/strong\u003eIntersected at '8'\n\u003cstrong\u003e解释：\u003c/strong\u003e相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png\" style=\"height: 136px; width: 350px;\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eintersectVal\u0026nbsp;= 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n\u003cstrong\u003e输出：\u003c/strong\u003eIntersected at '2'\n\u003cstrong\u003e解释：\u003c/strong\u003e相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eintersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n\u003cstrong\u003e输出：\u003c/strong\u003enull\n\u003cstrong\u003e解释：\u003c/strong\u003e从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003elistA\u003c/code\u003e 中节点数目为 \u003ccode\u003em\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003elistB\u003c/code\u003e 中节点数目为 \u003ccode\u003en\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= skipA \u0026lt;= m\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= skipB \u0026lt;= n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e如果 \u003ccode\u003elistA\u003c/code\u003e 和 \u003ccode\u003elistB\u003c/code\u003e 没有交点，\u003ccode\u003eintersectVal\u003c/code\u003e 为 \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e如果 \u003ccode\u003elistA\u003c/code\u003e 和 \u003ccode\u003elistB\u003c/code\u003e 有交点，\u003ccode\u003eintersectVal == listA[skipA] == listB[skipB]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你能否设计一个时间复杂度 \u003ccode\u003eO(m + n)\u003c/code\u003e 、仅用 \u003ccode\u003eO(1)\u003c/code\u003e 内存的解决方案？\u003c/p\u003e\n",
   "translatedTitle": "相交链表"
  },
  "invert-binary-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "is-subsequence": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "is-unique-lcci": {
   "content": "\u003cp\u003eImplement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\n\u003cstrong\u003eInput: \u003c/strong\u003e\u003ccode\u003es\u003c/code\u003e = \u0026quot;leetcode\u0026quot;\r\n\u003cstrong\u003eOutput: \u003c/strong\u003efalse\r\n\u003c/pre\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\n\u003cstrong\u003eInput: \u003c/strong\u003e\u003ccode\u003es\u003c/code\u003e = \u0026quot;abc\u0026quot;\r\n\u003cstrong\u003eOutput: \u003c/strong\u003etrue\r\n\u003c/pre\u003e\r\n\r\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cul\u003e\r\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= len(s) \u0026lt;= 100 \u003c/code\u003e\u003c/li\u003e\r\n\u003c/ul\u003e\r\n",
   "hints": [
    "试试散列表",
    "位向量有用吗？",
    "你能用O(NlogN)的时间复杂度解决它吗？这样的解法会是什么样呢？"
   ],
   "questionId": "100158",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e实现一个算法，确定一个字符串 \u003ccode\u003es\u003c/code\u003e 的所有字符是否全都不同。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003es\u003c/code\u003e = \u0026quot;leetcode\u0026quot;\n\u003cstrong\u003e输出:\u003c/strong\u003e false \n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003es\u003c/code\u003e = \u0026quot;abc\u0026quot;\n\u003cstrong\u003e输出:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e限制：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= len(s) \u003c= 100 \u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e如果你不使用额外的数据结构，会很加分。\u003c/li\u003e\n\u003c/ul\u003e\n    ",
   "translatedTitle": "判定字符是否唯一"
  },
  "isomorphic-strings": {
   "content": "\u003cp\u003eGiven two strings \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e, \u003cem\u003edetermine if they are isomorphic\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eTwo strings \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e are isomorphic if the characters in \u003ccode\u003es\u003c/code\u003e can be replaced to get \u003ccode\u003et\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"egg\", t = \"add\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"foo\", t = \"bar\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"paper\", t = \"title\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003et.length == s.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e consist of any valid ascii character.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "205",
   "similarQuestions": "[{\"title\": \"Word Pattern\", \"titleSlug\": \"word-pattern\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5355\\u8bcd\\u89c4\\u5f8b\"}]",
   "topicTags": [
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个字符串\u0026nbsp;\u003ccode\u003es\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003et\u003c/code\u003e\u0026nbsp;，判断它们是否是同构的。\u003c/p\u003e\n\n\u003cp\u003e如果\u0026nbsp;\u003ccode\u003es\u003c/code\u003e\u0026nbsp;中的字符可以按某种映射关系替换得到\u0026nbsp;\u003ccode\u003et\u003c/code\u003e\u0026nbsp;，那么这两个字符串是同构的。\u003c/p\u003e\n\n\u003cp\u003e每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \u003ccode\u003e\"egg\", \u003c/code\u003et = \u003ccode\u003e\"add\"\u003c/code\u003e\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \u003ccode\u003e\"foo\", \u003c/code\u003et = \u003ccode\u003e\"bar\"\u003c/code\u003e\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \u003ccode\u003e\"paper\", \u003c/code\u003et = \u003ccode\u003e\"title\"\u003c/code\u003e\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003et.length == s.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003et\u003c/code\u003e\u0026nbsp;由任意有效的 ASCII 字符组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "同构字符串"
  },
  "jBjn9C": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "jump-game": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "kill-process": {
   "content": "\u003cp\u003eYou have \u003ccode\u003en\u003c/code\u003e processes forming a rooted tree structure. You are given two integer arrays \u003ccode\u003epid\u003c/code\u003e and \u003ccode\u003eppid\u003c/code\u003e, where \u003ccode\u003epid[i]\u003c/code\u003e is the ID of the \u003ccode\u003ei\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e process and \u003ccode\u003eppid[i]\u003c/code\u003e is the ID of the \u003ccode\u003ei\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e process\u0026#39;s parent process.\u003c/p\u003e\n\n\u003cp\u003eEach process has only \u003cstrong\u003eone parent process\u003c/strong\u003e but may have multiple children processes. Only one process has \u003ccode\u003eppid[i] = 0\u003c/code\u003e, which means this process has \u003cstrong\u003eno parent process\u003c/strong\u003e (the root of the tree).\u003c/p\u003e\n\n\u003cp\u003eWhen a process is \u003cstrong\u003ekilled\u003c/strong\u003e, all of its children processes will also be killed.\u003c/p\u003e\n\n\u003cp\u003eGiven an integer \u003ccode\u003ekill\u003c/code\u003e representing the ID of a process you want to kill, return \u003cem\u003ea list of the IDs of the processes that will be killed. You may return the answer in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/24/ptree.jpg\" style=\"width: 207px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e pid = [1,3,10,5], ppid = [3,0,5,3], kill = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e [5,10]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\u0026nbsp;The processes colored in red are the processes that should be killed.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e pid = [1], ppid = [0], kill = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003en == pid.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == ppid.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= pid[i] \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= ppid[i] \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eOnly one process has no parent.\u003c/li\u003e\n\t\u003cli\u003eAll the values of \u003ccode\u003epid\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ekill\u003c/code\u003e is \u003cstrong\u003eguaranteed\u003c/strong\u003e to be in \u003ccode\u003epid\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "582",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    }
   ],
   "translatedContent": "\u003cp\u003e系统中存在 \u003ccode\u003en\u003c/code\u003e 个进程，形成一个有根树结构。给你两个整数数组 \u003ccode\u003epid\u003c/code\u003e 和 \u003ccode\u003eppid\u003c/code\u003e ，其中 \u003ccode\u003epid[i]\u003c/code\u003e 是第 \u003ccode\u003ei\u003c/code\u003e 个进程的 ID ，\u003ccode\u003eppid[i]\u003c/code\u003e 是第 \u003ccode\u003ei\u003c/code\u003e 个进程的父进程 ID 。\u003c/p\u003e\n\n\u003cp\u003e每一个进程只有 \u003cstrong\u003e一个父进程\u003c/strong\u003e ，但是可能会有 \u003cstrong\u003e一个或者多个子进程\u003c/strong\u003e 。只有一个进程的 \u003ccode\u003eppid[i] = 0\u003c/code\u003e ，意味着这个进程 \u003cstrong\u003e没有父进程\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e当一个进程 \u003cstrong\u003e被杀掉\u003c/strong\u003e 的时候，它所有的子进程和后代进程都要被杀掉。\u003c/p\u003e\n\n\u003cp\u003e给你一个整数 \u003ccode\u003ekill\u003c/code\u003e 表示要杀掉​​进程的 ID ，返回杀掉该进程后的所有进程 ID 的列表。可以按 \u003cstrong\u003e任意顺序\u003c/strong\u003e 返回答案。\u003c/p\u003e\n \n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/24/ptree.jpg\" style=\"width: 207px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003epid = [1,3,10,5], ppid = [3,0,5,3], kill = 5\n\u003cstrong\u003e输出：\u003c/strong\u003e[5,10]\n\u003cstrong\u003e解释：\u003c/strong\u003e涂为红色的进程是应该被杀掉的进程。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003epid = [1], ppid = [0], kill = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[1]\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003en == pid.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == ppid.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= n \u003c= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= pid[i] \u003c= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= ppid[i] \u003c= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e仅有一个进程没有父进程\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epid\u003c/code\u003e 中的所有值 \u003cstrong\u003e互不相同\u003c/strong\u003e\u003c/li\u003e\n\t\u003cli\u003e题目数据保证 \u003ccode\u003ekill\u003c/code\u003e 在 \u003ccode\u003epid\u003c/code\u003e 中\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "杀掉进程"
  },
  "kth-largest-element-in-a-stream": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "kth-largest-element-in-an-array": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e and an integer \u003ccode\u003ek\u003c/code\u003e, return \u003cem\u003ethe\u003c/em\u003e \u003ccode\u003ek\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e \u003cem\u003elargest element in the array\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote that it is the \u003ccode\u003ek\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e largest element in the sorted order, not the \u003ccode\u003ek\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e distinct element.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [3,2,1,5,6,4], k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [3,2,3,1,2,4,5,5,6], k = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "215",
   "similarQuestions": "[{\"title\": \"Wiggle Sort II\", \"titleSlug\": \"wiggle-sort-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6446\\u52a8\\u6392\\u5e8f II\"}, {\"title\": \"Top K Frequent Elements\", \"titleSlug\": \"top-k-frequent-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u524d K \\u4e2a\\u9ad8\\u9891\\u5143\\u7d20\"}, {\"title\": \"Third Maximum Number\", \"titleSlug\": \"third-maximum-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u7b2c\\u4e09\\u5927\\u7684\\u6570\"}, {\"title\": \"Kth Largest Element in a Stream\", \"titleSlug\": \"kth-largest-element-in-a-stream\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6570\\u636e\\u6d41\\u4e2d\\u7684\\u7b2c K \\u5927\\u5143\\u7d20\"}, {\"title\": \"K Closest Points to Origin\", \"titleSlug\": \"k-closest-points-to-origin\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u63a5\\u8fd1\\u539f\\u70b9\\u7684 K \\u4e2a\\u70b9\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Divide and Conquer",
     "slug": "divide-and-conquer",
     "translatedName": "分治"
    },
    {
     "name": "Quickselect",
     "slug": "quickselect",
     "translatedName": "快速选择"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    },
    {
     "name": "Heap (Priority Queue)",
     "slug": "heap-priority-queue",
     "translatedName": "堆（优先队列）"
    }
   ],
   "translatedContent": "\u003cp\u003e给定整数数组 \u003ccode\u003enums\u003c/code\u003e 和整数 \u003ccode\u003ek\u003c/code\u003e，请返回数组中第 \u003ccode\u003e\u003cstrong\u003ek\u003c/strong\u003e\u003c/code\u003e 个最大的元素。\u003c/p\u003e\n\n\u003cp\u003e请注意，你需要找的是数组排序后的第 \u003ccode\u003ek\u003c/code\u003e 个最大的元素，而不是第 \u003ccode\u003ek\u003c/code\u003e 个不同的元素。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003e[3,2,1,5,6,4] 和\u003c/code\u003e k = 2\n\u003cstrong\u003e输出:\u003c/strong\u003e 5\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003e[3,2,3,1,2,4,5,5,6] 和\u003c/code\u003e k = 4\n\u003cstrong\u003e输出:\u003c/strong\u003e 4\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示： \u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= k \u003c= nums.length \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u003c= nums[i] \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "数组中的第K个最大元素"
  },
  "kth-node-from-end-of-list-lcci": {
   "content": "\u003cp\u003eImplement an algorithm to find the kth to last element of a singly linked list.\u0026nbsp;Return the value of the element.\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eNote: \u003c/strong\u003eThis problem is slightly different from the original one in the book.\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eExample: \u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\n\u003cstrong\u003eInput: \u003c/strong\u003e 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 和 \u003cem\u003ek\u003c/em\u003e = 2\r\n\u003cstrong\u003eOutput:  \u003c/strong\u003e4\u003c/pre\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eNote: \u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cp\u003ek is always valid.\u003c/p\u003e\r\n",
   "hints": [
    "如果你知道链表大小，会怎么样？找到最后第k个元素和找到第x个元素有何区别？",
    "如果你不知道链表的大小，你能计算它吗？这将如何影响运行时间？",
    "尝试用递归法实现。如果你能找到(k − 1)到最后一个元素，可以找到第k个元素吗？",
    "你可能会发现返回多个值大有用处。有些语言不直接支持这一点，但基本上使用任何语言都有解决方法。这些解决方法有哪些？",
    "你能通过递归做到吗？想象一下，如果有两个指针指向相邻节点，它们通过链表以相同的速度移动。当一个到达链表的结尾时，另一个在哪里？"
   ],
   "questionId": "1000007",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e本题相对原题稍作改动\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003e 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 和 \u003cem\u003ek\u003c/em\u003e = 2\n\u003cstrong\u003e输出： \u003c/strong\u003e4\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e给定的 \u003cem\u003ek\u003c/em\u003e\u0026nbsp;保证是有效的。\u003c/p\u003e\n",
   "translatedTitle": "返回倒数第 k 个节点"
  },
  "kth-smallest-element-in-a-bst": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary search tree, and an integer \u003ccode\u003ek\u003c/code\u003e, return \u003cem\u003ethe\u003c/em\u003e \u003ccode\u003ek\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e \u003cem\u003esmallest value (\u003cstrong\u003e1-indexed\u003c/strong\u003e) of all the values of the nodes in the tree\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,1,4,null,2], k = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,3,6,2,4,null,null,1], k = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is \u003ccode\u003en\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= n \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?\u003c/p\u003e\n",
   "hints": [
    "Try to utilize the property of a BST.",
    "Try in-order traversal. (Credits to @chan13)",
    "What if you could modify the BST node's structure?",
    "The optimal runtime complexity is O(height of BST)."
   ],
   "questionId": "230",
   "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u4e2d\\u5e8f\\u904d\\u5386\"}, {\"title\": \"Second Minimum Node In a Binary Tree\", \"titleSlug\": \"second-minimum-node-in-a-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u4e2d\\u7b2c\\u4e8c\\u5c0f\\u7684\\u8282\\u70b9\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个二叉搜索树的根节点 \u003ccode\u003eroot\u003c/code\u003e ，和一个整数 \u003ccode\u003ek\u003c/code\u003e ，请你设计一个算法查找其中第 \u003ccode\u003ek\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003e个最小元素（从 1 开始计数）。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [3,1,4,null,2], k = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [5,3,6,2,4,null,null,1], k = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中的节点数为 \u003ccode\u003en\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= k \u003c= n \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= Node.val \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 \u003ccode\u003ek\u003c/code\u003e 小的值，你将如何优化算法？\u003c/p\u003e\n",
   "translatedTitle": "二叉搜索树中第K小的元素"
  },
  "largest-number": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "largest-rectangle-in-histogram": {
   "content": "\u003cp\u003eGiven an array of integers \u003ccode\u003eheights\u003c/code\u003e representing the histogram\u0026#39;s bar height where the width of each bar is \u003ccode\u003e1\u003c/code\u003e, return \u003cem\u003ethe area of the largest rectangle in the histogram\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" style=\"width: 522px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e heights = [2,1,5,6,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 10\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" style=\"width: 202px; height: 362px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e heights = [2,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= heights.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= heights[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "84",
   "similarQuestions": "[{\"title\": \"Maximal Rectangle\", \"titleSlug\": \"maximal-rectangle\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6700\\u5927\\u77e9\\u5f62\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Monotonic Stack",
     "slug": "monotonic-stack",
     "translatedName": "单调栈"
    }
   ],
   "translatedContent": "\u003cp\u003e给定 \u003cem\u003en\u003c/em\u003e 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\u003c/p\u003e\n\n\u003cp\u003e求在该柱状图中，能够勾勒出来的矩形的最大面积。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eheights = [2,1,5,6,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e10\n\u003cstrong\u003e解释：\u003c/strong\u003e最大的矩形为图中红色区域，面积为 10\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e heights = [2,4]\n\u003cb\u003e输出：\u003c/b\u003e 4\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= heights.length \u003c=10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= heights[i] \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "柱状图中最大的矩形"
  },
  "lemonade-change": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "length-of-last-word": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "letter-case-permutation": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "letter-combinations-of-a-phone-number": {
   "content": "\u003cp\u003eGiven a string containing digits from \u003ccode\u003e2-9\u003c/code\u003e inclusive, return all possible letter combinations that the number could represent. Return the answer in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png\" style=\"width: 200px; height: 162px;\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e digits = \u0026quot;23\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\u0026quot;ad\u0026quot;,\u0026quot;ae\u0026quot;,\u0026quot;af\u0026quot;,\u0026quot;bd\u0026quot;,\u0026quot;be\u0026quot;,\u0026quot;bf\u0026quot;,\u0026quot;cd\u0026quot;,\u0026quot;ce\u0026quot;,\u0026quot;cf\u0026quot;]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e digits = \u0026quot;\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e digits = \u0026quot;2\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= digits.length \u0026lt;= 4\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003edigits[i]\u003c/code\u003e is a digit in the range \u003ccode\u003e[\u0026#39;2\u0026#39;, \u0026#39;9\u0026#39;]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "17",
   "similarQuestions": "[{\"title\": \"Generate Parentheses\", \"titleSlug\": \"generate-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u62ec\\u53f7\\u751f\\u6210\"}, {\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7ec4\\u5408\\u603b\\u548c\"}, {\"title\": \"Binary Watch\", \"titleSlug\": \"binary-watch\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u8fdb\\u5236\\u624b\\u8868\"}]",
   "topicTags": [
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Backtracking",
     "slug": "backtracking",
     "translatedName": "回溯"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个仅包含数字\u0026nbsp;\u003ccode\u003e2-9\u003c/code\u003e\u0026nbsp;的字符串，返回所有它能表示的字母组合。答案可以按 \u003cstrong\u003e任意顺序\u003c/strong\u003e 返回。\u003c/p\u003e\n\n\u003cp\u003e给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png\" style=\"width: 200px;\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003edigits = \"23\"\n\u003cstrong\u003e输出：\u003c/strong\u003e[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003edigits = \"\"\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003edigits = \"2\"\n\u003cstrong\u003e输出：\u003c/strong\u003e[\"a\",\"b\",\"c\"]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= digits.length \u0026lt;= 4\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003edigits[i]\u003c/code\u003e 是范围 \u003ccode\u003e['2', '9']\u003c/code\u003e 的一个数字。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "电话号码的字母组合"
  },
  "lexicographical-numbers": {
   "content": "\u003cp\u003eGiven an integer \u003ccode\u003en\u003c/code\u003e, return all the numbers in the range \u003ccode\u003e[1, n]\u003c/code\u003e sorted in lexicographical order.\u003c/p\u003e\n\n\u003cp\u003eYou must write an algorithm that runs in\u0026nbsp;\u003ccode\u003eO(n)\u003c/code\u003e\u0026nbsp;time and uses \u003ccode\u003eO(1)\u003c/code\u003e extra space.\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e n = 13\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,10,11,12,13,2,3,4,5,6,7,8,9]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "386",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Trie",
     "slug": "trie",
     "translatedName": "字典树"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数 \u003ccode\u003en\u003c/code\u003e ，按字典序返回范围 \u003ccode\u003e[1, n]\u003c/code\u003e 内所有整数。\u003c/p\u003e\n\n\u003cp\u003e你必须设计一个时间复杂度为 \u003ccode\u003eO(n)\u003c/code\u003e 且使用 \u003ccode\u003eO(1)\u003c/code\u003e 额外空间的算法。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 13\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,10,11,12,13,2,3,4,5,6,7,8,9]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "字典序排数"
  },
  "lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof": {
   "content": "\u003cp\u003eEnglish description is not available for the problem. Please switch to Chinese.\u003c/p\u003e",
   "hints": [],
   "questionId": "100294",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。\u003c/p\u003e\n\n\u003cp\u003e例如，一个链表有 \u003ccode\u003e6\u003c/code\u003e 个节点，从头节点开始，它们的值依次是 \u003ccode\u003e1、2、3、4、5、6\u003c/code\u003e。这个链表的倒数第 \u003ccode\u003e3\u003c/code\u003e 个节点是值为 \u003ccode\u003e4\u003c/code\u003e 的节点。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n给定一个链表: \u003cstrong\u003e1-\u003e2-\u003e3-\u003e4-\u003e5\u003c/strong\u003e, 和 \u003cem\u003ek \u003c/em\u003e\u003cstrong\u003e= 2\u003c/strong\u003e.\n\n返回链表 4\u003cstrong\u003e-\u003e5\u003c/strong\u003e.\u003c/pre\u003e\n",
   "translatedTitle": "链表中倒数第k个节点"
  },
  "lian-xu-zi-shu-zu-de-zui-da-he-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "linked-list-cycle": {
   "content": "\u003cp\u003eGiven \u003ccode\u003ehead\u003c/code\u003e, the head of a linked list, determine if the linked list has a cycle in it.\u003c/p\u003e\n\n\u003cp\u003eThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u0026nbsp;\u003ccode\u003enext\u003c/code\u003e\u0026nbsp;pointer. Internally, \u003ccode\u003epos\u003c/code\u003e\u0026nbsp;is used to denote the index of the node that\u0026nbsp;tail\u0026#39;s\u0026nbsp;\u003ccode\u003enext\u003c/code\u003e\u0026nbsp;pointer is connected to.\u0026nbsp;\u003cstrong\u003eNote that\u0026nbsp;\u003ccode\u003epos\u003c/code\u003e\u0026nbsp;is not passed as a parameter\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn\u0026nbsp;\u003ccode\u003etrue\u003c/code\u003e\u003cem\u003e if there is a cycle in the linked list\u003c/em\u003e. Otherwise, return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [3,2,0,-4], pos = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"width: 141px; height: 74px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2], pos = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There is a cycle in the linked list, where the tail connects to the 0th node.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"width: 45px; height: 45px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1], pos = -1\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There is no cycle in the linked list.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of the nodes in the list is in the range \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epos\u003c/code\u003e is \u003ccode\u003e-1\u003c/code\u003e or a \u003cstrong\u003evalid index\u003c/strong\u003e in the linked-list.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e Can you solve it using \u003ccode\u003eO(1)\u003c/code\u003e (i.e. constant) memory?\u003c/p\u003e\n",
   "hints": [],
   "questionId": "141",
   "similarQuestions": "[{\"title\": \"Linked List Cycle II\", \"titleSlug\": \"linked-list-cycle-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u73af\\u5f62\\u94fe\\u8868 II\"}, {\"title\": \"Happy Number\", \"titleSlug\": \"happy-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5feb\\u4e50\\u6570\"}]",
   "topicTags": [
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个链表的头节点 \u003ccode\u003ehead\u003c/code\u003e ，判断链表中是否有环。\u003c/p\u003e\n\n\u003cp\u003e如果链表中有某个节点，可以通过连续跟踪 \u003ccode\u003enext\u003c/code\u003e 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 \u003ccode\u003epos\u003c/code\u003e 来表示链表尾连接到链表中的位置（索引从 0 开始）。\u003cstrong\u003e注意：\u003ccode\u003epos\u003c/code\u003e 不作为参数进行传递\u0026nbsp;\u003c/strong\u003e。仅仅是为了标识链表的实际情况。\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003e如果链表中存在环\u003c/em\u003e\u0026nbsp;，则返回 \u003ccode\u003etrue\u003c/code\u003e 。 否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [3,2,0,-4], pos = 1\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003cstrong\u003e解释：\u003c/strong\u003e链表中有一个环，其尾部连接到第二个节点。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2], pos = 0\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003cstrong\u003e解释：\u003c/strong\u003e链表中有一个环，其尾部连接到第一个节点。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1], pos = -1\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003cstrong\u003e解释：\u003c/strong\u003e链表中没有环。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点的数目范围是 \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epos\u003c/code\u003e 为 \u003ccode\u003e-1\u003c/code\u003e 或者链表中的一个 \u003cstrong\u003e有效索引\u003c/strong\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你能用 \u003ccode\u003eO(1)\u003c/code\u003e（即，常量）内存解决此问题吗？\u003c/p\u003e\n",
   "translatedTitle": "环形链表"
  },
  "linked-list-cycle-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "linked-list-cycle-lcci": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "linked-list-random-node": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "longest-common-prefix": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "longest-common-subsequence": {
   "content": "\u003cp\u003eGiven two strings \u003ccode\u003etext1\u003c/code\u003e and \u003ccode\u003etext2\u003c/code\u003e, return \u003cem\u003ethe length of their longest \u003cstrong\u003ecommon subsequence\u003c/strong\u003e. \u003c/em\u003eIf there is no \u003cstrong\u003ecommon subsequence\u003c/strong\u003e, return \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003esubsequence\u003c/strong\u003e of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, \u003ccode\u003e\u0026quot;ace\u0026quot;\u003c/code\u003e is a subsequence of \u003ccode\u003e\u0026quot;abcde\u0026quot;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eA \u003cstrong\u003ecommon subsequence\u003c/strong\u003e of two strings is a subsequence that is common to both strings.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e text1 = \u0026quot;abcde\u0026quot;, text2 = \u0026quot;ace\u0026quot; \n\u003cstrong\u003eOutput:\u003c/strong\u003e 3  \n\u003cstrong\u003eExplanation:\u003c/strong\u003e The longest common subsequence is \u0026quot;ace\u0026quot; and its length is 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e text1 = \u0026quot;abc\u0026quot;, text2 = \u0026quot;abc\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The longest common subsequence is \u0026quot;abc\u0026quot; and its length is 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e text1 = \u0026quot;abc\u0026quot;, text2 = \u0026quot;def\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There is no such common subsequence, so the result is 0.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= text1.length, text2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etext1\u003c/code\u003e and \u003ccode\u003etext2\u003c/code\u003e consist of only lowercase English characters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Try dynamic programming. \r\nDP[i][j] represents the longest common subsequence of text1[0 ... i] \u0026 text2[0 ... j].",
    "DP[i][j] = DP[i - 1][j - 1] + 1 , if text1[i] == text2[j]\r\nDP[i][j] = max(DP[i - 1][j], DP[i][j - 1]) , otherwise"
   ],
   "questionId": "1250",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个字符串 \u003ccode\u003etext1\u003c/code\u003e 和 \u003ccode\u003etext2\u003c/code\u003e，返回这两个字符串的最长 \u003cstrong\u003e公共子序列\u003c/strong\u003e 的长度。如果不存在 \u003cstrong\u003e公共子序列\u003c/strong\u003e ，返回 \u003ccode\u003e0\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e一个字符串的 \u003cstrong\u003e子序列\u003c/strong\u003e\u003cem\u003e \u003c/em\u003e是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e例如，\u003ccode\u003e\"ace\"\u003c/code\u003e 是 \u003ccode\u003e\"abcde\"\u003c/code\u003e 的子序列，但 \u003ccode\u003e\"aec\"\u003c/code\u003e 不是 \u003ccode\u003e\"abcde\"\u003c/code\u003e 的子序列。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e两个字符串的 \u003cstrong\u003e公共子序列\u003c/strong\u003e 是这两个字符串所共同拥有的子序列。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etext1 = \"abcde\", text2 = \"ace\" \n\u003cstrong\u003e输出：\u003c/strong\u003e3  \n\u003cstrong\u003e解释：\u003c/strong\u003e最长公共子序列是 \"ace\" ，它的长度为 3 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etext1 = \"abc\", text2 = \"abc\"\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e最长公共子序列是 \"abc\" ，它的长度为 3 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etext1 = \"abc\", text2 = \"def\"\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003cstrong\u003e解释：\u003c/strong\u003e两个字符串没有公共子序列，返回 0 。\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= text1.length, text2.length \u003c= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etext1\u003c/code\u003e 和 \u003ccode\u003etext2\u003c/code\u003e 仅由小写英文字符组成。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "最长公共子序列"
  },
  "longest-consecutive-sequence": {
   "content": "\u003cp\u003eGiven an unsorted array of integers \u003ccode\u003enums\u003c/code\u003e, return \u003cem\u003ethe length of the longest consecutive elements sequence.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eYou must write an algorithm that runs in\u0026nbsp;\u003ccode\u003eO(n)\u003c/code\u003e\u0026nbsp;time.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [100,4,200,1,3,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The longest consecutive elements sequence is \u003ccode\u003e[1, 2, 3, 4]\u003c/code\u003e. Therefore its length is 4.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0,3,7,2,5,8,4,6,0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 9\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "128",
   "similarQuestions": "[{\"title\": \"Binary Tree Longest Consecutive Sequence\", \"titleSlug\": \"binary-tree-longest-consecutive-sequence\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u6700\\u957f\\u8fde\\u7eed\\u5e8f\\u5217\"}]",
   "topicTags": [
    {
     "name": "Union Find",
     "slug": "union-find",
     "translatedName": "并查集"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个未排序的整数数组 \u003ccode\u003enums\u003c/code\u003e ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\u003c/p\u003e\n\n\u003cp\u003e请你设计并实现时间复杂度为 \u003ccode\u003eO(n)\u003c/code\u003e\u003cem\u003e \u003c/em\u003e的算法解决此问题。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [100,4,200,1,3,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e4\n\u003cstrong\u003e解释：\u003c/strong\u003e最长数字连续序列是 \u003ccode\u003e[1, 2, 3, 4]。它的长度为 4。\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [0,3,7,2,5,8,4,6,0,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e9\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= nums.length \u003c= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u003c= nums[i] \u003c= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "最长连续序列"
  },
  "longest-palindrome": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "longest-palindromic-substring": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e, return \u003cem\u003ethe longest palindromic substring\u003c/em\u003e in \u003ccode\u003es\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;babad\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;bab\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026quot;aba\u0026quot; is also a valid answer.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;cbbd\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;bb\u0026quot;\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consist of only digits and English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "How can we reuse a previously computed palindrome to compute a larger palindrome?",
    "If “aba” is a palindrome, is “xabax” a palindrome? Similarly is “xabay” a palindrome?",
    "Complexity based hint:\u003c/br\u003e\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
   ],
   "questionId": "5",
   "similarQuestions": "[{\"title\": \"Shortest Palindrome\", \"titleSlug\": \"shortest-palindrome\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6700\\u77ed\\u56de\\u6587\\u4e32\"}, {\"title\": \"Palindrome Permutation\", \"titleSlug\": \"palindrome-permutation\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u56de\\u6587\\u6392\\u5217\"}, {\"title\": \"Palindrome Pairs\", \"titleSlug\": \"palindrome-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u56de\\u6587\\u5bf9\"}, {\"title\": \"Longest Palindromic Subsequence\", \"titleSlug\": \"longest-palindromic-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u957f\\u56de\\u6587\\u5b50\\u5e8f\\u5217\"}, {\"title\": \"Palindromic Substrings\", \"titleSlug\": \"palindromic-substrings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u56de\\u6587\\u5b50\\u4e32\"}]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个字符串 \u003ccode\u003es\u003c/code\u003e，找到 \u003ccode\u003es\u003c/code\u003e 中最长的回文子串。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"babad\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"bab\"\n\u003cstrong\u003e解释：\u003c/strong\u003e\"aba\" 同样是符合题意的答案。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"cbbd\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"bb\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 仅由数字和英文字母组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "最长回文子串"
  },
  "longest-substring-without-repeating-characters": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "lowest-common-ancestor-of-a-binary-search-tree": {
   "content": "\u003cp\u003eGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\u003c/p\u003e\n\n\u003cp\u003eAccording to the \u003ca href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\"\u003edefinition of LCA on Wikipedia\u003c/a\u003e: \u0026ldquo;The lowest common ancestor is defined between two nodes \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e as the lowest node in \u003ccode\u003eT\u003c/code\u003e that has both \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e as descendants (where we allow \u003cb\u003ea node to be a descendant of itself\u003c/b\u003e).\u0026rdquo;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"width: 200px; height: 190px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The LCA of nodes 2 and 8 is 6.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"width: 200px; height: 190px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,1], p = 2, q = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[2, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll \u003ccode\u003eNode.val\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep != q\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e will exist in the BST.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "235",
   "similarQuestions": "[{\"title\": \"Lowest Common Ancestor of a Binary Tree\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u6700\\u8fd1\\u516c\\u5171\\u7956\\u5148\"}, {\"title\": \"Smallest Common Region\", \"titleSlug\": \"smallest-common-region\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u5c0f\\u516c\\u5171\\u533a\\u57df\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\"\u003e百度百科\u003c/a\u003e中最近公共祖先的定义为：\u0026ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（\u003cstrong\u003e一个节点也可以是它自己的祖先\u003c/strong\u003e）。\u0026rdquo;\u003c/p\u003e\n\n\u003cp\u003e例如，给定如下二叉搜索树:\u0026nbsp; root =\u0026nbsp;[6,2,8,0,4,7,9,null,null,3,5]\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"height: 190px; width: 200px;\"\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n\u003cstrong\u003e输出:\u003c/strong\u003e 6 \n\u003cstrong\u003e解释: \u003c/strong\u003e节点 \u003ccode\u003e2 \u003c/code\u003e和节点 \u003ccode\u003e8 \u003c/code\u003e的最近公共祖先是 \u003ccode\u003e6。\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n\u003cstrong\u003e输出:\u003c/strong\u003e 2\n\u003cstrong\u003e解释: \u003c/strong\u003e节点 \u003ccode\u003e2\u003c/code\u003e 和节点 \u003ccode\u003e4\u003c/code\u003e 的最近公共祖先是 \u003ccode\u003e2\u003c/code\u003e, 因为根据定义最近公共祖先节点可以为节点本身。\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e所有节点的值都是唯一的。\u003c/li\u003e\n\t\u003cli\u003ep、q 为不同节点且均存在于给定的二叉搜索树中。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉搜索树的最近公共祖先"
  },
  "lowest-common-ancestor-of-a-binary-tree": {
   "content": "\u003cp\u003eGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\u003c/p\u003e\n\n\u003cp\u003eAccording to the \u003ca href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\"\u003edefinition of LCA on Wikipedia\u003c/a\u003e: \u0026ldquo;The lowest common ancestor is defined between two nodes \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e as the lowest node in \u003ccode\u003eT\u003c/code\u003e that has both \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e as descendants (where we allow \u003cb\u003ea node to be a descendant of itself\u003c/b\u003e).\u0026rdquo;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The LCA of nodes 5 and 1 is 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2], p = 1, q = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[2, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll \u003ccode\u003eNode.val\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep != q\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e will exist in the tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "236",
   "similarQuestions": "[{\"title\": \"Lowest Common Ancestor of a Binary Search Tree\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u7684\\u6700\\u8fd1\\u516c\\u5171\\u7956\\u5148\"}, {\"title\": \"Smallest Common Region\", \"titleSlug\": \"smallest-common-region\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u5c0f\\u516c\\u5171\\u533a\\u57df\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\"\u003e百度百科\u003c/a\u003e中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（\u003cstrong\u003e一个节点也可以是它自己的祖先\u003c/strong\u003e）。”\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e节点 \u003ccode\u003e5 \u003c/code\u003e和节点 \u003ccode\u003e1 \u003c/code\u003e的最近公共祖先是节点 \u003ccode\u003e3 。\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\u003cstrong\u003e输出：\u003c/strong\u003e5\n\u003cstrong\u003e解释：\u003c/strong\u003e节点 \u003ccode\u003e5 \u003c/code\u003e和节点 \u003ccode\u003e4 \u003c/code\u003e的最近公共祖先是节点 \u003ccode\u003e5 。\u003c/code\u003e因为根据定义最近公共祖先节点可以为节点本身。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2], p = 1, q = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数目在范围 \u003ccode\u003e[2, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e 内。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u003c= Node.val \u003c= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e所有 \u003ccode\u003eNode.val\u003c/code\u003e \u003ccode\u003e互不相同\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep != q\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e 和 \u003ccode\u003eq\u003c/code\u003e 均存在于给定的二叉树中。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树的最近公共祖先"
  },
  "lru-cache": {
   "content": "\u003cp\u003eDesign a data structure that follows the constraints of a \u003cstrong\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\"\u003eLeast Recently Used (LRU) cache\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eLRUCache\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eLRUCache(int capacity)\u003c/code\u003e Initialize the LRU cache with \u003cstrong\u003epositive\u003c/strong\u003e size \u003ccode\u003ecapacity\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint get(int key)\u003c/code\u003e Return the value of the \u003ccode\u003ekey\u003c/code\u003e if the key exists, otherwise return \u003ccode\u003e-1\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid put(int key, int value)\u003c/code\u003e\u0026nbsp;Update the value of the \u003ccode\u003ekey\u003c/code\u003e if the \u003ccode\u003ekey\u003c/code\u003e exists. Otherwise, add the \u003ccode\u003ekey-value\u003c/code\u003e pair to the cache. If the number of keys exceeds the \u003ccode\u003ecapacity\u003c/code\u003e from this operation, \u003cstrong\u003eevict\u003c/strong\u003e the least recently used key.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe functions\u0026nbsp;\u003ccode data-stringify-type=\"code\"\u003eget\u003c/code\u003e\u0026nbsp;and\u0026nbsp;\u003ccode data-stringify-type=\"code\"\u003eput\u003c/code\u003e\u0026nbsp;must each run in \u003ccode\u003eO(1)\u003c/code\u003e average time complexity.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;LRUCache\u0026quot;, \u0026quot;put\u0026quot;, \u0026quot;put\u0026quot;, \u0026quot;get\u0026quot;, \u0026quot;put\u0026quot;, \u0026quot;get\u0026quot;, \u0026quot;put\u0026quot;, \u0026quot;get\u0026quot;, \u0026quot;get\u0026quot;, \u0026quot;get\u0026quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= capacity \u0026lt;= 3000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= key \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= value \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAt most 2\u003ccode\u003e\u0026nbsp;* 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u0026nbsp;calls will be made to \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eput\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "146",
   "similarQuestions": "[{\"title\": \"LFU Cache\", \"titleSlug\": \"lfu-cache\", \"difficulty\": \"Hard\", \"translatedTitle\": \"LFU \\u7f13\\u5b58\"}, {\"title\": \"Design In-Memory File System\", \"titleSlug\": \"design-in-memory-file-system\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u8bbe\\u8ba1\\u5185\\u5b58\\u6587\\u4ef6\\u7cfb\\u7edf\"}, {\"title\": \"Design Compressed String Iterator\", \"titleSlug\": \"design-compressed-string-iterator\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u8fed\\u4ee3\\u538b\\u7f29\\u5b57\\u7b26\\u4e32\"}]",
   "topicTags": [
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Doubly-Linked List",
     "slug": "doubly-linked-list",
     "translatedName": "双向链表"
    }
   ],
   "translatedContent": "\u003cdiv class=\"title__3Vvk\"\u003e请你设计并实现一个满足\u0026nbsp; \u003ca href=\"https://baike.baidu.com/item/LRU\" target=\"_blank\"\u003eLRU (最近最少使用) 缓存\u003c/a\u003e 约束的数据结构。\u003c/div\u003e\n\n\u003cdiv class=\"title__3Vvk\"\u003e实现 \u003ccode\u003eLRUCache\u003c/code\u003e 类：\u003c/div\u003e\n\n\u003cdiv class=\"original__bRMd\"\u003e\n\u003cdiv\u003e\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eLRUCache(int capacity)\u003c/code\u003e 以 \u003cstrong\u003e正整数\u003c/strong\u003e 作为容量\u0026nbsp;\u003ccode\u003ecapacity\u003c/code\u003e 初始化 LRU 缓存\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint get(int key)\u003c/code\u003e 如果关键字 \u003ccode\u003ekey\u003c/code\u003e 存在于缓存中，则返回关键字的值，否则返回 \u003ccode\u003e-1\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid put(int key, int value)\u003c/code\u003e\u0026nbsp;如果关键字\u0026nbsp;\u003ccode\u003ekey\u003c/code\u003e 已经存在，则变更其数据值\u0026nbsp;\u003ccode\u003evalue\u003c/code\u003e ；如果不存在，则向缓存中插入该组\u0026nbsp;\u003ccode\u003ekey-value\u003c/code\u003e 。如果插入操作导致关键字数量超过\u0026nbsp;\u003ccode\u003ecapacity\u003c/code\u003e ，则应该 \u003cstrong\u003e逐出\u003c/strong\u003e 最久未使用的关键字。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e函数 \u003ccode\u003eget\u003c/code\u003e 和 \u003ccode\u003eput\u003c/code\u003e 必须以 \u003ccode\u003eO(1)\u003c/code\u003e 的平均时间复杂度运行。\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入\u003c/strong\u003e\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\u003cstrong\u003e输出\u003c/strong\u003e\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\u003cstrong\u003e解释\u003c/strong\u003e\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= capacity \u0026lt;= 3000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= key \u0026lt;= 10000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= value \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e最多调用 \u003ccode\u003e2 * 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e 次 \u003ccode\u003eget\u003c/code\u003e 和 \u003ccode\u003eput\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "LRU 缓存"
  },
  "majority-element": {
   "content": "\u003cp\u003eGiven an array \u003ccode\u003enums\u003c/code\u003e of size \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003ethe majority element\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe majority element is the element that appears more than \u003ccode\u003e\u0026lfloor;n / 2\u0026rfloor;\u003c/code\u003e times. You may assume that the majority element always exists in the array.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [3,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [2,2,1,1,1,2,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003en == nums.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow-up:\u003c/strong\u003e Could you solve the problem in linear time and in \u003ccode\u003eO(1)\u003c/code\u003e space?",
   "hints": [],
   "questionId": "169",
   "similarQuestions": "[{\"title\": \"Majority Element II\", \"titleSlug\": \"majority-element-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6c42\\u4f17\\u6570 II\"}, {\"title\": \"Check If a Number Is Majority Element in a Sorted Array\", \"titleSlug\": \"check-if-a-number-is-majority-element-in-a-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u68c0\\u67e5\\u4e00\\u4e2a\\u6570\\u662f\\u5426\\u5728\\u6570\\u7ec4\\u4e2d\\u5360\\u7edd\\u5927\\u591a\\u6570\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Divide and Conquer",
     "slug": "divide-and-conquer",
     "translatedName": "分治"
    },
    {
     "name": "Counting",
     "slug": "counting",
     "translatedName": "计数"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个大小为 \u003cem\u003en \u003c/em\u003e的数组，找到其中的多数元素。多数元素是指在数组中出现次数 \u003cstrong\u003e大于\u003c/strong\u003e \u003ccode\u003e⌊ n/2 ⌋\u003c/code\u003e 的元素。\u003c/p\u003e\n\n\u003cp\u003e你可以假设数组是非空的，并且给定的数组总是存在多数元素。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e[3,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e3\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e[2,2,1,1,1,2,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "多数元素"
  },
  "max-stack": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "maximal-square": {
   "content": "\u003cp\u003eGiven an \u003ccode\u003em x n\u003c/code\u003e binary \u003ccode\u003ematrix\u003c/code\u003e filled with \u003ccode\u003e0\u003c/code\u003e\u0026#39;s and \u003ccode\u003e1\u003c/code\u003e\u0026#39;s, \u003cem\u003efind the largest square containing only\u003c/em\u003e \u003ccode\u003e1\u003c/code\u003e\u0026#39;s \u003cem\u003eand return its area\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg\" style=\"width: 400px; height: 319px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],[\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;],[\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;],[\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg\" style=\"width: 165px; height: 165px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;],[\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[\u0026quot;0\u0026quot;]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == matrix.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 300\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ematrix[i][j]\u003c/code\u003e is \u003ccode\u003e\u0026#39;0\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;1\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "221",
   "similarQuestions": "[{\"title\": \"Maximal Rectangle\", \"titleSlug\": \"maximal-rectangle\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6700\\u5927\\u77e9\\u5f62\"}, {\"title\": \"Largest Plus Sign\", \"titleSlug\": \"largest-plus-sign\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u5927\\u52a0\\u53f7\\u6807\\u5fd7\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    }
   ],
   "translatedContent": "\u003cp\u003e在一个由 \u003ccode\u003e'0'\u003c/code\u003e 和 \u003ccode\u003e'1'\u003c/code\u003e 组成的二维矩阵内，找到只包含 \u003ccode\u003e'1'\u003c/code\u003e 的最大正方形，并返回其面积。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg\" style=\"width: 400px; height: 319px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n\u003cstrong\u003e输出：\u003c/strong\u003e4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg\" style=\"width: 165px; height: 165px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[\"0\"]]\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == matrix.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= m, n \u003c= 300\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ematrix[i][j]\u003c/code\u003e 为 \u003ccode\u003e'0'\u003c/code\u003e 或 \u003ccode\u003e'1'\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "最大正方形"
  },
  "maximum-depth-of-binary-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "maximum-depth-of-n-ary-tree": {
   "content": "\u003cp\u003eGiven a n-ary tree, find its maximum depth.\u003c/p\u003e\n\n\u003cp\u003eThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,3,2,4,null,5,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe total number of nodes is in the range \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eThe depth of the n-ary tree is less than or equal to \u003ccode\u003e1000\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "774",
   "similarQuestions": "[{\"title\": \"Maximum Depth of Binary Tree\", \"titleSlug\": \"maximum-depth-of-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u6700\\u5927\\u6df1\\u5ea6\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个 N 叉树，找到其最大深度。\u003c/p\u003e\n\n\u003cp class=\"MachineTrans-lang-zh-CN\"\u003e最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\u003c/p\u003e\n\n\u003cp class=\"MachineTrans-lang-zh-CN\"\u003eN 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\u003c/p\u003e\n\n\u003cp class=\"MachineTrans-lang-zh-CN\"\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,null,3,2,4,null,5,6]\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\u003cstrong\u003e输出：\u003c/strong\u003e5\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树的深度不会超过 \u003ccode\u003e1000\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e树的节点数目位于 \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e 之间。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "N 叉树的最大深度"
  },
  "maximum-frequency-stack": {
   "content": "\u003cp\u003eDesign a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eFreqStack\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eFreqStack()\u003c/code\u003e constructs an empty frequency stack.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid push(int val)\u003c/code\u003e pushes an integer \u003ccode\u003eval\u003c/code\u003e onto the top of the stack.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint pop()\u003c/code\u003e removes and returns the most frequent element in the stack.\n\t\u003cul\u003e\n\t\t\u003cli\u003eIf there is a tie for the most frequent element, the element closest to the stack\u0026#39;s top is removed and returned.\u003c/li\u003e\n\t\u003c/ul\u003e\n\t\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;FreqStack\u0026quot;, \u0026quot;push\u0026quot;, \u0026quot;push\u0026quot;, \u0026quot;push\u0026quot;, \u0026quot;push\u0026quot;, \u0026quot;push\u0026quot;, \u0026quot;push\u0026quot;, \u0026quot;pop\u0026quot;, \u0026quot;pop\u0026quot;, \u0026quot;pop\u0026quot;, \u0026quot;pop\u0026quot;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= val \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e2 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls will be made to \u003ccode\u003epush\u003c/code\u003e and \u003ccode\u003epop\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eIt is guaranteed that there will be at least one element in the stack before calling \u003ccode\u003epop\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "931",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Ordered Set",
     "slug": "ordered-set",
     "translatedName": "有序集合"
    }
   ],
   "translatedContent": "\u003cp\u003e设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出\u003cstrong\u003e出现频率\u003c/strong\u003e最高的元素。\u003c/p\u003e\n\n\u003cp\u003e实现 \u003ccode\u003eFreqStack\u003c/code\u003e\u0026nbsp;类:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003ccode\u003eFreqStack()\u003c/code\u003e\u0026nbsp;构造一个空的堆栈。\u003c/li\u003e\n\t\u003cli\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003ccode\u003evoid push(int val)\u003c/code\u003e\u0026nbsp;将一个整数\u0026nbsp;\u003ccode\u003eval\u003c/code\u003e\u0026nbsp;压入栈顶。\u003c/li\u003e\n\t\u003cli\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003ccode\u003eint pop()\u003c/code\u003e\u0026nbsp;删除并返回堆栈中出现频率最高的元素。\n\t\u003cul\u003e\n\t\t\u003cli\u003e如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。\u003c/li\u003e\n\t\u003c/ul\u003e\n\t\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"pop\"],\n[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[null,null,null,null,null,null,null,5,7,5,4]\n\u003cstrong\u003e解释：\u003c/strong\u003e\nFreqStack = new FreqStack();\nfreqStack.push (5);//堆栈为 [5]\nfreqStack.push (7);//堆栈是 [5,7]\nfreqStack.push (5);//堆栈是 [5,7,5]\nfreqStack.push (7);//堆栈是 [5,7,5,7]\nfreqStack.push (4);//堆栈是 [5,7,5,7,4]\nfreqStack.push (5);//堆栈是 [5,7,5,7,4,5]\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。\nfreqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。\nfreqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= val \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epush\u003c/code\u003e\u0026nbsp;和 \u003ccode\u003epop\u003c/code\u003e\u0026nbsp;的操作数不大于 \u003ccode\u003e2 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e。\u003c/li\u003e\n\t\u003cli\u003e输入保证在调用\u0026nbsp;\u003ccode\u003epop\u003c/code\u003e\u0026nbsp;之前堆栈中至少有一个元素。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "最大频率栈"
  },
  "maximum-lcci": {
   "content": "\u003cp\u003eWrite a method that finds the maximum of two numbers. You should not use if-else or any other comparison operator.\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eExample: \u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\n\u003cstrong\u003eInput: \u003c/strong\u003e a = 1, b = 2\r\n\u003cstrong\u003eOutput: \u003c/strong\u003e 2\r\n\u003c/pre\u003e\r\n",
   "hints": [
    "如果a \u003e b，则k为1，否则为0。如果给定k，你能返回最大值吗（没有比较或if-else逻辑）？",
    "如果当a \u003e b时，k等于1，那么当k等于0时则相反，然后你可以返回a*k + b* (非k)。但你如何创建k？",
    "当a \u003e b时，a – b \u003e 0。你能得到a – b的符号位吗？",
    "你考虑过如何处理a – b中的整数溢出吗？"
   ],
   "questionId": "100349",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Brainteaser",
     "slug": "brainteaser",
     "translatedName": "脑筋急转弯"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e编写一个方法，找出两个数字\u003ccode\u003ea\u003c/code\u003e和\u003ccode\u003eb\u003c/code\u003e中最大的那一个。不得使用if-else或其他比较运算符。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003e a = 1, b = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e 2\n\u003c/pre\u003e\n",
   "translatedTitle": "最大数值"
  },
  "maximum-number-of-balloons": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "maximum-product-of-three-numbers": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e, \u003cem\u003efind three numbers whose product is maximum and return the maximum product\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 24\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [-1,-2,-3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e -6\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 \u0026lt;= nums.length \u0026lt;=\u0026nbsp;10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= nums[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "628",
   "similarQuestions": "[{\"title\": \"Maximum Product Subarray\", \"titleSlug\": \"maximum-product-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e58\\u79ef\\u6700\\u5927\\u5b50\\u6570\\u7ec4\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整型数组 \u003ccode\u003enums\u003c/code\u003e ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e6\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,2,3,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e24\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [-1,-2,-3]\n\u003cstrong\u003e输出：\u003c/strong\u003e-6\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 \u003c= nums.length \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u003c= nums[i] \u003c= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "三个数的最大乘积"
  },
  "maximum-subarray": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "maximum-twin-sum-of-a-linked-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "median-of-two-sorted-arrays": {
   "content": "\u003cp\u003eGiven two sorted arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e of size \u003ccode\u003em\u003c/code\u003e and \u003ccode\u003en\u003c/code\u003e respectively, return \u003cstrong\u003ethe median\u003c/strong\u003e of the two sorted arrays.\u003c/p\u003e\n\n\u003cp\u003eThe overall run time complexity should be \u003ccode\u003eO(log (m+n))\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums1 = [1,3], nums2 = [2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2.00000\n\u003cstrong\u003eExplanation:\u003c/strong\u003e merged array = [1,2,3] and median is 2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums1 = [1,2], nums2 = [3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2.50000\n\u003cstrong\u003eExplanation:\u003c/strong\u003e merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003enums1.length == m\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums2.length == n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= m \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= n \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m + n \u0026lt;= 2000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e6\u003c/sup\u003e \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "4",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Divide and Conquer",
     "slug": "divide-and-conquer",
     "translatedName": "分治"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个大小分别为 \u003ccode\u003em\u003c/code\u003e 和 \u003ccode\u003en\u003c/code\u003e 的正序（从小到大）数组\u0026nbsp;\u003ccode\u003enums1\u003c/code\u003e 和\u0026nbsp;\u003ccode\u003enums2\u003c/code\u003e。请你找出并返回这两个正序数组的 \u003cstrong\u003e中位数\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e算法的时间复杂度应该为 \u003ccode\u003eO(log (m+n))\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums1 = [1,3], nums2 = [2]\n\u003cstrong\u003e输出：\u003c/strong\u003e2.00000\n\u003cstrong\u003e解释：\u003c/strong\u003e合并数组 = [1,2,3] ，中位数 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums1 = [1,2], nums2 = [3,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e2.50000\n\u003cstrong\u003e解释：\u003c/strong\u003e合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003enums1.length == m\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums2.length == n\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= m \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= n \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m + n \u0026lt;= 2000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e6\u003c/sup\u003e \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "寻找两个正序数组的中位数"
  },
  "meeting-rooms": {
   "content": "\u003cp\u003eGiven an array of meeting time \u003ccode\u003eintervals\u003c/code\u003e\u0026nbsp;where \u003ccode\u003eintervals[i] = [start\u003csub\u003ei\u003c/sub\u003e, end\u003csub\u003ei\u003c/sub\u003e]\u003c/code\u003e, determine if a person could attend all meetings.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e intervals = [[0,30],[5,10],[15,20]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e intervals = [[7,10],[2,4]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= intervals.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eintervals[i].length == 2\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= start\u003csub\u003ei\u003c/sub\u003e \u0026lt;\u0026nbsp;end\u003csub\u003ei\u003c/sub\u003e \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "252",
   "similarQuestions": "[{\"title\": \"Merge Intervals\", \"titleSlug\": \"merge-intervals\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5408\\u5e76\\u533a\\u95f4\"}, {\"title\": \"Meeting Rooms II\", \"titleSlug\": \"meeting-rooms-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4f1a\\u8bae\\u5ba4 II\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个会议时间安排的数组 \u003ccode\u003eintervals\u003c/code\u003e ，每个会议时间都会包括开始和结束的时间 \u003ccode\u003eintervals[i] = [start\u003csub\u003ei\u003c/sub\u003e, end\u003csub\u003ei\u003c/sub\u003e]\u003c/code\u003e ，请你判断一个人是否能够参加这里面的全部会议。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eintervals = [[0,30],[5,10],[15,20]]\n\u003cstrong\u003e输出\u003c/strong\u003e：false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eintervals = [[7,10],[2,4]]\n\u003cstrong\u003e输出\u003c/strong\u003e：true\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= intervals.length \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eintervals[i].length == 2\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= start\u003csub\u003ei\u003c/sub\u003e \u003c end\u003csub\u003ei\u003c/sub\u003e \u003c= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "会议室"
  },
  "merge-in-between-linked-lists": {
   "content": "\u003cp\u003eYou are given two linked lists: \u003ccode\u003elist1\u003c/code\u003e and \u003ccode\u003elist2\u003c/code\u003e of sizes \u003ccode\u003en\u003c/code\u003e and \u003ccode\u003em\u003c/code\u003e respectively.\u003c/p\u003e\n\n\u003cp\u003eRemove \u003ccode\u003elist1\u003c/code\u003e\u0026#39;s nodes from the \u003ccode\u003ea\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e node to the \u003ccode\u003eb\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e node, and put \u003ccode\u003elist2\u003c/code\u003e in their place.\u003c/p\u003e\n\n\u003cp\u003eThe blue edges and nodes in the following figure indicate the result:\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/fig1.png\" style=\"height: 130px; width: 504px;\" /\u003e\n\u003cp\u003e\u003cem\u003eBuild the result list and return its head.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/merge_linked_list_ex1.png\" style=\"width: 406px; height: 140px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0,1,2,1000000,1000001,1000002,5]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/merge_linked_list_ex2.png\" style=\"width: 463px; height: 140px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0,1,1000000,1000001,1000002,1000003,1000004,6]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The blue edges and nodes in the above figure indicate the result.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 \u0026lt;= list1.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= a \u0026lt;= b \u0026lt; list1.length - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= list2.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Check which edges need to be changed.",
    "Let the next node of the (a-1)th node of list1 be the 0-th node in list 2.",
    "Let the next node of the last node of list2 be the (b+1)-th node in list 1."
   ],
   "questionId": "1765",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    }
   ],
   "translatedContent": "\u003cp\u003e给你两个链表\u0026nbsp;\u003ccode\u003elist1\u003c/code\u003e 和\u0026nbsp;\u003ccode\u003elist2\u003c/code\u003e\u0026nbsp;，它们包含的元素分别为\u0026nbsp;\u003ccode\u003en\u003c/code\u003e 个和\u0026nbsp;\u003ccode\u003em\u003c/code\u003e 个。\u003c/p\u003e\n\n\u003cp\u003e请你将\u0026nbsp;\u003ccode\u003elist1\u003c/code\u003e\u0026nbsp;中下标从 \u003ccode\u003ea\u003c/code\u003e 到 \u003ccode\u003eb\u003c/code\u003e 的全部节点都删除，并将\u003ccode\u003elist2\u003c/code\u003e\u0026nbsp;接在被删除节点的位置。\u003c/p\u003e\n\n\u003cp\u003e下图中蓝色边和节点展示了操作后的结果：\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/fig1.png\" style=\"height: 130px; width: 504px;\" /\u003e\n\u003cp\u003e请你返回结果链表的头指针。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex1.png\" style=\"width: 406px; height: 140px;\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003elist1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n\u003cb\u003e输出：\u003c/b\u003e[0,1,2,1000000,1000001,1000002,5]\n\u003cb\u003e解释：\u003c/b\u003e我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex2.png\" style=\"width: 463px; height: 140px;\" /\u003e\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003elist1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\n\u003cb\u003e输出：\u003c/b\u003e[0,1,1000000,1000001,1000002,1000003,1000004,6]\n\u003cb\u003e解释：\u003c/b\u003e上图中蓝色的边和节点为答案链表。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 \u0026lt;= list1.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= a \u0026lt;= b \u0026lt; list1.length - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= list2.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "合并两个链表"
  },
  "merge-intervals": {
   "content": "\u003cp\u003eGiven an array\u0026nbsp;of \u003ccode\u003eintervals\u003c/code\u003e\u0026nbsp;where \u003ccode\u003eintervals[i] = [start\u003csub\u003ei\u003c/sub\u003e, end\u003csub\u003ei\u003c/sub\u003e]\u003c/code\u003e, merge all overlapping intervals, and return \u003cem\u003ean array of the non-overlapping intervals that cover all the intervals in the input\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e intervals = [[1,3],[2,6],[8,10],[15,18]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1,6],[8,10],[15,18]]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e intervals = [[1,4],[4,5]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1,5]]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Intervals [1,4] and [4,5] are considered overlapping.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= intervals.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eintervals[i].length == 2\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= start\u003csub\u003ei\u003c/sub\u003e \u0026lt;= end\u003csub\u003ei\u003c/sub\u003e \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "56",
   "similarQuestions": "[{\"title\": \"Insert Interval\", \"titleSlug\": \"insert-interval\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u63d2\\u5165\\u533a\\u95f4\"}, {\"title\": \"Meeting Rooms\", \"titleSlug\": \"meeting-rooms\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4f1a\\u8bae\\u5ba4\"}, {\"title\": \"Meeting Rooms II\", \"titleSlug\": \"meeting-rooms-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4f1a\\u8bae\\u5ba4 II\"}, {\"title\": \"Teemo Attacking\", \"titleSlug\": \"teemo-attacking\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u63d0\\u83ab\\u653b\\u51fb\"}, {\"title\": \"Add Bold Tag in String\", \"titleSlug\": \"add-bold-tag-in-string\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7ed9\\u5b57\\u7b26\\u4e32\\u6dfb\\u52a0\\u52a0\\u7c97\\u6807\\u7b7e\"}, {\"title\": \"Range Module\", \"titleSlug\": \"range-module\", \"difficulty\": \"Hard\", \"translatedTitle\": \"Range \\u6a21\\u5757\"}, {\"title\": \"Employee Free Time\", \"titleSlug\": \"employee-free-time\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u5458\\u5de5\\u7a7a\\u95f2\\u65f6\\u95f4\"}, {\"title\": \"Partition Labels\", \"titleSlug\": \"partition-labels\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5212\\u5206\\u5b57\\u6bcd\\u533a\\u95f4\"}, {\"title\": \"Interval List Intersections\", \"titleSlug\": \"interval-list-intersections\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u533a\\u95f4\\u5217\\u8868\\u7684\\u4ea4\\u96c6\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e以数组 \u003ccode\u003eintervals\u003c/code\u003e 表示若干个区间的集合，其中单个区间为 \u003ccode\u003eintervals[i] = [start\u003csub\u003ei\u003c/sub\u003e, end\u003csub\u003ei\u003c/sub\u003e]\u003c/code\u003e 。请你合并所有重叠的区间，并返回\u0026nbsp;\u003cem\u003e一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间\u003c/em\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eintervals = [[1,3],[2,6],[8,10],[15,18]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1,6],[8,10],[15,18]]\n\u003cstrong\u003e解释：\u003c/strong\u003e区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eintervals = [[1,4],[4,5]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1,5]]\n\u003cstrong\u003e解释：\u003c/strong\u003e区间 [1,4] 和 [4,5] 可被视为重叠区间。\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= intervals.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eintervals[i].length == 2\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= start\u003csub\u003ei\u003c/sub\u003e \u0026lt;= end\u003csub\u003ei\u003c/sub\u003e \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "合并区间"
  },
  "merge-k-sorted-lists": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "merge-sorted-array": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "merge-two-binary-trees": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "merge-two-sorted-lists": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "middle-of-the-linked-list": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003ehead\u003c/code\u003e of a singly linked list, return \u003cem\u003ethe middle node of the linked list\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf there are two middle nodes, return \u003cstrong\u003ethe second middle\u003c/strong\u003e node.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg\" style=\"width: 544px; height: 65px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,4,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3,4,5]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The middle node of the list is node 3.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg\" style=\"width: 664px; height: 65px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,4,5,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [4,5,6]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Since the list has two middle nodes with values 3 and 4, we return the second one.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "908",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个头结点为 \u003ccode\u003ehead\u003c/code\u003e 的非空单链表，返回链表的中间结点。\u003c/p\u003e\n\n\u003cp\u003e如果有两个中间结点，则返回第二个中间结点。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e[1,2,3,4,5]\n\u003cstrong\u003e输出：\u003c/strong\u003e此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e[1,2,3,4,5,6]\n\u003cstrong\u003e输出：\u003c/strong\u003e此列表中的结点 4 (序列化形式：[4,5,6])\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e给定链表的结点数介于 \u003ccode\u003e1\u003c/code\u003e 和 \u003ccode\u003e100\u003c/code\u003e 之间。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "链表的中间结点"
  },
  "min-stack": {
   "content": "\u003cp\u003eDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eMinStack\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eMinStack()\u003c/code\u003e initializes the stack object.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid push(int val)\u003c/code\u003e pushes the element \u003ccode\u003eval\u003c/code\u003e onto the stack.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid pop()\u003c/code\u003e removes the element on the top of the stack.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint top()\u003c/code\u003e gets the top element of the stack.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint getMin()\u003c/code\u003e retrieves the minimum element in the stack.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;MinStack\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;push\u0026quot;,\u0026quot;getMin\u0026quot;,\u0026quot;pop\u0026quot;,\u0026quot;top\u0026quot;,\u0026quot;getMin\u0026quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null,null,null,null,-3,null,0,-2]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eMethods \u003ccode\u003epop\u003c/code\u003e, \u003ccode\u003etop\u003c/code\u003e and \u003ccode\u003egetMin\u003c/code\u003e operations will always be called on \u003cstrong\u003enon-empty\u003c/strong\u003e stacks.\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls will be made to \u003ccode\u003epush\u003c/code\u003e, \u003ccode\u003epop\u003c/code\u003e, \u003ccode\u003etop\u003c/code\u003e, and \u003ccode\u003egetMin\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Consider each node in the stack having a minimum value. (Credits to @aakarshmadhavan)"
   ],
   "questionId": "155",
   "similarQuestions": "[{\"title\": \"Sliding Window Maximum\", \"titleSlug\": \"sliding-window-maximum\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6ed1\\u52a8\\u7a97\\u53e3\\u6700\\u5927\\u503c\"}, {\"title\": \"Max Stack\", \"titleSlug\": \"max-stack\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6700\\u5927\\u6808\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    }
   ],
   "translatedContent": "\u003cp\u003e设计一个支持 \u003ccode\u003epush\u003c/code\u003e ，\u003ccode\u003epop\u003c/code\u003e ，\u003ccode\u003etop\u003c/code\u003e 操作，并能在常数时间内检索到最小元素的栈。\u003c/p\u003e\n\n\u003cp\u003e实现 \u003ccode\u003eMinStack\u003c/code\u003e 类:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eMinStack()\u003c/code\u003e 初始化堆栈对象。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid push(int val)\u003c/code\u003e 将元素val推入堆栈。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid pop()\u003c/code\u003e 删除堆栈顶部的元素。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint top()\u003c/code\u003e 获取堆栈顶部的元素。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eint getMin()\u003c/code\u003e 获取堆栈中的最小元素。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n\u003cstrong\u003e输出：\u003c/strong\u003e\n[null,null,null,null,-3,null,0,-2]\n\n\u003cstrong\u003e解释：\u003c/strong\u003e\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --\u0026gt; 返回 -3.\nminStack.pop();\nminStack.top();      --\u0026gt; 返回 0.\nminStack.getMin();   --\u0026gt; 返回 -2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e\u0026nbsp;\u0026lt;= val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e\u0026nbsp;- 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epop\u003c/code\u003e、\u003ccode\u003etop\u003c/code\u003e 和 \u003ccode\u003egetMin\u003c/code\u003e 操作总是在 \u003cstrong\u003e非空栈\u003c/strong\u003e 上调用\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epush\u003c/code\u003e,\u0026nbsp;\u003ccode\u003epop\u003c/code\u003e,\u0026nbsp;\u003ccode\u003etop\u003c/code\u003e, and\u0026nbsp;\u003ccode\u003egetMin\u003c/code\u003e最多被调用\u0026nbsp;\u003ccode\u003e3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u0026nbsp;次\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "最小栈"
  },
  "minimum-ascii-delete-sum-for-two-strings": {
   "content": "\u003cp\u003eGiven two strings \u003ccode\u003es1\u003c/code\u003e and\u0026nbsp;\u003ccode\u003es2\u003c/code\u003e, return \u003cem\u003ethe lowest \u003cstrong\u003eASCII\u003c/strong\u003e sum of deleted characters to make two strings equal\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s1 = \u0026quot;sea\u0026quot;, s2 = \u0026quot;eat\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 231\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Deleting \u0026quot;s\u0026quot; from \u0026quot;sea\u0026quot; adds the ASCII value of \u0026quot;s\u0026quot; (115) to the sum.\nDeleting \u0026quot;t\u0026quot; from \u0026quot;eat\u0026quot; adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s1 = \u0026quot;delete\u0026quot;, s2 = \u0026quot;leet\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 403\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Deleting \u0026quot;dee\u0026quot; from \u0026quot;delete\u0026quot; to turn the string into \u0026quot;let\u0026quot;,\nadds 100[d] + 101[e] + 101[e] to the sum.\nDeleting \u0026quot;e\u0026quot; from \u0026quot;leet\u0026quot; adds 101[e] to the sum.\nAt the end, both strings are equal to \u0026quot;let\u0026quot;, and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into \u0026quot;lee\u0026quot; or \u0026quot;eet\u0026quot;, we would get answers of 433 or 417, which are higher.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s1.length, s2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es1\u003c/code\u003e and \u003ccode\u003es2\u003c/code\u003e consist of lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Let dp(i, j) be the answer for inputs s1[i:] and s2[j:]."
   ],
   "questionId": "712",
   "similarQuestions": "[{\"title\": \"Edit Distance\", \"titleSlug\": \"edit-distance\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u7f16\\u8f91\\u8ddd\\u79bb\"}, {\"title\": \"Longest Increasing Subsequence\", \"titleSlug\": \"longest-increasing-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u957f\\u9012\\u589e\\u5b50\\u5e8f\\u5217\"}, {\"title\": \"Delete Operation for Two Strings\", \"titleSlug\": \"delete-operation-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e24\\u4e2a\\u5b57\\u7b26\\u4e32\\u7684\\u5220\\u9664\\u64cd\\u4f5c\"}]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个字符串\u003ccode\u003es1\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003es2\u003c/code\u003e，返回 \u003cem\u003e使两个字符串相等所需删除字符的\u0026nbsp;\u003cstrong\u003eASCII\u0026nbsp;\u003c/strong\u003e值的最小和\u0026nbsp;\u003c/em\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s1 = \"sea\", s2 = \"eat\"\n\u003cstrong\u003e输出:\u003c/strong\u003e 231\n\u003cstrong\u003e解释:\u003c/strong\u003e 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。\n在 \"eat\" 中删除 \"t\" 并将 116 加入总和。\n结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s1 = \"delete\", s2 = \"leet\"\n\u003cstrong\u003e输出:\u003c/strong\u003e 403\n\u003cstrong\u003e解释:\u003c/strong\u003e 在 \"delete\" 中删除 \"dee\" 字符串变成 \"let\"，\n将 100[d]+101[e]+101[e] 加入总和。在 \"leet\" 中删除 \"e\" 将 101[e] 加入总和。\n结束时，两个字符串都等于 \"let\"，结果即为 100+101+101+101 = 403 。\n如果改为将两个字符串转换为 \"lee\" 或 \"eet\"，我们会得到 433 或 417 的结果，比答案更大。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= s1.length, s2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es1\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003es2\u003c/code\u003e\u0026nbsp;由小写英文字母组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "两个字符串的最小ASCII删除和"
  },
  "minimum-depth-of-binary-tree": {
   "content": "\u003cp\u003eGiven a binary tree, find its minimum depth.\u003c/p\u003e\n\n\u003cp\u003eThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u0026nbsp;A leaf is a node with no children.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" style=\"width: 432px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [3,9,20,null,null,15,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,null,3,null,4,null,5,null,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "111",
   "similarQuestions": "[{\"title\": \"Binary Tree Level Order Traversal\", \"titleSlug\": \"binary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u5c42\\u5e8f\\u904d\\u5386\"}, {\"title\": \"Maximum Depth of Binary Tree\", \"titleSlug\": \"maximum-depth-of-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u6700\\u5927\\u6df1\\u5ea6\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个二叉树，找出其最小深度。\u003c/p\u003e\n\n\u003cp\u003e最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e叶子节点是指没有子节点的节点。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" style=\"width: 432px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [3,9,20,null,null,15,7]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [2,null,3,null,4,null,5,null,6]\n\u003cstrong\u003e输出：\u003c/strong\u003e5\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数的范围在 \u003ccode\u003e[0, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u003c= Node.val \u003c= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树的最小深度"
  },
  "minimum-height-tree-lcci": {
   "content": "\u003cp\u003eGiven a sorted (increasing order) array with unique integer elements, write an algo\u0026shy;rithm to create a binary search tree with minimal height.\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\nGiven sorted array: [-10,-3,0,5,9],\r\n\r\nOne possible answer is: [0,-3,9,-10,null,5]，which represents the following tree: \r\n\r\n          0 \r\n         / \\ \r\n       -3   9 \r\n       /   / \r\n     -10  5 \r\n\u003c/pre\u003e\r\n",
   "hints": [
    "最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？",
    "你可以通过找到“理想”的下一个要添加的元素和多次调用insertValue来实现。这样效率会有点儿低，因为你必须反复遍历树。尝试用递归代替。你能把这个问题分解为子问题吗？",
    "想象一下，我们有一个createMinimalTree方法可以返回给定数组的最小树（但由于一些奇怪的原因不在树的根上操作）。你能用这个操作树的根节点吗？你能写出函数的基线条件吗？非常好！那基本上是整个函数了。"
   ],
   "questionId": "100174",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Divide and Conquer",
     "slug": "divide-and-conquer",
     "translatedName": "分治"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。\u003c/p\u003e\u003cstrong\u003e示例:\u003c/strong\u003e\u003cpre\u003e给定有序数组: [-10,-3,0,5,9],\u003cbr\u003e\u003cbr\u003e一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\u003cbr\u003e\u003cbr\u003e          0 \u003cbr\u003e         / \u0026#92 \u003cbr\u003e       -3   9 \u003cbr\u003e       /   / \u003cbr\u003e     -10  5 \u003cbr\u003e\u003c/pre\u003e",
   "translatedTitle": "最小高度树"
  },
  "minimum-path-sum": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "minimum-size-subarray-sum": {
   "content": "\u003cp\u003eGiven an array of positive integers \u003ccode\u003enums\u003c/code\u003e and a positive integer \u003ccode\u003etarget\u003c/code\u003e, return the minimal length of a \u003cstrong\u003econtiguous subarray\u003c/strong\u003e \u003ccode\u003e[nums\u003csub\u003el\u003c/sub\u003e, nums\u003csub\u003el+1\u003c/sub\u003e, ..., nums\u003csub\u003er-1\u003c/sub\u003e, nums\u003csub\u003er\u003c/sub\u003e]\u003c/code\u003e of which the sum is greater than or equal to \u003ccode\u003etarget\u003c/code\u003e. If there is no such subarray, return \u003ccode\u003e0\u003c/code\u003e instead.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e target = 7, nums = [2,3,1,2,4,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The subarray [4,3] has the minimal length under the problem constraint.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e target = 4, nums = [1,4,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e target = 11, nums = [1,1,1,1,1,1,1,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= target \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e If you have figured out the \u003ccode\u003eO(n)\u003c/code\u003e solution, try coding another solution of which the time complexity is \u003ccode\u003eO(n log(n))\u003c/code\u003e.",
   "hints": [],
   "questionId": "209",
   "similarQuestions": "[{\"title\": \"Minimum Window Substring\", \"titleSlug\": \"minimum-window-substring\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6700\\u5c0f\\u8986\\u76d6\\u5b50\\u4e32\"}, {\"title\": \"Maximum Size Subarray Sum Equals k\", \"titleSlug\": \"maximum-size-subarray-sum-equals-k\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u548c\\u7b49\\u4e8e k \\u7684\\u6700\\u957f\\u5b50\\u6570\\u7ec4\\u957f\\u5ea6\"}, {\"title\": \"Maximum Length of Repeated Subarray\", \"titleSlug\": \"maximum-length-of-repeated-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u957f\\u91cd\\u590d\\u5b50\\u6570\\u7ec4\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Prefix Sum",
     "slug": "prefix-sum",
     "translatedName": "前缀和"
    },
    {
     "name": "Sliding Window",
     "slug": "sliding-window",
     "translatedName": "滑动窗口"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个含有 \u003ccode\u003en\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003e个正整数的数组和一个正整数 \u003ccode\u003etarget\u003c/code\u003e\u003cstrong\u003e 。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e找出该数组中满足其和\u003cstrong\u003e \u003c/strong\u003e\u003ccode\u003e≥ target\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003e的长度最小的 \u003cstrong\u003e连续子数组\u003c/strong\u003e \u003ccode\u003e[nums\u003csub\u003el\u003c/sub\u003e, nums\u003csub\u003el+1\u003c/sub\u003e, ..., nums\u003csub\u003er-1\u003c/sub\u003e, nums\u003csub\u003er\u003c/sub\u003e]\u003c/code\u003e ，并返回其长度\u003cstrong\u003e。\u003c/strong\u003e如果不存在符合条件的子数组，返回 \u003ccode\u003e0\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etarget = 7, nums = [2,3,1,2,4,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e子数组 \u003ccode\u003e[4,3]\u003c/code\u003e 是该条件下的长度最小的子数组。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etarget = 4, nums = [1,4,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etarget = 11, nums = [1,1,1,1,1,1,1,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= target \u003c= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= nums.length \u003c= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= nums[i] \u003c= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e如果你已经实现\u003cem\u003e \u003c/em\u003e\u003ccode\u003eO(n)\u003c/code\u003e 时间复杂度的解法, 请尝试设计一个 \u003ccode\u003eO(n log(n))\u003c/code\u003e 时间复杂度的解法。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "长度最小的子数组"
  },
  "missing-number": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "missing-ranges": {
   "content": "\u003cp\u003eYou are given an inclusive range \u003ccode\u003e[lower, upper]\u003c/code\u003e and a \u003cstrong\u003esorted unique\u003c/strong\u003e integer array \u003ccode\u003enums\u003c/code\u003e, where all elements are in the inclusive range.\u003c/p\u003e\n\n\u003cp\u003eA number \u003ccode\u003ex\u003c/code\u003e is considered \u003cstrong\u003emissing\u003c/strong\u003e if \u003ccode\u003ex\u003c/code\u003e is in the range \u003ccode\u003e[lower, upper]\u003c/code\u003e and \u003ccode\u003ex\u003c/code\u003e is not in \u003ccode\u003enums\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe \u003cstrong\u003esmallest sorted\u003c/strong\u003e list of ranges that \u003cstrong\u003ecover every missing number exactly\u003c/strong\u003e\u003c/em\u003e. That is, no element of \u003ccode\u003enums\u003c/code\u003e is in any of the ranges, and each missing number is in one of the ranges.\u003c/p\u003e\n\n\u003cp\u003eEach range \u003ccode\u003e[a,b]\u003c/code\u003e in the list should be output as:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e\u0026quot;a-\u0026gt;b\u0026quot;\u003c/code\u003e if \u003ccode\u003ea != b\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e\u0026quot;a\u0026quot;\u003c/code\u003e if \u003ccode\u003ea == b\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0,1,3,50,75], lower = 0, upper = 99\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\u0026quot;2\u0026quot;,\u0026quot;4-\u0026gt;49\u0026quot;,\u0026quot;51-\u0026gt;74\u0026quot;,\u0026quot;76-\u0026gt;99\u0026quot;]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The ranges are:\n[2,2] --\u0026gt; \u0026quot;2\u0026quot;\n[4,49] --\u0026gt; \u0026quot;4-\u0026gt;49\u0026quot;\n[51,74] --\u0026gt; \u0026quot;51-\u0026gt;74\u0026quot;\n[76,99] --\u0026gt; \u0026quot;76-\u0026gt;99\u0026quot;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [-1], lower = -1, upper = -1\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are no missing ranges since there are no missing numbers.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e9\u003c/sup\u003e \u0026lt;= lower \u0026lt;= upper \u0026lt;= 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003elower \u0026lt;= nums[i] \u0026lt;= upper\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the values of \u003ccode\u003enums\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "163",
   "similarQuestions": "[{\"title\": \"Summary Ranges\", \"titleSlug\": \"summary-ranges\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6c47\\u603b\\u533a\\u95f4\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个排序的整数数组 \u003cem\u003e\u003cstrong\u003enums\u0026nbsp;\u003c/strong\u003e\u003c/em\u003e，其中元素的范围在\u0026nbsp;\u003cstrong\u003e闭区间\u003c/strong\u003e\u0026nbsp;\u003cstrong\u003e[\u003cem\u003elower, upper\u003c/em\u003e]\u003c/strong\u003e\u0026nbsp;当中，返回不包含在数组中的缺失区间。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入: \u003c/strong\u003e\u003cstrong\u003e\u003cem\u003enums\u003c/em\u003e\u003c/strong\u003e = \u003ccode\u003e[0, 1, 3, 50, 75]\u003c/code\u003e, \u003cstrong\u003e\u003cem\u003elower\u003c/em\u003e\u003c/strong\u003e = 0 和 \u003cstrong\u003e\u003cem\u003eupper\u003c/em\u003e\u003c/strong\u003e = 99,\n\u003cstrong\u003e输出: \u003c/strong\u003e\u003ccode\u003e[\u0026quot;2\u0026quot;, \u0026quot;4-\u0026gt;49\u0026quot;, \u0026quot;51-\u0026gt;74\u0026quot;, \u0026quot;76-\u0026gt;99\u0026quot;]\u003c/code\u003e\n\u003c/pre\u003e\n",
   "translatedTitle": "缺失的区间"
  },
  "most-common-word": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "move-zeroes": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e, move all \u003ccode\u003e0\u003c/code\u003e\u0026#39;s to the end of it while maintaining the relative order of the non-zero elements.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that you must do this in-place without making a copy of the array.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0,1,0,3,12]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,3,12,0,0]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you minimize the total number of operations done?",
   "hints": [
    "\u003cb\u003eIn-place\u003c/b\u003e means we should not be allocating any space for extra array. But we are allowed to modify the existing array. However, as a first step, try coming up with a solution that makes use of additional space. For this problem as well, first apply the idea discussed using an additional array and the in-place solution will pop up eventually.",
    "A \u003cb\u003etwo-pointer\u003c/b\u003e approach could be helpful here. The idea would be to have one pointer for iterating the array and another pointer that just works on the non-zero elements of the array."
   ],
   "questionId": "283",
   "similarQuestions": "[{\"title\": \"Remove Element\", \"titleSlug\": \"remove-element\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u79fb\\u9664\\u5143\\u7d20\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个数组 \u003ccode\u003enums\u003c/code\u003e，编写一个函数将所有 \u003ccode\u003e0\u003c/code\u003e 移动到数组的末尾，同时保持非零元素的相对顺序。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e请注意\u003c/strong\u003e\u0026nbsp;，必须在不复制数组的情况下原地对数组进行操作。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = \u003ccode\u003e[0,1,0,3,12]\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e \u003ccode\u003e[1,3,12,0,0]\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = \u003ccode\u003e[0]\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e \u003ccode\u003e[0]\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示\u003c/strong\u003e:\u003c/p\u003e\n\u003cmeta charset=\"UTF-8\" /\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e\u0026nbsp;\u0026lt;= nums[i] \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e\u0026nbsp;- 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e进阶：\u003c/b\u003e你能尽量减少完成的操作次数吗？\u003c/p\u003e\n",
   "translatedTitle": "移动零"
  },
  "moving-average-from-data-stream": {
   "content": "\u003cp\u003eGiven a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\u003c/p\u003e\n\n\u003cp\u003eImplement the\u0026nbsp;\u003ccode\u003eMovingAverage\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eMovingAverage(int size)\u003c/code\u003e Initializes\u0026nbsp;the object with the size of the window \u003ccode\u003esize\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003edouble next(int val)\u003c/code\u003e Returns the moving average of the last \u003ccode\u003esize\u003c/code\u003e values of the stream.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput\u003c/strong\u003e\n[\u0026quot;MovingAverage\u0026quot;, \u0026quot;next\u0026quot;, \u0026quot;next\u0026quot;, \u0026quot;next\u0026quot;, \u0026quot;next\u0026quot;]\n[[3], [1], [10], [3], [5]]\n\u003cstrong\u003eOutput\u003c/strong\u003e\n[null, 1.0, 5.5, 4.66667, 6.0]\n\n\u003cstrong\u003eExplanation\u003c/strong\u003e\nMovingAverage movingAverage = new MovingAverage(3);\nmovingAverage.next(1); // return 1.0 = 1 / 1\nmovingAverage.next(10); // return 5.5 = (1 + 10) / 2\nmovingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3\nmovingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= size \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e \u0026lt;= val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAt most \u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e calls will be made to \u003ccode\u003enext\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "346",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "Queue",
     "slug": "queue",
     "translatedName": "队列"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Data Stream",
     "slug": "data-stream",
     "translatedName": "数据流"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算其所有整数的移动平均值。\u003c/p\u003e\n\n\u003cp\u003e实现 \u003ccode\u003eMovingAverage\u003c/code\u003e 类：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eMovingAverage(int size)\u003c/code\u003e 用窗口大小 \u003ccode\u003esize\u003c/code\u003e 初始化对象。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003edouble next(int val)\u003c/code\u003e 计算并返回数据流中最后 \u003ccode\u003esize\u003c/code\u003e 个值的移动平均值。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e\n[\"MovingAverage\", \"next\", \"next\", \"next\", \"next\"]\n[[3], [1], [10], [3], [5]]\n\u003cstrong\u003e输出：\u003c/strong\u003e\n[null, 1.0, 5.5, 4.66667, 6.0]\n\n\u003cstrong\u003e解释：\u003c/strong\u003e\nMovingAverage movingAverage = new MovingAverage(3);\nmovingAverage.next(1); // 返回 1.0 = 1 / 1\nmovingAverage.next(10); // 返回 5.5 = (1 + 10) / 2\nmovingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3\nmovingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= size \u003c= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e \u003c= val \u003c= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e最多调用 \u003ccode\u003enext\u003c/code\u003e 方法 \u003ccode\u003e10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e 次\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "数据流中的移动平均值"
  },
  "multiply-strings": {
   "content": "\u003cp\u003eGiven two non-negative integers \u003ccode\u003enum1\u003c/code\u003e and \u003ccode\u003enum2\u003c/code\u003e represented as strings, return the product of \u003ccode\u003enum1\u003c/code\u003e and \u003ccode\u003enum2\u003c/code\u003e, also represented as a string.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u0026nbsp;You must not use any built-in BigInteger library or convert the inputs to integer directly.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e num1 = \"2\", num2 = \"3\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"6\"\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e num1 = \"123\", num2 = \"456\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"56088\"\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= num1.length, num2.length \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enum1\u003c/code\u003e and \u003ccode\u003enum2\u003c/code\u003e consist of digits only.\u003c/li\u003e\n\t\u003cli\u003eBoth \u003ccode\u003enum1\u003c/code\u003e and \u003ccode\u003enum2\u003c/code\u003e\u0026nbsp;do not contain any leading zero, except the number \u003ccode\u003e0\u003c/code\u003e itself.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "43",
   "similarQuestions": "[{\"title\": \"Add Two Numbers\", \"titleSlug\": \"add-two-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e24\\u6570\\u76f8\\u52a0\"}, {\"title\": \"Plus One\", \"titleSlug\": \"plus-one\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u52a0\\u4e00\"}, {\"title\": \"Add Binary\", \"titleSlug\": \"add-binary\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u8fdb\\u5236\\u6c42\\u548c\"}, {\"title\": \"Add Strings\", \"titleSlug\": \"add-strings\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5b57\\u7b26\\u4e32\\u76f8\\u52a0\"}]",
   "topicTags": [
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Simulation",
     "slug": "simulation",
     "translatedName": "模拟"
    }
   ],
   "translatedContent": "\u003cp\u003e给定两个以字符串形式表示的非负整数\u0026nbsp;\u003ccode\u003enum1\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003enum2\u003c/code\u003e，返回\u0026nbsp;\u003ccode\u003enum1\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003enum2\u003c/code\u003e\u0026nbsp;的乘积，它们的乘积也表示为字符串形式。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e不能使用任何内置的 BigInteger 库或直接将输入转换为整数。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e num1 = \"2\", num2 = \"3\"\n\u003cstrong\u003e输出:\u003c/strong\u003e \"6\"\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e num1 = \"123\", num2 = \"456\"\n\u003cstrong\u003e输出:\u003c/strong\u003e \"56088\"\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= num1.length, num2.length \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enum1\u003c/code\u003e\u0026nbsp;和 \u003ccode\u003enum2\u003c/code\u003e\u0026nbsp;只能由数字组成。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enum1\u003c/code\u003e\u0026nbsp;和 \u003ccode\u003enum2\u003c/code\u003e\u0026nbsp;都不包含任何前导零，除了数字0本身。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "字符串相乘"
  },
  "n-ary-tree-level-order-traversal": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "n-ary-tree-preorder-traversal": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "n-th-tribonacci-number": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "next-greater-element-i": {
   "content": "\u003cp\u003eThe \u003cstrong\u003enext greater element\u003c/strong\u003e of some element \u003ccode\u003ex\u003c/code\u003e in an array is the \u003cstrong\u003efirst greater\u003c/strong\u003e element that is \u003cstrong\u003eto the right\u003c/strong\u003e of \u003ccode\u003ex\u003c/code\u003e in the same array.\u003c/p\u003e\n\n\u003cp\u003eYou are given two \u003cstrong\u003edistinct 0-indexed\u003c/strong\u003e integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, where \u003ccode\u003enums1\u003c/code\u003e is a subset of \u003ccode\u003enums2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFor each \u003ccode\u003e0 \u0026lt;= i \u0026lt; nums1.length\u003c/code\u003e, find the index \u003ccode\u003ej\u003c/code\u003e such that \u003ccode\u003enums1[i] == nums2[j]\u003c/code\u003e and determine the \u003cstrong\u003enext greater element\u003c/strong\u003e of \u003ccode\u003enums2[j]\u003c/code\u003e in \u003ccode\u003enums2\u003c/code\u003e. If there is no next greater element, then the answer for this query is \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ean array \u003c/em\u003e\u003ccode\u003eans\u003c/code\u003e\u003cem\u003e of length \u003c/em\u003e\u003ccode\u003enums1.length\u003c/code\u003e\u003cem\u003e such that \u003c/em\u003e\u003ccode\u003eans[i]\u003c/code\u003e\u003cem\u003e is the \u003cstrong\u003enext greater element\u003c/strong\u003e as described above.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums1 = [4,1,2], nums2 = [1,3,4,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [-1,3,-1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,\u003cu\u003e4\u003c/u\u003e,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [\u003cu\u003e1\u003c/u\u003e,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,\u003cu\u003e2\u003c/u\u003e]. There is no next greater element, so the answer is -1.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums1 = [2,4], nums2 = [1,2,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [3,-1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,\u003cu\u003e2\u003c/u\u003e,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,\u003cu\u003e4\u003c/u\u003e]. There is no next greater element, so the answer is -1.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums1.length \u0026lt;= nums2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll integers in \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003eAll the integers of \u003ccode\u003enums1\u003c/code\u003e also appear in \u003ccode\u003enums2\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you find an \u003ccode\u003eO(nums1.length + nums2.length)\u003c/code\u003e solution?",
   "hints": [],
   "questionId": "496",
   "similarQuestions": "[{\"title\": \"Next Greater Element II\", \"titleSlug\": \"next-greater-element-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e0b\\u4e00\\u4e2a\\u66f4\\u5927\\u5143\\u7d20 II\"}, {\"title\": \"Next Greater Element III\", \"titleSlug\": \"next-greater-element-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e0b\\u4e00\\u4e2a\\u66f4\\u5927\\u5143\\u7d20 III\"}, {\"title\": \"Daily Temperatures\", \"titleSlug\": \"daily-temperatures\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6bcf\\u65e5\\u6e29\\u5ea6\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Monotonic Stack",
     "slug": "monotonic-stack",
     "translatedName": "单调栈"
    }
   ],
   "translatedContent": "\u003cp\u003e\u003ccode\u003enums1\u003c/code\u003e\u0026nbsp;中数字\u0026nbsp;\u003ccode\u003ex\u003c/code\u003e\u0026nbsp;的 \u003cstrong\u003e下一个更大元素\u003c/strong\u003e 是指\u0026nbsp;\u003ccode\u003ex\u003c/code\u003e\u0026nbsp;在\u0026nbsp;\u003ccode\u003enums2\u003c/code\u003e 中对应位置 \u003cstrong\u003e右侧\u003c/strong\u003e 的 \u003cstrong\u003e第一个\u003c/strong\u003e 比\u0026nbsp;\u003ccode\u003ex\u003c/code\u003e\u003cstrong\u003e\u0026nbsp;\u003c/strong\u003e大的元素。\u003c/p\u003e\n\n\u003cp\u003e给你两个\u003cstrong\u003e 没有重复元素\u003c/strong\u003e 的数组\u0026nbsp;\u003ccode\u003enums1\u003c/code\u003e 和\u0026nbsp;\u003ccode\u003enums2\u003c/code\u003e ，下标从 \u003cstrong\u003e0\u003c/strong\u003e 开始计数，其中\u003ccode\u003enums1\u003c/code\u003e\u0026nbsp;是\u0026nbsp;\u003ccode\u003enums2\u003c/code\u003e\u0026nbsp;的子集。\u003c/p\u003e\n\n\u003cp\u003e对于每个 \u003ccode\u003e0 \u0026lt;= i \u0026lt; nums1.length\u003c/code\u003e ，找出满足 \u003ccode\u003enums1[i] == nums2[j]\u003c/code\u003e 的下标 \u003ccode\u003ej\u003c/code\u003e ，并且在 \u003ccode\u003enums2\u003c/code\u003e 确定 \u003ccode\u003enums2[j]\u003c/code\u003e 的 \u003cstrong\u003e下一个更大元素\u003c/strong\u003e 。如果不存在下一个更大元素，那么本次查询的答案是 \u003ccode\u003e-1\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e返回一个长度为\u0026nbsp;\u003ccode\u003enums1.length\u003c/code\u003e 的数组\u003cem\u003e \u003c/em\u003e\u003ccode\u003eans\u003c/code\u003e\u003cem\u003e \u003c/em\u003e作为答案，满足\u003cem\u003e \u003c/em\u003e\u003ccode\u003eans[i]\u003c/code\u003e\u003cem\u003e \u003c/em\u003e是如上所述的 \u003cstrong\u003e下一个更大元素\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums1 = [4,1,2], nums2 = [1,3,4,2].\n\u003cstrong\u003e输出：\u003c/strong\u003e[-1,3,-1]\n\u003cstrong\u003e解释：\u003c/strong\u003enums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,\u003cstrong\u003e4\u003c/strong\u003e,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [\u003cem\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/em\u003e,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,\u003cem\u003e\u003cstrong\u003e2\u003c/strong\u003e\u003c/em\u003e]。不存在下一个更大元素，所以答案是 -1 。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums1 = [2,4], nums2 = [1,2,3,4].\n\u003cstrong\u003e输出：\u003c/strong\u003e[3,-1]\n\u003cstrong\u003e解释：\u003c/strong\u003enums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 = [1,\u003cem\u003e\u003cstrong\u003e2\u003c/strong\u003e\u003c/em\u003e,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 = [1,2,3,\u003cem\u003e\u003cstrong\u003e4\u003c/strong\u003e\u003c/em\u003e]。不存在下一个更大元素，所以答案是 -1 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums1.length \u0026lt;= nums2.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums1\u003c/code\u003e和\u003ccode\u003enums2\u003c/code\u003e中所有整数 \u003cstrong\u003e互不相同\u003c/strong\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums1\u003c/code\u003e 中的所有整数同样出现在 \u003ccode\u003enums2\u003c/code\u003e 中\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你可以设计一个时间复杂度为 \u003ccode\u003eO(nums1.length + nums2.length)\u003c/code\u003e 的解决方案吗？\u003c/p\u003e\n",
   "translatedTitle": "下一个更大元素 I"
  },
  "nim-game": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "number-complement": {
   "content": "\u003cp\u003eThe \u003cstrong\u003ecomplement\u003c/strong\u003e of an integer is the integer you get when you flip all the \u003ccode\u003e0\u003c/code\u003e\u0026#39;s to \u003ccode\u003e1\u003c/code\u003e\u0026#39;s and all the \u003ccode\u003e1\u003c/code\u003e\u0026#39;s to \u003ccode\u003e0\u003c/code\u003e\u0026#39;s in its binary representation.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, The integer \u003ccode\u003e5\u003c/code\u003e is \u003ccode\u003e\u0026quot;101\u0026quot;\u003c/code\u003e in binary and its \u003cstrong\u003ecomplement\u003c/strong\u003e is \u003ccode\u003e\u0026quot;010\u0026quot;\u003c/code\u003e which is the integer \u003ccode\u003e2\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eGiven an integer \u003ccode\u003enum\u003c/code\u003e, return \u003cem\u003eits complement\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e num = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e num = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= num \u0026lt; 2\u003csup\u003e31\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This question is the same as 1009: \u003ca href=\"https://leetcode.com/problems/complement-of-base-10-integer/\" target=\"_blank\"\u003ehttps://leetcode.com/problems/complement-of-base-10-integer/\u003c/a\u003e\u003c/p\u003e\n",
   "hints": [],
   "questionId": "476",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    }
   ],
   "translatedContent": "\u003cp\u003e对整数的二进制表示取反（\u003ccode\u003e0\u003c/code\u003e 变 \u003ccode\u003e1\u003c/code\u003e ，\u003ccode\u003e1\u003c/code\u003e 变 \u003ccode\u003e0\u003c/code\u003e）后，再转换为十进制表示，可以得到这个整数的补数。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e例如，整数 \u003ccode\u003e5\u003c/code\u003e 的二进制表示是 \u003ccode\u003e\"101\"\u003c/code\u003e ，取反后得到 \u003ccode\u003e\"010\"\u003c/code\u003e ，再转回十进制表示得到补数 \u003ccode\u003e2\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e给你一个整数 \u003ccode\u003enum\u003c/code\u003e ，输出它的补数。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003col\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enum = 5\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enum = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003cstrong\u003e解释：\u003c/strong\u003e1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= num \u0026lt; 2\u003csup\u003e31\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e本题与 1009 \u003ca href=\"https://leetcode-cn.com/problems/complement-of-base-10-integer/\"\u003ehttps://leetcode-cn.com/problems/complement-of-base-10-integer/\u003c/a\u003e 相同\u003c/p\u003e\n",
   "translatedTitle": "数字的补数"
  },
  "number-of-1-bits": {
   "content": "\u003cp\u003eWrite a function that takes an unsigned integer and returns the number of \u0026#39;1\u0026#39; bits it has (also known as the \u003ca href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\"\u003eHamming weight\u003c/a\u003e).\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eNote that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer\u0026#39;s internal binary representation is the same, whether it is signed or unsigned.\u003c/li\u003e\n\t\u003cli\u003eIn Java, the compiler represents the signed integers using \u003ca href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\"\u003e2\u0026#39;s complement notation\u003c/a\u003e. Therefore, in \u003cstrong\u003eExample 3\u003c/strong\u003e, the input represents the signed integer. \u003ccode\u003e-3\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 00000000000000000000000000001011\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The input binary string \u003cstrong\u003e00000000000000000000000000001011\u003c/strong\u003e has a total of three \u0026#39;1\u0026#39; bits.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 00000000000000000000000010000000\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The input binary string \u003cstrong\u003e00000000000000000000000010000000\u003c/strong\u003e has a total of one \u0026#39;1\u0026#39; bit.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 11111111111111111111111111111101\n\u003cstrong\u003eOutput:\u003c/strong\u003e 31\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The input binary string \u003cstrong\u003e11111111111111111111111111111101\u003c/strong\u003e has a total of thirty one \u0026#39;1\u0026#39; bits.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe input must be a \u003cstrong\u003ebinary string\u003c/strong\u003e of length \u003ccode\u003e32\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e If this function is called many times, how would you optimize it?",
   "hints": [],
   "questionId": "191",
   "similarQuestions": "[{\"title\": \"Reverse Bits\", \"titleSlug\": \"reverse-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u98a0\\u5012\\u4e8c\\u8fdb\\u5236\\u4f4d\"}, {\"title\": \"Power of Two\", \"titleSlug\": \"power-of-two\", \"difficulty\": \"Easy\", \"translatedTitle\": \"2 \\u7684\\u5e42\"}, {\"title\": \"Counting Bits\", \"titleSlug\": \"counting-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6bd4\\u7279\\u4f4d\\u8ba1\\u6570\"}, {\"title\": \"Binary Watch\", \"titleSlug\": \"binary-watch\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u8fdb\\u5236\\u624b\\u8868\"}, {\"title\": \"Hamming Distance\", \"titleSlug\": \"hamming-distance\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6c49\\u660e\\u8ddd\\u79bb\"}, {\"title\": \"Binary Number with Alternating Bits\", \"titleSlug\": \"binary-number-with-alternating-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4ea4\\u66ff\\u4f4d\\u4e8c\\u8fdb\\u5236\\u6570\"}, {\"title\": \"Prime Number of Set Bits in Binary Representation\", \"titleSlug\": \"prime-number-of-set-bits-in-binary-representation\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u8fdb\\u5236\\u8868\\u793a\\u4e2d\\u8d28\\u6570\\u4e2a\\u8ba1\\u7b97\\u7f6e\\u4f4d\"}]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    }
   ],
   "translatedContent": "\u003cp\u003e编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为\u003ca href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F\" target=\"_blank\"\u003e汉明重量\u003c/a\u003e）。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\u003c/li\u003e\n\t\u003cli\u003e在 Java 中，编译器使用\u003ca href=\"https://baike.baidu.com/item/二进制补码/5295284\" target=\"_blank\"\u003e二进制补码\u003c/a\u003e记法来表示有符号整数。因此，在上面的 \u003cstrong\u003e示例 3\u003c/strong\u003e 中，输入表示有符号整数 \u003ccode\u003e-3\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e00000000000000000000000000001011\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e输入的二进制串 \u003ccode\u003e\u003cstrong\u003e00000000000000000000000000001011\u003c/strong\u003e 中，共有三位为 '1'。\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e00000000000000000000000010000000\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003cstrong\u003e解释：\u003c/strong\u003e输入的二进制串 \u003cstrong\u003e00000000000000000000000010000000\u003c/strong\u003e 中，共有一位为 '1'。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e11111111111111111111111111111101\n\u003cstrong\u003e输出：\u003c/strong\u003e31\n\u003cstrong\u003e解释：\u003c/strong\u003e输入的二进制串 \u003cstrong\u003e11111111111111111111111111111101\u003c/strong\u003e 中，共有 31 位为 '1'。\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e输入必须是长度为 \u003ccode\u003e32\u003c/code\u003e 的 \u003cstrong\u003e二进制串\u003c/strong\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cul\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e如果多次调用这个函数，你将如何优化你的算法？\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "位1的个数"
  },
  "number-of-enclaves": {
   "content": "\u003cp\u003eYou are given an \u003ccode\u003em x n\u003c/code\u003e binary matrix \u003ccode\u003egrid\u003c/code\u003e, where \u003ccode\u003e0\u003c/code\u003e represents a sea cell and \u003ccode\u003e1\u003c/code\u003e represents a land cell.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003emove\u003c/strong\u003e consists of walking from one land cell to another adjacent (\u003cstrong\u003e4-directionally\u003c/strong\u003e) land cell or walking off the boundary of the \u003ccode\u003egrid\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe number of land cells in\u003c/em\u003e \u003ccode\u003egrid\u003c/code\u003e \u003cem\u003efor which we cannot walk off the boundary of the grid in any number of \u003cstrong\u003emoves\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg\" style=\"width: 333px; height: 333px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg\" style=\"width: 333px; height: 333px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003cstrong\u003eExplanation:\u003c/strong\u003e All 1s are either on the boundary or can reach the boundary.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == grid.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == grid[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003egrid[i][j]\u003c/code\u003e is either \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e1\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Can you model this problem as a graph problem?  Create n * m + 1 nodes where n * m nodes represents each cell of the map and one extra node to represent the exterior of the map.",
    "In the map add edges between neighbors on land cells. And add edges between the exterior and land nodes which are in the boundary.\r\nReturn as answer the number of nodes that are not reachable from the exterior node."
   ],
   "questionId": "1073",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Union Find",
     "slug": "union-find",
     "translatedName": "并查集"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个大小为 \u003ccode\u003em x n\u003c/code\u003e 的二进制矩阵 \u003ccode\u003egrid\u003c/code\u003e ，其中 \u003ccode\u003e0\u003c/code\u003e 表示一个海洋单元格、\u003ccode\u003e1\u003c/code\u003e 表示一个陆地单元格。\u003c/p\u003e\n\n\u003cp\u003e一次 \u003cstrong\u003e移动\u003c/strong\u003e 是指从一个陆地单元格走到另一个相邻（\u003cstrong\u003e上、下、左、右\u003c/strong\u003e）的陆地单元格或跨过 \u003ccode\u003egrid\u003c/code\u003e 的边界。\u003c/p\u003e\n\n\u003cp\u003e返回网格中\u003cstrong\u003e 无法 \u003c/strong\u003e在任意次数的移动中离开网格边界的陆地单元格的数量。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg\" style=\"height: 200px; width: 200px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003egrid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg\" style=\"height: 200px; width: 200px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003egrid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n\u003cstrong\u003e输出：\u003c/strong\u003e0\n\u003cstrong\u003e解释：\u003c/strong\u003e所有 1 都在边界上或可以到达边界。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == grid.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == grid[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 500\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003egrid[i][j]\u003c/code\u003e 的值为 \u003ccode\u003e0\u003c/code\u003e 或 \u003ccode\u003e1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "飞地的数量"
  },
  "number-of-islands": {
   "content": "\u003cp\u003eGiven an \u003ccode\u003em x n\u003c/code\u003e 2D binary grid \u003ccode\u003egrid\u003c/code\u003e which represents a map of \u003ccode\u003e\u0026#39;1\u0026#39;\u003c/code\u003es (land) and \u003ccode\u003e\u0026#39;0\u0026#39;\u003c/code\u003es (water), return \u003cem\u003ethe number of islands\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eAn \u003cstrong\u003eisland\u003c/strong\u003e is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e grid = [\n  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;],\n  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;],\n  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],\n  [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;]\n]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e grid = [\n  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],\n  [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],\n  [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],\n  [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;]\n]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == grid.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == grid[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 300\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003egrid[i][j]\u003c/code\u003e is \u003ccode\u003e\u0026#39;0\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;1\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "200",
   "similarQuestions": "[{\"title\": \"Surrounded Regions\", \"titleSlug\": \"surrounded-regions\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u88ab\\u56f4\\u7ed5\\u7684\\u533a\\u57df\"}, {\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5899\\u4e0e\\u95e8\"}, {\"title\": \"Number of Islands II\", \"titleSlug\": \"number-of-islands-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u5c9b\\u5c7f\\u6570\\u91cf II\"}, {\"title\": \"Number of Connected Components in an Undirected Graph\", \"titleSlug\": \"number-of-connected-components-in-an-undirected-graph\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u65e0\\u5411\\u56fe\\u4e2d\\u8fde\\u901a\\u5206\\u91cf\\u7684\\u6570\\u76ee\"}, {\"title\": \"Number of Distinct Islands\", \"titleSlug\": \"number-of-distinct-islands\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e0d\\u540c\\u5c9b\\u5c7f\\u7684\\u6570\\u91cf\"}, {\"title\": \"Max Area of Island\", \"titleSlug\": \"max-area-of-island\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5c9b\\u5c7f\\u7684\\u6700\\u5927\\u9762\\u79ef\"}]",
   "topicTags": [
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Union Find",
     "slug": "union-find",
     "translatedName": "并查集"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个由 \u003ccode\u003e'1'\u003c/code\u003e（陆地）和 \u003ccode\u003e'0'\u003c/code\u003e（水）组成的的二维网格，请你计算网格中岛屿的数量。\u003c/p\u003e\n\n\u003cp\u003e岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\u003c/p\u003e\n\n\u003cp\u003e此外，你可以假设该网格的四条边均被水包围。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003egrid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003egrid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == grid.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == grid[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= m, n \u003c= 300\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003egrid[i][j]\u003c/code\u003e 的值为 \u003ccode\u003e'0'\u003c/code\u003e 或 \u003ccode\u003e'1'\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "岛屿数量"
  },
  "number-of-matching-subsequences": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e and an array of strings \u003ccode\u003ewords\u003c/code\u003e, return \u003cem\u003ethe number of\u003c/em\u003e \u003ccode\u003ewords[i]\u003c/code\u003e \u003cem\u003ethat is a subsequence of\u003c/em\u003e \u003ccode\u003es\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003esubsequence\u003c/strong\u003e of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, \u003ccode\u003e\u0026quot;ace\u0026quot;\u003c/code\u003e is a subsequence of \u003ccode\u003e\u0026quot;abcde\u0026quot;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;abcde\u0026quot;, words = [\u0026quot;a\u0026quot;,\u0026quot;bb\u0026quot;,\u0026quot;acd\u0026quot;,\u0026quot;ace\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are three strings in words that are a subsequence of s: \u0026quot;a\u0026quot;, \u0026quot;acd\u0026quot;, \u0026quot;ace\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;dsahjpjauf\u0026quot;, words = [\u0026quot;ahjpjau\u0026quot;,\u0026quot;ja\u0026quot;,\u0026quot;ahbwzgqnuk\u0026quot;,\u0026quot;tnmlanowax\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= words.length \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= words[i].length \u0026lt;= 50\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e and \u003ccode\u003ewords[i]\u003c/code\u003e consist of only lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "808",
   "similarQuestions": "[{\"title\": \"Is Subsequence\", \"titleSlug\": \"is-subsequence\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5224\\u65ad\\u5b50\\u5e8f\\u5217\"}]",
   "topicTags": [
    {
     "name": "Trie",
     "slug": "trie",
     "translatedName": "字典树"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给定字符串 \u003ccode\u003es\u003c/code\u003e\u0026nbsp;和字符串数组\u0026nbsp;\u003ccode\u003ewords\u003c/code\u003e, 返回\u0026nbsp;\u0026nbsp;\u003cem\u003e\u003ccode\u003ewords[i]\u003c/code\u003e\u0026nbsp;中是\u003ccode\u003es\u003c/code\u003e的子序列的单词个数\u003c/em\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e字符串的 \u003cstrong\u003e子序列\u003c/strong\u003e 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e例如， \u003ccode\u003e“ace”\u003c/code\u003e 是 \u003ccode\u003e“abcde”\u003c/code\u003e 的子序列。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\n\u003cstrong\u003e输出:\u003c/strong\u003e 3\n\u003cstrong\u003e解释:\u003c/strong\u003e 有三个是\u0026nbsp;s 的子序列的单词: \"a\", \"acd\", \"ace\"。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003es = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\n\u003cstrong\u003e输出:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 5 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= words.length \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= words[i].length \u0026lt;= 50\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ewords[i]\u003c/code\u003e和 \u003cfont color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"\u003e\u003cspan style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\"\u003es\u003c/span\u003e\u003c/font\u003e\u0026nbsp;都只由小写字母组成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cspan style=\"display:block\"\u003e\u003cspan style=\"height:0px\"\u003e\u003cspan style=\"position:absolute\"\u003e​​​​\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e",
   "translatedTitle": "匹配子序列的单词数"
  },
  "number-of-provinces": {
   "content": "\u003cp\u003eThere are \u003ccode\u003en\u003c/code\u003e cities. Some of them are connected, while some are not. If city \u003ccode\u003ea\u003c/code\u003e is connected directly with city \u003ccode\u003eb\u003c/code\u003e, and city \u003ccode\u003eb\u003c/code\u003e is connected directly with city \u003ccode\u003ec\u003c/code\u003e, then city \u003ccode\u003ea\u003c/code\u003e is connected indirectly with city \u003ccode\u003ec\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003eprovince\u003c/strong\u003e is a group of directly or indirectly connected cities and no other cities outside of the group.\u003c/p\u003e\n\n\u003cp\u003eYou are given an \u003ccode\u003en x n\u003c/code\u003e matrix \u003ccode\u003eisConnected\u003c/code\u003e where \u003ccode\u003eisConnected[i][j] = 1\u003c/code\u003e if the \u003ccode\u003ei\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e city and the \u003ccode\u003ej\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e city are directly connected, and \u003ccode\u003eisConnected[i][j] = 0\u003c/code\u003e otherwise.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe total number of \u003cstrong\u003eprovinces\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" style=\"width: 222px; height: 142px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" style=\"width: 222px; height: 142px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == isConnected.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == isConnected[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eisConnected[i][j]\u003c/code\u003e is \u003ccode\u003e1\u003c/code\u003e or \u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eisConnected[i][i] == 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eisConnected[i][j] == isConnected[j][i]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "547",
   "similarQuestions": "[{\"title\": \"Number of Connected Components in an Undirected Graph\", \"titleSlug\": \"number-of-connected-components-in-an-undirected-graph\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u65e0\\u5411\\u56fe\\u4e2d\\u8fde\\u901a\\u5206\\u91cf\\u7684\\u6570\\u76ee\"}, {\"title\": \"Robot Return to Origin\", \"titleSlug\": \"robot-return-to-origin\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u673a\\u5668\\u4eba\\u80fd\\u5426\\u8fd4\\u56de\\u539f\\u70b9\"}, {\"title\": \"Sentence Similarity\", \"titleSlug\": \"sentence-similarity\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u53e5\\u5b50\\u76f8\\u4f3c\\u6027\"}, {\"title\": \"Sentence Similarity II\", \"titleSlug\": \"sentence-similarity-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u53e5\\u5b50\\u76f8\\u4f3c\\u6027 II\"}, {\"title\": \"The Earliest Moment When Everyone Become Friends\", \"titleSlug\": \"the-earliest-moment-when-everyone-become-friends\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5f7c\\u6b64\\u719f\\u8bc6\\u7684\\u6700\\u65e9\\u65f6\\u95f4\"}]",
   "topicTags": [
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Union Find",
     "slug": "union-find",
     "translatedName": "并查集"
    },
    {
     "name": "Graph",
     "slug": "graph",
     "translatedName": "图"
    }
   ],
   "translatedContent": "\u003cdiv class=\"original__bRMd\"\u003e\n\u003cdiv\u003e\n\u003cp\u003e有 \u003ccode\u003en\u003c/code\u003e 个城市，其中一些彼此相连，另一些没有相连。如果城市 \u003ccode\u003ea\u003c/code\u003e 与城市 \u003ccode\u003eb\u003c/code\u003e 直接相连，且城市 \u003ccode\u003eb\u003c/code\u003e 与城市 \u003ccode\u003ec\u003c/code\u003e 直接相连，那么城市 \u003ccode\u003ea\u003c/code\u003e 与城市 \u003ccode\u003ec\u003c/code\u003e 间接相连。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e省份\u003c/strong\u003e 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\u003c/p\u003e\n\n\u003cp\u003e给你一个 \u003ccode\u003en x n\u003c/code\u003e 的矩阵 \u003ccode\u003eisConnected\u003c/code\u003e ，其中 \u003ccode\u003eisConnected[i][j] = 1\u003c/code\u003e 表示第 \u003ccode\u003ei\u003c/code\u003e 个城市和第 \u003ccode\u003ej\u003c/code\u003e 个城市直接相连，而 \u003ccode\u003eisConnected[i][j] = 0\u003c/code\u003e 表示二者不直接相连。\u003c/p\u003e\n\n\u003cp\u003e返回矩阵中 \u003cstrong\u003e省份\u003c/strong\u003e 的数量。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" style=\"width: 222px; height: 142px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eisConnected = [[1,1,0],[1,1,0],[0,0,1]]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" style=\"width: 222px; height: 142px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eisConnected = [[1,0,0],[0,1,0],[0,0,1]]\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= n \u003c= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == isConnected.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == isConnected[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eisConnected[i][j]\u003c/code\u003e 为 \u003ccode\u003e1\u003c/code\u003e 或 \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eisConnected[i][i] == 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eisConnected[i][j] == isConnected[j][i]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n",
   "translatedTitle": "省份数量"
  },
  "number-of-recent-calls": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "number-of-segments-in-a-string": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "occurrences-after-bigram": {
   "content": "\u003cp\u003eGiven two strings \u003ccode\u003efirst\u003c/code\u003e and \u003ccode\u003esecond\u003c/code\u003e, consider occurrences in some text of the form \u003ccode\u003e\u0026quot;first second third\u0026quot;\u003c/code\u003e, where \u003ccode\u003esecond\u003c/code\u003e comes immediately after \u003ccode\u003efirst\u003c/code\u003e, and \u003ccode\u003ethird\u003c/code\u003e comes immediately after \u003ccode\u003esecond\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ean array of all the words\u003c/em\u003e \u003ccode\u003ethird\u003c/code\u003e \u003cem\u003efor each occurrence of\u003c/em\u003e \u003ccode\u003e\u0026quot;first second third\u0026quot;\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\"girl\",\"student\"]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e text = \"we will we will rock you\", first = \"we\", second = \"will\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e [\"we\",\"rock\"]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= text.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etext\u003c/code\u003e consists of lowercase English letters and spaces.\u003c/li\u003e\n\t\u003cli\u003eAll the words in \u003ccode\u003etext\u003c/code\u003e a separated by \u003cstrong\u003ea single space\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= first.length, second.length \u0026lt;= 10\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003efirst\u003c/code\u003e and \u003ccode\u003esecond\u003c/code\u003e consist of lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Split the string into words, then look at adjacent triples of words."
   ],
   "questionId": "1156",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给出第一个词\u0026nbsp;\u003ccode\u003efirst\u003c/code\u003e 和第二个词\u0026nbsp;\u003ccode\u003esecond\u003c/code\u003e，考虑在某些文本\u0026nbsp;\u003ccode\u003etext\u003c/code\u003e\u0026nbsp;中可能以 \u003ccode\u003e\"first second third\"\u003c/code\u003e 形式出现的情况，其中\u0026nbsp;\u003ccode\u003esecond\u003c/code\u003e\u0026nbsp;紧随\u0026nbsp;\u003ccode\u003efirst\u003c/code\u003e\u0026nbsp;出现，\u003ccode\u003ethird\u003c/code\u003e\u0026nbsp;紧随\u0026nbsp;\u003ccode\u003esecond\u003c/code\u003e\u0026nbsp;出现。\u003c/p\u003e\n\n\u003cp\u003e对于每种这样的情况，将第三个词 \"\u003ccode\u003ethird\u003c/code\u003e\" 添加到答案中，并返回答案。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etext = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n\u003cstrong\u003e输出：\u003c/strong\u003e[\"girl\",\"student\"]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003etext = \"we will we will rock you\", first = \"we\", second = \"will\"\n\u003cstrong\u003e输出：\u003c/strong\u003e[\"we\",\"rock\"]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= text.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etext\u003c/code\u003e\u0026nbsp;由小写英文字母和空格组成\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003etext\u003c/code\u003e 中的所有单词之间都由 \u003cstrong\u003e单个空格字符\u003c/strong\u003e 分隔\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= first.length, second.length \u0026lt;= 10\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003efirst\u003c/code\u003e 和\u0026nbsp;\u003ccode\u003esecond\u003c/code\u003e\u0026nbsp;由小写英文字母组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "Bigram 分词"
  },
  "odd-even-linked-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "one-edit-distance": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "opLdQZ": {
   "content": "\u003cp\u003eEnglish description is not available for the problem. Please switch to Chinese.\u003c/p\u003e",
   "hints": [],
   "questionId": "1000319",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个二叉搜索树的 \u003cstrong\u003e根节点\u003c/strong\u003e \u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;和一个整数 \u003ccode\u003ek\u003c/code\u003e , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 \u003ccode\u003ek\u003c/code\u003e 。假设二叉搜索树中节点的值均唯一。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003eroot =\u003cstrong\u003e \u003c/strong\u003e[8,6,10,5,7,9,11], k = 12\n\u003cstrong\u003e输出: \u003c/strong\u003etrue\n\u003cstrong\u003e解释: \u003c/strong\u003e节点 5 和节点 7 之和等于 12\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003eroot =\u003cstrong\u003e \u003c/strong\u003e[8,6,10,5,7,9,11], k = 22\n\u003cstrong\u003e输出: \u003c/strong\u003efalse\n\u003cstrong\u003e解释: \u003c/strong\u003e不存在两个节点值之和为 22 的节点\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e二叉树的节点个数的范围是\u0026nbsp;\u0026nbsp;\u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e\u0026nbsp;\u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;为二叉搜索树\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e\u0026nbsp;\u0026lt;= k \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e注意：本题与主站 653 题相同：\u0026nbsp;\u003ca href=\"https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/\"\u003ehttps://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/\u003c/a\u003e\u003c/p\u003e\n",
   "translatedTitle": "二叉搜索树中两个节点之和"
  },
  "palindrome-linked-list": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003ehead\u003c/code\u003e of a singly linked list, return \u003ccode\u003etrue\u003c/code\u003e if it is a palindrome.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg\" style=\"width: 422px; height: 62px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,2,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg\" style=\"width: 182px; height: 62px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is in the range \u003ccode\u003e[1, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you do it in \u003ccode\u003eO(n)\u003c/code\u003e time and \u003ccode\u003eO(1)\u003c/code\u003e space?",
   "hints": [],
   "questionId": "234",
   "similarQuestions": "[{\"title\": \"Palindrome Number\", \"titleSlug\": \"palindrome-number\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u56de\\u6587\\u6570\"}, {\"title\": \"Valid Palindrome\", \"titleSlug\": \"valid-palindrome\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u9a8c\\u8bc1\\u56de\\u6587\\u4e32\"}, {\"title\": \"Reverse Linked List\", \"titleSlug\": \"reverse-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u53cd\\u8f6c\\u94fe\\u8868\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个单链表的头节点 \u003ccode\u003ehead\u003c/code\u003e ，请你判断该链表是否为回文链表。如果是，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg\" style=\"width: 422px; height: 62px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,2,1]\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg\" style=\"width: 182px; height: 62px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2]\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点数目在范围\u003ccode\u003e[1, 10\u003csup\u003e5\u003c/sup\u003e]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你能否用\u0026nbsp;\u003ccode\u003eO(n)\u003c/code\u003e 时间复杂度和 \u003ccode\u003eO(1)\u003c/code\u003e 空间复杂度解决此题？\u003c/p\u003e\n",
   "translatedTitle": "回文链表"
  },
  "palindrome-number": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "palindrome-permutation": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if a permutation of the string could form a palindrome.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;code\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;aab\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;carerac\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consists of only lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Consider the palindromes of odd vs even length. What difference do you notice?",
    "Count the frequency of each character.",
    "If each character occurs even number of times, then it must be a palindrome. How about character which occurs odd number of times?"
   ],
   "questionId": "266",
   "similarQuestions": "[{\"title\": \"Longest Palindromic Substring\", \"titleSlug\": \"longest-palindromic-substring\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u957f\\u56de\\u6587\\u5b50\\u4e32\"}, {\"title\": \"Valid Anagram\", \"titleSlug\": \"valid-anagram\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6709\\u6548\\u7684\\u5b57\\u6bcd\\u5f02\\u4f4d\\u8bcd\"}, {\"title\": \"Palindrome Permutation II\", \"titleSlug\": \"palindrome-permutation-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u56de\\u6587\\u6392\\u5217 II\"}, {\"title\": \"Longest Palindrome\", \"titleSlug\": \"longest-palindrome\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6700\\u957f\\u56de\\u6587\\u4e32\"}]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个字符串，判断该字符串中是否可以通过重新排列组合，形成一个回文字符串。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003e\u0026quot;code\u0026quot;\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e false\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003e\u0026quot;aab\u0026quot;\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e true\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e \u003ccode\u003e\u0026quot;carerac\u0026quot;\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e true\u003c/pre\u003e\n",
   "translatedTitle": "回文排列"
  },
  "partition-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "pascals-triangle": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "path-sum": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree and an integer \u003ccode\u003etargetSum\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if the tree has a \u003cstrong\u003eroot-to-leaf\u003c/strong\u003e path such that adding up all the values along the path equals \u003ccode\u003etargetSum\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003eleaf\u003c/strong\u003e is a node with no children.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The root-to-leaf path with the target sum is shown.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3], targetSum = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There two root-to-leaf paths in the tree:\n(1 --\u0026gt; 2): The sum is 3.\n(1 --\u0026gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [], targetSum = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Since the tree is empty, there are no root-to-leaf paths.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 5000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= targetSum \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "112",
   "similarQuestions": "[{\"title\": \"Path Sum II\", \"titleSlug\": \"path-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u8def\\u5f84\\u603b\\u548c II\"}, {\"title\": \"Binary Tree Maximum Path Sum\", \"titleSlug\": \"binary-tree-maximum-path-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u4e2d\\u7684\\u6700\\u5927\\u8def\\u5f84\\u548c\"}, {\"title\": \"Sum Root to Leaf Numbers\", \"titleSlug\": \"sum-root-to-leaf-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6c42\\u6839\\u8282\\u70b9\\u5230\\u53f6\\u8282\\u70b9\\u6570\\u5b57\\u4e4b\\u548c\"}, {\"title\": \"Path Sum III\", \"titleSlug\": \"path-sum-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u8def\\u5f84\\u603b\\u548c III\"}, {\"title\": \"Path Sum IV\", \"titleSlug\": \"path-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u8def\\u5f84\\u603b\\u548c IV\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给你二叉树的根节点\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e 和一个表示目标和的整数\u0026nbsp;\u003ccode\u003etargetSum\u003c/code\u003e 。判断该树中是否存在 \u003cstrong\u003e根节点到叶子节点\u003c/strong\u003e 的路径，这条路径上所有节点值相加等于目标和\u0026nbsp;\u003ccode\u003etargetSum\u003c/code\u003e 。如果存在，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e叶子节点\u003c/strong\u003e 是指没有子节点的节点。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003cstrong\u003e解释：\u003c/strong\u003e等于目标和的根节点到叶节点路径如上图所示。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2,3], targetSum = 5\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003cstrong\u003e解释：\u003c/strong\u003e树中存在两条根节点到叶子节点的路径：\n(1 --\u0026gt; 2): 和为 3\n(1 --\u0026gt; 3): 和为 4\n不存在 sum = 5 的根节点到叶子节点的路径。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [], targetSum = 0\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003cstrong\u003e解释：\u003c/strong\u003e由于树是空的，所以不存在根节点到叶子节点的路径。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点的数目在范围 \u003ccode\u003e[0, 5000]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= targetSum \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "路径总和"
  },
  "peak-index-in-a-mountain-array": {
   "content": "\u003cp\u003eLet\u0026#39;s call an array \u003ccode\u003earr\u003c/code\u003e a \u003cstrong\u003emountain\u003c/strong\u003e\u0026nbsp;if the following properties hold:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003earr.length \u0026gt;= 3\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThere exists some \u003ccode\u003ei\u003c/code\u003e with\u0026nbsp;\u003ccode\u003e0 \u0026lt; i\u0026nbsp;\u0026lt; arr.length - 1\u003c/code\u003e\u0026nbsp;such that:\n\t\u003cul\u003e\n\t\t\u003cli\u003e\u003ccode\u003earr[0] \u0026lt; arr[1] \u0026lt; ... arr[i-1] \u0026lt; arr[i] \u003c/code\u003e\u003c/li\u003e\n\t\t\u003cli\u003e\u003ccode\u003earr[i] \u0026gt; arr[i+1] \u0026gt; ... \u0026gt; arr[arr.length - 1]\u003c/code\u003e\u003c/li\u003e\n\t\u003c/ul\u003e\n\t\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eGiven an integer array \u003ccode\u003earr\u003c/code\u003e that is \u003cstrong\u003eguaranteed\u003c/strong\u003e to be\u0026nbsp;a mountain, return any\u0026nbsp;\u003ccode\u003ei\u003c/code\u003e\u0026nbsp;such that\u0026nbsp;\u003ccode\u003earr[0] \u0026lt; arr[1] \u0026lt; ... arr[i - 1] \u0026lt; arr[i] \u0026gt; arr[i + 1] \u0026gt; ... \u0026gt; arr[arr.length - 1]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e arr = [0,1,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e arr = [0,2,1,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e arr = [0,10,5,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 \u0026lt;= arr.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= arr[i] \u0026lt;= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003earr\u003c/code\u003e is \u003cstrong\u003eguaranteed\u003c/strong\u003e to be a mountain array.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Finding the \u003ccode\u003eO(n)\u003c/code\u003e is straightforward, could you find an \u003ccode\u003eO(log(n))\u003c/code\u003e solution?",
   "hints": [],
   "questionId": "882",
   "similarQuestions": "[{\"title\": \"Find Peak Element\", \"titleSlug\": \"find-peak-element\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5bfb\\u627e\\u5cf0\\u503c\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "符合下列属性的数组 \u003ccode\u003earr\u003c/code\u003e 称为 \u003cstrong\u003e山脉数组\u003c/strong\u003e ：\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003earr.length \u003e= 3\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e存在 \u003ccode\u003ei\u003c/code\u003e（\u003ccode\u003e0 \u003c i \u003c arr.length - 1\u003c/code\u003e）使得：\n\t\u003cul\u003e\n\t\t\u003cli\u003e\u003ccode\u003earr[0] \u003c arr[1] \u003c ... arr[i-1] \u003c arr[i] \u003c/code\u003e\u003c/li\u003e\n\t\t\u003cli\u003e\u003ccode\u003earr[i] \u003e arr[i+1] \u003e ... \u003e arr[arr.length - 1]\u003c/code\u003e\u003c/li\u003e\n\t\u003c/ul\u003e\n\t\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e给你由整数组成的山脉数组 \u003ccode\u003earr\u003c/code\u003e ，返回任何满足 \u003ccode\u003earr[0] \u003c arr[1] \u003c ... arr[i - 1] \u003c arr[i] \u003e arr[i + 1] \u003e ... \u003e arr[arr.length - 1]\u003c/code\u003e 的下标 \u003ccode\u003ei\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003earr = [0,1,0]\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003earr = [0,2,1,0]\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003earr = [0,10,5,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003earr = [3,4,5,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 5：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003earr = [24,69,100,99,79,78,67,36,26,19]\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e3 \u003c= arr.length \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= arr[i] \u003c= 10\u003csup\u003e6\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e题目数据保证 \u003ccode\u003earr\u003c/code\u003e 是一个山脉数组\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e很容易想到时间复杂度 \u003ccode\u003eO(n)\u003c/code\u003e 的解决方案，你可以设计一个 \u003ccode\u003eO(log(n))\u003c/code\u003e 的解决方案吗？\u003c/p\u003e\n",
   "translatedTitle": "山脉数组的峰顶索引"
  },
  "perfect-squares": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "permutations": {
   "content": "\u003cp\u003eGiven an array \u003ccode\u003enums\u003c/code\u003e of distinct integers, return \u003cem\u003eall the possible permutations\u003c/em\u003e. You can return the answer in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[0,1],[1,0]]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1]]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 6\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10 \u0026lt;= nums[i] \u0026lt;= 10\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll the integers of \u003ccode\u003enums\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "46",
   "similarQuestions": "[{\"title\": \"Next Permutation\", \"titleSlug\": \"next-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e0b\\u4e00\\u4e2a\\u6392\\u5217\"}, {\"title\": \"Permutations II\", \"titleSlug\": \"permutations-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5168\\u6392\\u5217 II\"}, {\"title\": \"Permutation Sequence\", \"titleSlug\": \"permutation-sequence\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6392\\u5217\\u5e8f\\u5217\"}, {\"title\": \"Combinations\", \"titleSlug\": \"combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7ec4\\u5408\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Backtracking",
     "slug": "backtracking",
     "translatedName": "回溯"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个不含重复数字的数组 \u003ccode\u003enums\u003c/code\u003e ，返回其 \u003cem\u003e所有可能的全排列\u003c/em\u003e 。你可以 \u003cstrong\u003e按任意顺序\u003c/strong\u003e 返回答案。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [0,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[0,1],[1,0]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 6\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10 \u0026lt;= nums[i] \u0026lt;= 10\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e 中的所有整数 \u003cstrong\u003e互不相同\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "全排列"
  },
  "plus-one": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "plus-one-linked-list": {
   "content": "\u003cp\u003eGiven a non-negative integer represented as a linked list of digits, \u003cem\u003eplus one to the integer\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe digits are stored such that the most significant digit is at the \u003ccode\u003ehead\u003c/code\u003e of the list.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,4]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e head = [0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the linked list is in the range \u003ccode\u003e[1, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe number represented by the linked list does not contain leading zeros except for the zero itself.\u0026nbsp;\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "369",
   "similarQuestions": "[{\"title\": \"Plus One\", \"titleSlug\": \"plus-one\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u52a0\\u4e00\"}]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个用\u003cstrong\u003e链表\u003c/strong\u003e表示的非负整数， 然后将这个整数\u0026nbsp;\u003cem\u003e再加上 1\u003c/em\u003e 。\u003c/p\u003e\n\n\u003cp\u003e这些数字的存储是这样的：最高位有效的数字位于链表的首位\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003ehead\u003c/code\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003ehead = [1,2,3]\n\u003cstrong\u003e输出: \u003c/strong\u003e[1,2,4]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u003c/strong\u003e\u003cstrong\u003e\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003ehead = [0]\n\u003cstrong\u003e输出: \u003c/strong\u003e[1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中的节点数在\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003e[1, 100]\u003c/code\u003e\u0026nbsp;的范围内。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e由链表表示的数字不包含前导零，除了零本身。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "给单链表加一"
  },
  "populating-next-right-pointers-in-each-node": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "populating-next-right-pointers-in-each-node-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "power-of-three": {
   "content": "\u003cp\u003eGiven an integer \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003e\u003ccode\u003etrue\u003c/code\u003e if it is a power of three. Otherwise, return \u003ccode\u003efalse\u003c/code\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eAn integer \u003ccode\u003en\u003c/code\u003e is a power of three, if there exists an integer \u003ccode\u003ex\u003c/code\u003e such that \u003ccode\u003en == 3\u003csup\u003ex\u003c/sup\u003e\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 27\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 9\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you solve it without loops/recursion?",
   "hints": [],
   "questionId": "326",
   "similarQuestions": "[{\"title\": \"Power of Two\", \"titleSlug\": \"power-of-two\", \"difficulty\": \"Easy\", \"translatedTitle\": \"2 \\u7684\\u5e42\"}, {\"title\": \"Power of Four\", \"titleSlug\": \"power-of-four\", \"difficulty\": \"Easy\", \"translatedTitle\": \"4\\u7684\\u5e42\"}]",
   "topicTags": [
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个整数，写一个函数来判断它是否是 3\u0026nbsp;的幂次方。如果是，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e整数 \u003ccode\u003en\u003c/code\u003e 是 3 的幂次方需满足：存在整数 \u003ccode\u003ex\u003c/code\u003e 使得 \u003ccode\u003en == 3\u003csup\u003ex\u003c/sup\u003e\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 27\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 0\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 9\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 45\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你能不使用循环或者递归来完成本题吗？\u003c/p\u003e\n",
   "translatedTitle": "3 的幂"
  },
  "power-of-two": {
   "content": "\u003cp\u003eGiven an integer \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003e\u003ccode\u003etrue\u003c/code\u003e if it is a power of two. Otherwise, return \u003ccode\u003efalse\u003c/code\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eAn integer \u003ccode\u003en\u003c/code\u003e is a power of two, if there exists an integer \u003ccode\u003ex\u003c/code\u003e such that \u003ccode\u003en == 2\u003csup\u003ex\u003c/sup\u003e\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation: \u003c/strong\u003e2\u003csup\u003e0\u003c/sup\u003e = 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 16\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation: \u003c/strong\u003e2\u003csup\u003e4\u003c/sup\u003e = 16\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= n \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you solve it without loops/recursion?",
   "hints": [],
   "questionId": "231",
   "similarQuestions": "[{\"title\": \"Number of 1 Bits\", \"titleSlug\": \"number-of-1-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4f4d1\\u7684\\u4e2a\\u6570\"}, {\"title\": \"Power of Three\", \"titleSlug\": \"power-of-three\", \"difficulty\": \"Easy\", \"translatedTitle\": \"3 \\u7684\\u5e42\"}, {\"title\": \"Power of Four\", \"titleSlug\": \"power-of-four\", \"difficulty\": \"Easy\", \"translatedTitle\": \"4\\u7684\\u5e42\"}]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数 \u003ccode\u003en\u003c/code\u003e，请你判断该整数是否是 2 的幂次方。如果是，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e如果存在一个整数 \u003ccode\u003ex\u003c/code\u003e 使得 \u003ccode\u003en == 2\u003csup\u003ex\u003c/sup\u003e\u003c/code\u003e ，则认为 \u003ccode\u003en\u003c/code\u003e 是 2 的幂次方。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 1\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003cstrong\u003e解释：\u003c/strong\u003e2\u003csup\u003e0\u003c/sup\u003e = 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 16\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003cstrong\u003e解释：\u003c/strong\u003e2\u003csup\u003e4\u003c/sup\u003e = 16\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 3\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 4\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 5：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 5\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u003c= n \u003c= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你能够不使用循环/递归解决此问题吗？\u003c/p\u003e\n",
   "translatedTitle": "2 的幂"
  },
  "powx-n": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "print-foobar-alternately": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "print-in-order": {
   "content": "\u003cp\u003eSuppose we have a class:\u003c/p\u003e\n\n\u003cpre\u003e\npublic class Foo {\n  public void first() { print(\u0026quot;first\u0026quot;); }\n  public void second() { print(\u0026quot;second\u0026quot;); }\n  public void third() { print(\u0026quot;third\u0026quot;); }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThe same instance of \u003ccode\u003eFoo\u003c/code\u003e will be passed to three different threads. Thread A will call \u003ccode\u003efirst()\u003c/code\u003e, thread B will call \u003ccode\u003esecond()\u003c/code\u003e, and thread C will call \u003ccode\u003ethird()\u003c/code\u003e. Design a mechanism and modify the program to ensure that \u003ccode\u003esecond()\u003c/code\u003e is executed after \u003ccode\u003efirst()\u003c/code\u003e, and \u003ccode\u003ethird()\u003c/code\u003e is executed after \u003ccode\u003esecond()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eWe do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests\u0026#39; comprehensiveness.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;firstsecondthird\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). \u0026quot;firstsecondthird\u0026quot; is the correct output.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,3,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;firstsecondthird\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \u0026quot;firstsecondthird\u0026quot; is the correct output.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e is a permutation of \u003ccode\u003e[1, 2, 3]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "1203",
   "similarQuestions": "[{\"title\": \"Print FooBar Alternately\", \"titleSlug\": \"print-foobar-alternately\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4ea4\\u66ff\\u6253\\u5370 FooBar\"}]",
   "topicTags": [
    {
     "name": "Concurrency",
     "slug": "concurrency",
     "translatedName": "多线程"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个类：\u003c/p\u003e\n\n\u003cpre\u003e\npublic class Foo {\n\u0026nbsp; public void first() { print(\"first\"); }\n\u0026nbsp; public void second() { print(\"second\"); }\n\u0026nbsp; public void third() { print(\"third\"); }\n}\u003c/pre\u003e\n\n\u003cp\u003e三个不同的线程 A、B、C 将会共用一个\u0026nbsp;\u003ccode\u003eFoo\u003c/code\u003e\u0026nbsp;实例。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e线程 A 将会调用 \u003ccode\u003efirst()\u003c/code\u003e 方法\u003c/li\u003e\n\t\u003cli\u003e线程 B 将会调用\u0026nbsp;\u003ccode\u003esecond()\u003c/code\u003e 方法\u003c/li\u003e\n\t\u003cli\u003e线程 C 将会调用 \u003ccode\u003ethird()\u003c/code\u003e 方法\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e请设计修改程序，以确保 \u003ccode\u003esecond()\u003c/code\u003e 方法在 \u003ccode\u003efirst()\u003c/code\u003e 方法之后被执行，\u003ccode\u003ethird()\u003c/code\u003e 方法在 \u003ccode\u003esecond()\u003c/code\u003e 方法之后被执行。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。\u003c/li\u003e\n\t\u003cli\u003e你看到的输入格式主要是为了确保测试的全面性。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e\"firstsecondthird\"\n\u003cstrong\u003e解释：\u003c/strong\u003e\n有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 second() 方法，线程 C 将会调用 third() 方法。正确的输出是 \"firstsecondthird\"。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,3,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e\"firstsecondthird\"\n\u003cstrong\u003e解释：\u003c/strong\u003e\n输入 [1,3,2] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 third() 方法，线程 C 将会调用 second() 方法。正确的输出是 \"firstsecondthird\"。\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cul\u003e\n\u003c/ul\u003e\n\u003cstrong\u003e提示：\u003c/strong\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e 是 \u003ccode\u003e[1, 2, 3]\u003c/code\u003e 的一组排列\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "按序打印"
  },
  "print-zero-even-odd": {
   "content": "\u003cp\u003eYou have a function \u003ccode\u003eprintNumber\u003c/code\u003e that can be called with an integer parameter and prints it to the console.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, calling \u003ccode\u003eprintNumber(7)\u003c/code\u003e prints \u003ccode\u003e7\u003c/code\u003e to the console.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eYou are given an instance of the class \u003ccode\u003eZeroEvenOdd\u003c/code\u003e that has three functions: \u003ccode\u003ezero\u003c/code\u003e, \u003ccode\u003eeven\u003c/code\u003e, and \u003ccode\u003eodd\u003c/code\u003e. The same instance of \u003ccode\u003eZeroEvenOdd\u003c/code\u003e will be passed to three different threads:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003cstrong\u003eThread A:\u003c/strong\u003e calls \u003ccode\u003ezero()\u003c/code\u003e that should only output \u003ccode\u003e0\u003c/code\u003e\u0026#39;s.\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eThread B:\u003c/strong\u003e calls \u003ccode\u003eeven()\u003c/code\u003e that should only output even numbers.\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eThread C:\u003c/strong\u003e calls \u003ccode\u003eodd()\u003c/code\u003e that should only output odd numbers.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eModify the given class to output the series \u003ccode\u003e\u0026quot;010203040506...\u0026quot;\u003c/code\u003e where the length of the series must be \u003ccode\u003e2n\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eImplement the \u003ccode\u003eZeroEvenOdd\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eZeroEvenOdd(int n)\u003c/code\u003e Initializes the object with the number \u003ccode\u003en\u003c/code\u003e that represents the numbers that should be printed.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid zero(printNumber)\u003c/code\u003e Calls \u003ccode\u003eprintNumber\u003c/code\u003e to output one zero.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid even(printNumber)\u003c/code\u003e Calls \u003ccode\u003eprintNumber\u003c/code\u003e to output one even number.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid odd(printNumber)\u003c/code\u003e Calls \u003ccode\u003eprintNumber\u003c/code\u003e to output one odd number.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;0102\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are three threads being fired asynchronously.\nOne of them calls zero(), the other calls even(), and the last one calls odd().\n\u0026quot;0102\u0026quot; is the correct output.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;0102030405\u0026quot;\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "1216",
   "similarQuestions": "[{\"title\": \"Print FooBar Alternately\", \"titleSlug\": \"print-foobar-alternately\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4ea4\\u66ff\\u6253\\u5370 FooBar\"}]",
   "topicTags": [
    {
     "name": "Concurrency",
     "slug": "concurrency",
     "translatedName": "多线程"
    }
   ],
   "translatedContent": "\u003cp\u003e现有函数 \u003ccode\u003eprintNumber\u003c/code\u003e 可以用一个整数参数调用，并输出该整数到控制台。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e例如，调用 \u003ccode\u003eprintNumber(7)\u003c/code\u003e 将会输出 \u003ccode\u003e7\u003c/code\u003e 到控制台。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e给你类 \u003ccode\u003eZeroEvenOdd\u003c/code\u003e 的一个实例，该类中有三个函数：\u003ccode\u003ezero\u003c/code\u003e、\u003ccode\u003eeven\u003c/code\u003e 和 \u003ccode\u003eodd\u003c/code\u003e 。\u003ccode\u003eZeroEvenOdd\u003c/code\u003e 的相同实例将会传递给三个不同线程：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003cstrong\u003e线程 A：\u003c/strong\u003e调用 \u003ccode\u003ezero()\u003c/code\u003e ，只输出 \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003e线程 B：\u003c/strong\u003e调用 \u003ccode\u003eeven()\u003c/code\u003e ，只输出偶数\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003e线程 C：\u003c/strong\u003e调用 \u003ccode\u003eodd()\u003c/code\u003e ，只输出奇数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e修改给出的类，以输出序列 \u003ccode\u003e\"010203040506...\"\u003c/code\u003e ，其中序列的长度必须为 \u003ccode\u003e2n\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e实现 \u003ccode\u003eZeroEvenOdd\u003c/code\u003e 类：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003eZeroEvenOdd(int n)\u003c/code\u003e 用数字 \u003ccode\u003en\u003c/code\u003e 初始化对象，表示需要输出的数。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid zero(printNumber)\u003c/code\u003e 调用 \u003ccode\u003eprintNumber\u003c/code\u003e 以输出一个 0 。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid even(printNumber)\u003c/code\u003e 调用\u003ccode\u003eprintNumber\u003c/code\u003e 以输出偶数。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003evoid odd(printNumber)\u003c/code\u003e 调用 \u003ccode\u003eprintNumber\u003c/code\u003e 以输出奇数。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e\"0102\"\n\u003cstrong\u003e解释：\u003c/strong\u003e三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 \"0102\"。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 5\n\u003cstrong\u003e输出：\u003c/strong\u003e\"0102030405\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "打印零与奇偶数"
  },
  "product-of-array-except-self": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e, return \u003cem\u003ean array\u003c/em\u003e \u003ccode\u003eanswer\u003c/code\u003e \u003cem\u003esuch that\u003c/em\u003e \u003ccode\u003eanswer[i]\u003c/code\u003e \u003cem\u003eis equal to the product of all the elements of\u003c/em\u003e \u003ccode\u003enums\u003c/code\u003e \u003cem\u003eexcept\u003c/em\u003e \u003ccode\u003enums[i]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe product of any prefix or suffix of \u003ccode\u003enums\u003c/code\u003e is \u003cstrong\u003eguaranteed\u003c/strong\u003e to fit in a \u003cstrong\u003e32-bit\u003c/strong\u003e integer.\u003c/p\u003e\n\n\u003cp\u003eYou must write an algorithm that runs in\u0026nbsp;\u003ccode\u003eO(n)\u003c/code\u003e\u0026nbsp;time and without using the division operation.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,2,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [24,12,8,6]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [-1,1,0,-3,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0,0,9,0,0]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e2 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-30 \u0026lt;= nums[i] \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe product of any prefix or suffix of \u003ccode\u003enums\u003c/code\u003e is \u003cstrong\u003eguaranteed\u003c/strong\u003e to fit in a \u003cstrong\u003e32-bit\u003c/strong\u003e integer.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e\u0026nbsp;Can you solve the problem in \u003ccode\u003eO(1)\u0026nbsp;\u003c/code\u003eextra\u0026nbsp;space complexity? (The output array \u003cstrong\u003edoes not\u003c/strong\u003e count as extra space for space complexity analysis.)\u003c/p\u003e\n",
   "hints": [],
   "questionId": "238",
   "similarQuestions": "[{\"title\": \"Trapping Rain Water\", \"titleSlug\": \"trapping-rain-water\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u63a5\\u96e8\\u6c34\"}, {\"title\": \"Maximum Product Subarray\", \"titleSlug\": \"maximum-product-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e58\\u79ef\\u6700\\u5927\\u5b50\\u6570\\u7ec4\"}, {\"title\": \"Paint House II\", \"titleSlug\": \"paint-house-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u7c89\\u5237\\u623f\\u5b50 II\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Prefix Sum",
     "slug": "prefix-sum",
     "translatedName": "前缀和"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数数组\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e，返回 \u003cem\u003e数组\u0026nbsp;\u003ccode\u003eanswer\u003c/code\u003e\u0026nbsp;，其中\u0026nbsp;\u003ccode\u003eanswer[i]\u003c/code\u003e\u0026nbsp;等于\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e\u0026nbsp;中除\u0026nbsp;\u003ccode\u003enums[i]\u003c/code\u003e\u0026nbsp;之外其余各元素的乘积\u003c/em\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e题目数据 \u003cstrong\u003e保证\u003c/strong\u003e 数组\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e之中任意元素的全部前缀元素和后缀的乘积都在\u0026nbsp; \u003cstrong\u003e32 位\u003c/strong\u003e 整数范围内。\u003c/p\u003e\n\n\u003cp\u003e请\u003cstrong\u003e不要使用除法，\u003c/strong\u003e且在\u0026nbsp;\u003ccode\u003eO(\u003cem\u003en\u003c/em\u003e)\u003c/code\u003e 时间复杂度内完成此题。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = \u003ccode\u003e[1,2,3,4]\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e \u003ccode\u003e[24,12,8,6]\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [-1,1,0,-3,3]\n\u003cstrong\u003e输出:\u003c/strong\u003e [0,0,9,0,0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e2 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-30 \u0026lt;= nums[i] \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003e保证\u003c/strong\u003e 数组\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e之中任意元素的全部前缀元素和后缀的乘积都在\u0026nbsp; \u003cstrong\u003e32 位\u003c/strong\u003e 整数范围内\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你可以在 \u003ccode\u003eO(1)\u003c/code\u003e\u0026nbsp;的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组\u003cstrong\u003e不被视为\u003c/strong\u003e额外空间。）\u003c/p\u003e\n",
   "translatedTitle": "除自身以外数组的乘积"
  },
  "que-shi-de-shu-zi-lcof": {
   "content": "English description is not available for the problem. Please switch to Chinese.",
   "hints": [],
   "questionId": "100331",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e [0,1,3]\n\u003cstrong\u003e输出:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e [0,1,2,3,4,5,6,7,9]\n\u003cstrong\u003e输出:\u003c/strong\u003e 8\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e限制：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e1 \u0026lt;= 数组长度 \u0026lt;= 10000\u003c/code\u003e\u003c/p\u003e\n",
   "translatedTitle": "0～n-1中缺失的数字"
  },
  "range-sum-of-bst": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "ransom-note": {
   "content": "\u003cp\u003eGiven two strings \u003ccode\u003eransomNote\u003c/code\u003e and \u003ccode\u003emagazine\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e\u003cem\u003e if \u003c/em\u003e\u003ccode\u003eransomNote\u003c/code\u003e\u003cem\u003e can be constructed from \u003c/em\u003e\u003ccode\u003emagazine\u003c/code\u003e\u003cem\u003e and \u003c/em\u003e\u003ccode\u003efalse\u003c/code\u003e\u003cem\u003e otherwise\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eEach letter in \u003ccode\u003emagazine\u003c/code\u003e can only be used once in \u003ccode\u003eransomNote\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e ransomNote = \"a\", magazine = \"b\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e ransomNote = \"aa\", magazine = \"ab\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e ransomNote = \"aa\", magazine = \"aab\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= ransomNote.length, magazine.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eransomNote\u003c/code\u003e and \u003ccode\u003emagazine\u003c/code\u003e consist of lowercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "383",
   "similarQuestions": "[{\"title\": \"Stickers to Spell Word\", \"titleSlug\": \"stickers-to-spell-word\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u8d34\\u7eb8\\u62fc\\u8bcd\"}]",
   "topicTags": [
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Counting",
     "slug": "counting",
     "translatedName": "计数"
    }
   ],
   "translatedContent": "\u003cp\u003e给你两个字符串：\u003ccode\u003eransomNote\u003c/code\u003e 和 \u003ccode\u003emagazine\u003c/code\u003e ，判断 \u003ccode\u003eransomNote\u003c/code\u003e 能不能由 \u003ccode\u003emagazine\u003c/code\u003e 里面的字符构成。\u003c/p\u003e\n\n\u003cp\u003e如果可以，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003emagazine\u003c/code\u003e 中的每个字符只能在 \u003ccode\u003eransomNote\u003c/code\u003e 中使用一次。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eransomNote = \"a\", magazine = \"b\"\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eransomNote = \"aa\", magazine = \"ab\"\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eransomNote = \"aa\", magazine = \"aab\"\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= ransomNote.length, magazine.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eransomNote\u003c/code\u003e 和 \u003ccode\u003emagazine\u003c/code\u003e 由小写英文字母组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "赎金信"
  },
  "recover-binary-search-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "redundant-connection": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "remove-duplicates-from-sorted-array": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e sorted in \u003cstrong\u003enon-decreasing order\u003c/strong\u003e, remove the duplicates \u003ca href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"\u003e\u003cstrong\u003ein-place\u003c/strong\u003e\u003c/a\u003e such that each unique element appears only \u003cstrong\u003eonce\u003c/strong\u003e. The \u003cstrong\u003erelative order\u003c/strong\u003e of the elements should be kept the \u003cstrong\u003esame\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the \u003cstrong\u003efirst part\u003c/strong\u003e of the array \u003ccode\u003enums\u003c/code\u003e. More formally, if there are \u003ccode\u003ek\u003c/code\u003e elements after removing the duplicates, then the first \u003ccode\u003ek\u003c/code\u003e elements of \u003ccode\u003enums\u003c/code\u003e\u0026nbsp;should hold the final result. It does not matter what you leave beyond the first\u0026nbsp;\u003ccode\u003ek\u003c/code\u003e\u0026nbsp;elements.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003ccode\u003ek\u003c/code\u003e\u003cem\u003e after placing the final result in the first \u003c/em\u003e\u003ccode\u003ek\u003c/code\u003e\u003cem\u003e slots of \u003c/em\u003e\u003ccode\u003enums\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eDo \u003cstrong\u003enot\u003c/strong\u003e allocate extra space for another array. You must do this by \u003cstrong\u003emodifying the input array \u003ca href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"\u003ein-place\u003c/a\u003e\u003c/strong\u003e with O(1) extra memory.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCustom Judge:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe judge will test your solution with the following code:\u003c/p\u003e\n\n\u003cpre\u003e\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i \u0026lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\u003c/pre\u003e\n\n\u003cp\u003eIf all assertions pass, then your solution will be \u003cstrong\u003eaccepted\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,1,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2, nums = [1,2,_]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0,0,1,1,1,2,2,3,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5, nums = [0,1,2,3,4,_,_,_,_,_]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= nums[i] \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e is sorted in \u003cstrong\u003enon-decreasing\u003c/strong\u003e order.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image above for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n\u003cbr\u003e\r\n\u003cimg src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" width=\"500\"/\u003e",
    "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
    "Essentially, once an element is encountered, you simply need to \u003cb\u003ebypass\u003c/b\u003e its duplicates and move on to the next unique element."
   ],
   "questionId": "26",
   "similarQuestions": "[{\"title\": \"Remove Element\", \"titleSlug\": \"remove-element\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u79fb\\u9664\\u5143\\u7d20\"}, {\"title\": \"Remove Duplicates from Sorted Array II\", \"titleSlug\": \"remove-duplicates-from-sorted-array-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5220\\u9664\\u6709\\u5e8f\\u6570\\u7ec4\\u4e2d\\u7684\\u91cd\\u590d\\u9879 II\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个 \u003cstrong\u003e升序排列\u003c/strong\u003e 的数组 \u003ccode\u003enums\u003c/code\u003e ，请你\u003cstrong\u003e\u003ca href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"\u003e 原地\u003c/a\u003e\u003c/strong\u003e 删除重复出现的元素，使每个元素 \u003cstrong\u003e只出现一次\u003c/strong\u003e ，返回删除后数组的新长度。元素的 \u003cstrong\u003e相对顺序\u003c/strong\u003e 应该保持 \u003cstrong\u003e一致\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 \u003ccode\u003ek\u003c/code\u003e 个元素，那么\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e\u0026nbsp;的前 \u003ccode\u003ek\u003c/code\u003e 个元素应该保存最终结果。\u003c/p\u003e\n\n\u003cp\u003e将最终结果插入\u0026nbsp;\u003ccode\u003enums\u003c/code\u003e 的前 \u003ccode\u003ek\u003c/code\u003e 个位置后返回 \u003ccode\u003ek\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e不要使用额外的空间，你必须在 \u003cstrong\u003e\u003ca href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"\u003e原地 \u003c/a\u003e修改输入数组 \u003c/strong\u003e并在使用 O(1) 额外空间的条件下完成。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e判题标准:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e系统会用下面的代码来测试你的题解:\u003c/p\u003e\n\n\u003cpre\u003e\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i \u0026lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\u003c/pre\u003e\n\n\u003cp\u003e如果所有断言都通过，那么您的题解将被 \u003cstrong\u003e通过\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,1,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e2, nums = [1,2,_]\n\u003cstrong\u003e解释：\u003c/strong\u003e函数应该返回新的长度 \u003cstrong\u003e\u003ccode\u003e2\u003c/code\u003e\u003c/strong\u003e ，并且原数组 \u003cem\u003enums \u003c/em\u003e的前两个元素被修改为 \u003cstrong\u003e\u003ccode\u003e1\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e2 \u003c/code\u003e\u003c/strong\u003e\u003ccode\u003e。\u003c/code\u003e不需要考虑数组中超出新长度后面的元素。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [0,0,1,1,1,2,2,3,3,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e5, nums = [0,1,2,3,4]\n\u003cstrong\u003e解释：\u003c/strong\u003e函数应该返回新的长度 \u003cstrong\u003e\u003ccode\u003e5\u003c/code\u003e\u003c/strong\u003e ， 并且原数组 \u003cem\u003enums \u003c/em\u003e的前五个元素被修改为 \u003cstrong\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e1\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e2\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e3\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e4\u003c/code\u003e\u003c/strong\u003e 。不需要考虑数组中超出新长度后面的元素。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums.length \u0026lt;= 3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e 已按 \u003cstrong\u003e升序\u003c/strong\u003e 排列\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "删除有序数组中的重复项"
  },
  "remove-duplicates-from-sorted-array-ii": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e sorted in \u003cstrong\u003enon-decreasing order\u003c/strong\u003e, remove some duplicates \u003ca href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"\u003e\u003cstrong\u003ein-place\u003c/strong\u003e\u003c/a\u003e such that each unique element appears \u003cstrong\u003eat most twice\u003c/strong\u003e. The \u003cstrong\u003erelative order\u003c/strong\u003e of the elements should be kept the \u003cstrong\u003esame\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the \u003cstrong\u003efirst part\u003c/strong\u003e of the array \u003ccode\u003enums\u003c/code\u003e. More formally, if there are \u003ccode\u003ek\u003c/code\u003e elements after removing the duplicates, then the first \u003ccode\u003ek\u003c/code\u003e elements of \u003ccode\u003enums\u003c/code\u003e\u0026nbsp;should hold the final result. It does not matter what you leave beyond the first\u0026nbsp;\u003ccode\u003ek\u003c/code\u003e\u0026nbsp;elements.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003ccode\u003ek\u003c/code\u003e\u003cem\u003e after placing the final result in the first \u003c/em\u003e\u003ccode\u003ek\u003c/code\u003e\u003cem\u003e slots of \u003c/em\u003e\u003ccode\u003enums\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eDo \u003cstrong\u003enot\u003c/strong\u003e allocate extra space for another array. You must do this by \u003cstrong\u003emodifying the input array \u003ca href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"\u003ein-place\u003c/a\u003e\u003c/strong\u003e with O(1) extra memory.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCustom Judge:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe judge will test your solution with the following code:\u003c/p\u003e\n\n\u003cpre\u003e\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i \u0026lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\u003c/pre\u003e\n\n\u003cp\u003eIf all assertions pass, then your solution will be \u003cstrong\u003eaccepted\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,1,1,2,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5, nums = [1,1,2,2,3,_]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0,0,1,1,1,1,2,3,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 7, nums = [0,0,1,1,2,3,3,_,_]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e is sorted in \u003cstrong\u003enon-decreasing\u003c/strong\u003e order.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "80",
   "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted Array\", \"titleSlug\": \"remove-duplicates-from-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5220\\u9664\\u6709\\u5e8f\\u6570\\u7ec4\\u4e2d\\u7684\\u91cd\\u590d\\u9879\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个有序数组 \u003ccode\u003enums\u003c/code\u003e ，请你\u003cstrong\u003e\u003ca href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"\u003e 原地\u003c/a\u003e\u003c/strong\u003e 删除重复出现的元素，使每个元素 \u003cstrong\u003e最多出现两次\u003c/strong\u003e ，返回删除后数组的新长度。\u003c/p\u003e\n\n\u003cp\u003e不要使用额外的数组空间，你必须在 \u003cstrong\u003e\u003ca href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"\u003e原地 \u003c/a\u003e修改输入数组 \u003c/strong\u003e并在使用 O(1) 额外空间的条件下完成。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e为什么返回数值是整数，但输出的答案是数组呢？\u003c/p\u003e\n\n\u003cp\u003e请注意，输入数组是以\u003cstrong\u003e「引用」\u003c/strong\u003e方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\u003c/p\u003e\n\n\u003cp\u003e你可以想象内部操作如下:\u003c/p\u003e\n\n\u003cpre\u003e\n// \u003cstrong\u003enums\u003c/strong\u003e 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中\u003cstrong\u003e 该长度范围内\u003c/strong\u003e 的所有元素。\nfor (int i = 0; i \u003c len; i++) {\n    print(nums[i]);\n}\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1,1,1,2,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e5, nums = [1,1,2,2,3]\n\u003cstrong\u003e解释：\u003c/strong\u003e函数应返回新长度 length = \u003cstrong\u003e\u003ccode\u003e5\u003c/code\u003e\u003c/strong\u003e, 并且原数组的前五个元素被修改为 \u003cstrong\u003e\u003ccode\u003e1, 1, 2, 2,\u003c/code\u003e\u003c/strong\u003e \u003cstrong\u003e3 \u003c/strong\u003e。 不需要考虑数组中超出新长度后面的元素。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [0,0,1,1,1,1,2,3,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e7, nums = [0,0,1,1,2,3,3]\n\u003cstrong\u003e解释：\u003c/strong\u003e函数应返回新长度 length = \u003cstrong\u003e\u003ccode\u003e7\u003c/code\u003e\u003c/strong\u003e, 并且原数组的前五个元素被修改为 \u003cstrong\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e0\u003c/strong\u003e, \u003cstrong\u003e1\u003c/strong\u003e, \u003cstrong\u003e1\u003c/strong\u003e, \u003cstrong\u003e2\u003c/strong\u003e, \u003cstrong\u003e3\u003c/strong\u003e, \u003cstrong\u003e3 。\u003c/strong\u003e 不需要考虑数组中超出新长度后面的元素。\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= nums.length \u003c= 3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u003c= nums[i] \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e 已按升序排列\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "删除有序数组中的重复项 II"
  },
  "remove-duplicates-from-sorted-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "remove-duplicates-from-sorted-list-ii": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003ehead\u003c/code\u003e of a sorted linked list, \u003cem\u003edelete all nodes that have duplicate numbers, leaving only distinct numbers from the original list\u003c/em\u003e. Return \u003cem\u003ethe linked list \u003cstrong\u003esorted\u003c/strong\u003e as well\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg\" style=\"width: 500px; height: 142px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,3,4,4,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg\" style=\"width: 500px; height: 205px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,1,1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is in the range \u003ccode\u003e[0, 300]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe list is guaranteed to be \u003cstrong\u003esorted\u003c/strong\u003e in ascending order.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "82",
   "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted List\", \"titleSlug\": \"remove-duplicates-from-sorted-list\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5220\\u9664\\u6392\\u5e8f\\u94fe\\u8868\\u4e2d\\u7684\\u91cd\\u590d\\u5143\\u7d20\"}]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个已排序的链表的头\u0026nbsp;\u003ccode\u003ehead\u003c/code\u003e ，\u0026nbsp;\u003cem\u003e删除原始链表中所有重复数字的节点，只留下不同的数字\u003c/em\u003e\u0026nbsp;。返回 \u003cem\u003e已排序的链表\u003c/em\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg\" style=\"height: 142px; width: 500px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,3,4,4,5]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg\" style=\"height: 164px; width: 400px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,1,1,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e[2,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点数目在范围 \u003ccode\u003e[0, 300]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e题目数据保证链表已经按升序 \u003cstrong\u003e排列\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "删除排序链表中的重复元素 II"
  },
  "remove-element": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e and an integer \u003ccode\u003eval\u003c/code\u003e, remove all occurrences of \u003ccode\u003eval\u003c/code\u003e in \u003ccode\u003enums\u003c/code\u003e \u003ca href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"\u003e\u003cstrong\u003ein-place\u003c/strong\u003e\u003c/a\u003e. The relative order of the elements may be changed.\u003c/p\u003e\n\n\u003cp\u003eSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the \u003cstrong\u003efirst part\u003c/strong\u003e of the array \u003ccode\u003enums\u003c/code\u003e. More formally, if there are \u003ccode\u003ek\u003c/code\u003e elements after removing the duplicates, then the first \u003ccode\u003ek\u003c/code\u003e elements of \u003ccode\u003enums\u003c/code\u003e should hold the final result. It does not matter what you leave beyond the first \u003ccode\u003ek\u003c/code\u003e elements.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003ccode\u003ek\u003c/code\u003e\u003cem\u003e after placing the final result in the first \u003c/em\u003e\u003ccode\u003ek\u003c/code\u003e\u003cem\u003e slots of \u003c/em\u003e\u003ccode\u003enums\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eDo \u003cstrong\u003enot\u003c/strong\u003e allocate extra space for another array. You must do this by \u003cstrong\u003emodifying the input array \u003ca href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"\u003ein-place\u003c/a\u003e\u003c/strong\u003e with O(1) extra memory.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCustom Judge:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe judge will test your solution with the following code:\u003c/p\u003e\n\n\u003cpre\u003e\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i \u0026lt; actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\u003c/pre\u003e\n\n\u003cp\u003eIf all assertions pass, then your solution will be \u003cstrong\u003eaccepted\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [3,2,2,3], val = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2, nums = [2,2,_,_]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0,1,2,2,3,0,4,2], val = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5, nums = [0,1,4,0,3,_,_,_]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums[i] \u0026lt;= 50\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to \u003cb\u003eremove\u003c/b\u003e that element per-say, right?",
    "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n\u003cbr\u003e\u003cimg src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/\u003e",
    "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
   ],
   "questionId": "27",
   "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted Array\", \"titleSlug\": \"remove-duplicates-from-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5220\\u9664\\u6709\\u5e8f\\u6570\\u7ec4\\u4e2d\\u7684\\u91cd\\u590d\\u9879\"}, {\"title\": \"Remove Linked List Elements\", \"titleSlug\": \"remove-linked-list-elements\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u79fb\\u9664\\u94fe\\u8868\\u5143\\u7d20\"}, {\"title\": \"Move Zeroes\", \"titleSlug\": \"move-zeroes\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u79fb\\u52a8\\u96f6\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个数组 \u003ccode\u003enums\u003c/code\u003e\u003cem\u003e \u003c/em\u003e和一个值 \u003ccode\u003eval\u003c/code\u003e，你需要 \u003cstrong\u003e\u003ca href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"\u003e原地\u003c/a\u003e\u003c/strong\u003e 移除所有数值等于 \u003ccode\u003eval\u003c/code\u003e\u003cem\u003e \u003c/em\u003e的元素，并返回移除后数组的新长度。\u003c/p\u003e\n\n\u003cp\u003e不要使用额外的数组空间，你必须仅使用 \u003ccode\u003eO(1)\u003c/code\u003e 额外空间并 \u003cstrong\u003e\u003ca href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"\u003e原地 \u003c/a\u003e修改输入数组\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e为什么返回数值是整数，但输出的答案是数组呢?\u003c/p\u003e\n\n\u003cp\u003e请注意，输入数组是以\u003cstrong\u003e「引用」\u003c/strong\u003e方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\u003c/p\u003e\n\n\u003cp\u003e你可以想象内部操作如下:\u003c/p\u003e\n\n\u003cpre\u003e\n// \u003cstrong\u003enums\u003c/strong\u003e 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中\u003cstrong\u003e 该长度范围内\u003c/strong\u003e 的所有元素。\nfor (int i = 0; i \u003c len; i++) {\n    print(nums[i]);\n}\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [3,2,2,3], val = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e2, nums = [2,2]\n\u003cstrong\u003e解释：\u003c/strong\u003e函数应该返回新的长度 \u003cstrong\u003e2\u003c/strong\u003e, 并且 nums\u003cem\u003e \u003c/em\u003e中的前两个元素均为 \u003cstrong\u003e2\u003c/strong\u003e。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [0,1,2,2,3,0,4,2], val = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e5, nums = [0,1,4,0,3]\n\u003cstrong\u003e解释：\u003c/strong\u003e函数应该返回新的长度 \u003cstrong\u003e\u003ccode\u003e5\u003c/code\u003e\u003c/strong\u003e, 并且 nums 中的前五个元素为 \u003cstrong\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e1\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e3\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e4\u003c/strong\u003e。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= nums.length \u003c= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= nums[i] \u003c= 50\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= val \u003c= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "移除元素"
  },
  "remove-linked-list-elements": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "remove-nth-node-from-end-of-list": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003ehead\u003c/code\u003e of a linked list, remove the \u003ccode\u003en\u003csup\u003eth\u003c/sup\u003e\u003c/code\u003e node from the end of the list and return its head.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,4,5], n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,3,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1], n = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2], n = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is \u003ccode\u003esz\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= sz \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= sz\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you do this in one pass?\u003c/p\u003e\n",
   "hints": [
    "Maintain two pointers and update one with a delay of n steps."
   ],
   "questionId": "19",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个链表，删除链表的倒数第\u0026nbsp;\u003ccode\u003en\u003c/code\u003e\u003cem\u003e\u0026nbsp;\u003c/em\u003e个结点，并且返回链表的头结点。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,4,5], n = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2,3,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1], n = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2], n = 1\n\u003cstrong\u003e输出：\u003c/strong\u003e[1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中结点的数目为 \u003ccode\u003esz\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= sz \u0026lt;= 30\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= sz\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你能尝试使用一趟扫描实现吗？\u003c/p\u003e\n",
   "translatedTitle": "删除链表的倒数第 N 个结点"
  },
  "reorder-list": {
   "content": "\u003cp\u003eYou are given the head of a singly linked-list. The list can be represented as:\u003c/p\u003e\n\n\u003cpre\u003e\nL\u003csub\u003e0\u003c/sub\u003e \u0026rarr; L\u003csub\u003e1\u003c/sub\u003e \u0026rarr; \u0026hellip; \u0026rarr; L\u003csub\u003en - 1\u003c/sub\u003e \u0026rarr; L\u003csub\u003en\u003c/sub\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cem\u003eReorder the list to be on the following form:\u003c/em\u003e\u003c/p\u003e\n\n\u003cpre\u003e\nL\u003csub\u003e0\u003c/sub\u003e \u0026rarr; L\u003csub\u003en\u003c/sub\u003e \u0026rarr; L\u003csub\u003e1\u003c/sub\u003e \u0026rarr; L\u003csub\u003en - 1\u003c/sub\u003e \u0026rarr; L\u003csub\u003e2\u003c/sub\u003e \u0026rarr; L\u003csub\u003en - 2\u003c/sub\u003e \u0026rarr; \u0026hellip;\n\u003c/pre\u003e\n\n\u003cp\u003eYou may not modify the values in the list\u0026#39;s nodes. Only nodes themselves may be changed.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\" style=\"width: 422px; height: 222px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,4,2,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg\" style=\"width: 542px; height: 222px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,4,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,5,2,4,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is in the range \u003ccode\u003e[1, 5 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "143",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个单链表 \u003ccode\u003eL\u003c/code\u003e\u003cem\u003e \u003c/em\u003e的头节点 \u003ccode\u003ehead\u003c/code\u003e ，单链表 \u003ccode\u003eL\u003c/code\u003e 表示为：\u003c/p\u003e\n\n\u003cpre\u003e\nL\u003csub\u003e0\u003c/sub\u003e → L\u003csub\u003e1\u003c/sub\u003e → … → L\u003csub\u003en - 1\u003c/sub\u003e → L\u003csub\u003en\u003c/sub\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e请将其重新排列后变为：\u003c/p\u003e\n\n\u003cpre\u003e\nL\u003csub\u003e0\u003c/sub\u003e → L\u003csub\u003en\u003c/sub\u003e → L\u003csub\u003e1\u003c/sub\u003e → L\u003csub\u003en - 1\u003c/sub\u003e → L\u003csub\u003e2\u003c/sub\u003e → L\u003csub\u003en - 2\u003c/sub\u003e → …\u003c/pre\u003e\n\n\u003cp\u003e不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png\" style=\"width: 240px; \" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,4,2,3]\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://pic.leetcode-cn.com/1626420320-YUiulT-image.png\" style=\"width: 320px; \" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,4,5]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,5,2,4,3]\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表的长度范围为 \u003ccode\u003e[1, 5 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "重排链表"
  },
  "repeated-substring-pattern": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "restore-ip-addresses": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "reverse-bits": {
   "content": "\u003cp\u003eReverse bits of a given 32 bits unsigned integer.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer\u0026#39;s internal binary representation is the same, whether it is signed or unsigned.\u003c/li\u003e\n\t\u003cli\u003eIn Java, the compiler represents the signed integers using \u003ca href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\"\u003e2\u0026#39;s complement notation\u003c/a\u003e. Therefore, in \u003cstrong\u003eExample 2\u003c/strong\u003e above, the input represents the signed integer \u003ccode\u003e-3\u003c/code\u003e and the output represents the signed integer \u003ccode\u003e-1073741825\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 00000010100101000001111010011100\n\u003cstrong\u003eOutput:\u003c/strong\u003e    964176192 (00111001011110000010100101000000)\n\u003cstrong\u003eExplanation: \u003c/strong\u003eThe input binary string \u003cstrong\u003e00000010100101000001111010011100\u003c/strong\u003e represents the unsigned integer 43261596, so return 964176192 which its binary representation is \u003cstrong\u003e00111001011110000010100101000000\u003c/strong\u003e.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 11111111111111111111111111111101\n\u003cstrong\u003eOutput:\u003c/strong\u003e   3221225471 (10111111111111111111111111111111)\n\u003cstrong\u003eExplanation: \u003c/strong\u003eThe input binary string \u003cstrong\u003e11111111111111111111111111111101\u003c/strong\u003e represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is \u003cstrong\u003e10111111111111111111111111111111\u003c/strong\u003e.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe input must be a \u003cstrong\u003ebinary string\u003c/strong\u003e of length \u003ccode\u003e32\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e If this function is called many times, how would you optimize it?\u003c/p\u003e\n",
   "hints": [],
   "questionId": "190",
   "similarQuestions": "[{\"title\": \"Reverse Integer\", \"titleSlug\": \"reverse-integer\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6574\\u6570\\u53cd\\u8f6c\"}, {\"title\": \"Number of 1 Bits\", \"titleSlug\": \"number-of-1-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4f4d1\\u7684\\u4e2a\\u6570\"}]",
   "topicTags": [
    {
     "name": "Bit Manipulation",
     "slug": "bit-manipulation",
     "translatedName": "位运算"
    },
    {
     "name": "Divide and Conquer",
     "slug": "divide-and-conquer",
     "translatedName": "分治"
    }
   ],
   "translatedContent": "\u003cp\u003e颠倒给定的 32 位无符号整数的二进制位。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\u003c/li\u003e\n\t\u003cli\u003e在 Java 中，编译器使用\u003ca href=\"https://baike.baidu.com/item/二进制补码/5295284\" target=\"_blank\"\u003e二进制补码\u003c/a\u003e记法来表示有符号整数。因此，在 \u003cstrong\u003e示例 2\u003c/strong\u003e\u0026nbsp;中，输入表示有符号整数 \u003ccode\u003e-3\u003c/code\u003e，输出表示有符号整数 \u003ccode\u003e-1073741825\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 00000010100101000001111010011100\n\u003cstrong\u003e输出：\u003c/strong\u003e964176192 (00111001011110000010100101000000)\n\u003cstrong\u003e解释：\u003c/strong\u003e输入的二进制串 \u003cstrong\u003e00000010100101000001111010011100 \u003c/strong\u003e表示无符号整数\u003cstrong\u003e 43261596\u003c/strong\u003e\u003cstrong\u003e，\n    \u003c/strong\u003e 因此返回 964176192，其二进制表示形式为 \u003cstrong\u003e00111001011110000010100101000000\u003c/strong\u003e。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003en = 11111111111111111111111111111101\n\u003cstrong\u003e输出：\u003c/strong\u003e3221225471 (10111111111111111111111111111111)\n\u003cstrong\u003e解释：\u003c/strong\u003e输入的二进制串 \u003cstrong\u003e11111111111111111111111111111101\u003c/strong\u003e 表示无符号整数 4294967293，\n   \u0026nbsp; 因此返回 3221225471 其二进制表示形式为 \u003cstrong\u003e10111111111111111111111111111111 。\u003c/strong\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e输入是一个长度为 \u003ccode\u003e32\u003c/code\u003e 的二进制字符串\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶\u003c/strong\u003e: 如果多次调用这个函数，你将如何优化你的算法？\u003c/p\u003e\n",
   "translatedTitle": "颠倒二进制位"
  },
  "reverse-integer": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "reverse-linked-list": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "reverse-linked-list-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "reverse-nodes-in-k-group": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "reverse-only-letters": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e, reverse the string according to the following rules:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eAll the characters that are not English letters remain in the same position.\u003c/li\u003e\n\t\u003cli\u003eAll the English letters (lowercase or uppercase) should be reversed.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003ccode\u003es\u003c/code\u003e\u003cem\u003e after reversing it\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"ab-cd\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"dc-ba\"\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"a-bC-dEf-ghIj\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"j-Ih-gfE-dCba\"\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"Test1ng-Leet=code-Q!\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"Qedo1ct-eeLg=ntse-T!\"\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consists of characters with ASCII values in the range \u003ccode\u003e[33, 122]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e does not contain \u003ccode\u003e\u0026#39;\\\u0026quot;\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;\\\\\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "This problem is exactly like reversing a normal string except that there are certain characters that we have to simply skip. That should be easy enough to do if you know how to reverse a string using the two-pointer approach."
   ],
   "questionId": "953",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个字符串 \u003ccode\u003es\u003c/code\u003e ，根据下述规则反转字符串：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e所有非英文字母保留在原有位置。\u003c/li\u003e\n\t\u003cli\u003e所有英文字母（小写或大写）位置反转。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e返回反转后的 \u003ccode\u003es\u003c/code\u003e\u003cem\u003e 。\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003col\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"ab-cd\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"dc-ba\"\n\u003c/pre\u003e\n\n\u003col\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"a-bC-dEf-ghIj\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"j-Ih-gfE-dCba\"\n\u003c/pre\u003e\n\n\u003col\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"Test1ng-Leet=code-Q!\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"Qedo1ct-eeLg=ntse-T!\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 仅由 ASCII 值在范围 \u003ccode\u003e[33, 122]\u003c/code\u003e 的字符组成\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 不含 \u003ccode\u003e'\\\"'\u003c/code\u003e 或 \u003ccode\u003e'\\\\'\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "仅仅反转字母"
  },
  "reverse-string": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "reverse-string-ii": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e and an integer \u003ccode\u003ek\u003c/code\u003e, reverse the first \u003ccode\u003ek\u003c/code\u003e characters for every \u003ccode\u003e2k\u003c/code\u003e characters counting from the start of the string.\u003c/p\u003e\n\n\u003cp\u003eIf there are fewer than \u003ccode\u003ek\u003c/code\u003e characters left, reverse all of them. If there are less than \u003ccode\u003e2k\u003c/code\u003e but greater than or equal to \u003ccode\u003ek\u003c/code\u003e characters, then reverse the first \u003ccode\u003ek\u003c/code\u003e characters and leave the other as original.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"abcdefg\", k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"bacdfeg\"\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"abcd\", k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"bacd\"\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consists of only lowercase English letters.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "541",
   "similarQuestions": "[{\"title\": \"Reverse String\", \"titleSlug\": \"reverse-string\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u53cd\\u8f6c\\u5b57\\u7b26\\u4e32\"}, {\"title\": \"Reverse Words in a String III\", \"titleSlug\": \"reverse-words-in-a-string-iii\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u53cd\\u8f6c\\u5b57\\u7b26\\u4e32\\u4e2d\\u7684\\u5355\\u8bcd III\"}]",
   "topicTags": [
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个字符串 \u003ccode\u003es\u003c/code\u003e 和一个整数 \u003ccode\u003ek\u003c/code\u003e，从字符串开头算起，每计数至 \u003ccode\u003e2k\u003c/code\u003e 个字符，就反转这 \u003ccode\u003e2k\u003c/code\u003e 字符中的前 \u003ccode\u003ek\u003c/code\u003e 个字符。\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e如果剩余字符少于 \u003ccode\u003ek\u003c/code\u003e 个，则将剩余字符全部反转。\u003c/li\u003e\n\t\u003cli\u003e如果剩余字符小于 \u003ccode\u003e2k\u003c/code\u003e 但大于或等于 \u003ccode\u003ek\u003c/code\u003e 个，则反转前 \u003ccode\u003ek\u003c/code\u003e 个字符，其余字符保持原样。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"abcdefg\", k = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e\"bacdfeg\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"abcd\", k = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e\"bacd\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 仅由小写英文组成\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "反转字符串 II"
  },
  "reverse-vowels-of-a-string": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e, reverse only all the vowels in the string and return it.\u003c/p\u003e\n\n\u003cp\u003eThe vowels are \u003ccode\u003e\u0026#39;a\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;e\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;i\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;o\u0026#39;\u003c/code\u003e, and \u003ccode\u003e\u0026#39;u\u0026#39;\u003c/code\u003e, and they can appear in both cases.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"hello\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"holle\"\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e s = \"leetcode\"\n\u003cstrong\u003eOutput:\u003c/strong\u003e \"leotcede\"\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 3 * 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consist of \u003cstrong\u003eprintable ASCII\u003c/strong\u003e characters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "345",
   "similarQuestions": "[{\"title\": \"Reverse String\", \"titleSlug\": \"reverse-string\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u53cd\\u8f6c\\u5b57\\u7b26\\u4e32\"}, {\"title\": \"Remove Vowels from a String\", \"titleSlug\": \"remove-vowels-from-a-string\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5220\\u53bb\\u5b57\\u7b26\\u4e32\\u4e2d\\u7684\\u5143\\u97f3\"}]",
   "topicTags": [
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个字符串 \u003ccode\u003es\u003c/code\u003e ，仅反转字符串中的所有元音字母，并返回结果字符串。\u003c/p\u003e\n\n\u003cp\u003e元音字母包括 \u003ccode\u003e'a'\u003c/code\u003e、\u003ccode\u003e'e'\u003c/code\u003e、\u003ccode\u003e'i'\u003c/code\u003e、\u003ccode\u003e'o'\u003c/code\u003e、\u003ccode\u003e'u'\u003c/code\u003e，且可能以大小写两种形式出现。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"hello\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"holle\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"leetcode\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"leotcede\"\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 3 * 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 由 \u003cstrong\u003e可打印的 ASCII\u003c/strong\u003e 字符组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "反转字符串中的元音字母"
  },
  "reverse-words-in-a-string": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "reverse-words-in-a-string-iii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "richest-customer-wealth": {
   "content": "\u003cp\u003eYou are given an \u003ccode\u003em x n\u003c/code\u003e integer grid \u003ccode\u003eaccounts\u003c/code\u003e where \u003ccode\u003eaccounts[i][j]\u003c/code\u003e is the amount of money the \u003ccode\u003ei​​​​​\u003csup\u003e​​​​​​th\u003c/sup\u003e​​​​\u003c/code\u003e customer has in the \u003ccode\u003ej​​​​​\u003csup\u003e​​​​​​th\u003c/sup\u003e\u003c/code\u003e​​​​ bank. Return\u003cem\u003e the \u003cstrong\u003ewealth\u003c/strong\u003e that the richest customer has.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eA customer\u0026#39;s \u003cstrong\u003ewealth\u003c/strong\u003e is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum \u003cstrong\u003ewealth\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e accounts = [[1,2,3],[3,2,1]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 6\n\u003cstrong\u003eExplanation\u003c/strong\u003e\u003cstrong\u003e:\u003c/strong\u003e\n\u003ccode\u003e1st customer has wealth = 1 + 2 + 3 = 6\n\u003c/code\u003e\u003ccode\u003e2nd customer has wealth = 3 + 2 + 1 = 6\n\u003c/code\u003eBoth customers are considered the richest with a wealth of 6 each, so return 6.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e accounts = [[1,5],[7,3],[3,5]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 10\n\u003cstrong\u003eExplanation\u003c/strong\u003e: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e accounts = [[2,8,7],[7,1,3],[1,9,5]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 17\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em ==\u0026nbsp;accounts.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en ==\u0026nbsp;accounts[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 50\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= accounts[i][j] \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Calculate the wealth of each customer",
    "Find the maximum element in array."
   ],
   "questionId": "1791",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个 \u003ccode\u003em x n\u003c/code\u003e 的整数网格 \u003ccode\u003eaccounts\u003c/code\u003e ，其中 \u003ccode\u003eaccounts[i][j]\u003c/code\u003e 是第 \u003ccode\u003ei​​​​​\u003csup\u003e​​​​​​\u003c/sup\u003e​\u003c/code\u003e 位客户在第 \u003ccode\u003ej\u003c/code\u003e 家银行托管的资产数量。返回最富有客户所拥有的 \u003cstrong\u003e资产总量\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e客户的 \u003cstrong\u003e资产总量\u003c/strong\u003e 就是他们在各家银行托管的资产数量之和。最富有客户就是 \u003cstrong\u003e资产总量\u003c/strong\u003e 最大的客户。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003eaccounts = [[1,2,3],[3,2,1]]\n\u003cstrong\u003e输出：\u003c/strong\u003e6\n\u003cstrong\u003e解释：\u003c/strong\u003e\n\u003ccode\u003e第 1 位客户的资产总量 = 1 + 2 + 3 = 6\n第 2 位客户的资产总量 = 3 + 2 + 1 = 6\n\u003c/code\u003e两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003eaccounts = [[1,5],[7,3],[3,5]]\n\u003cstrong\u003e输出：\u003c/strong\u003e10\n\u003cstrong\u003e解释：\u003c/strong\u003e\n\u003ccode\u003e第 1 位客户的资产总量\u003c/code\u003e = 6\n\u003ccode\u003e第 2 位客户的资产总量\u003c/code\u003e = 10 \n\u003ccode\u003e第 3 位客户的资产总量\u003c/code\u003e = 8\n第 2 位客户是最富有的，资产总量是 10\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003eaccounts = [[2,8,7],[7,1,3],[1,9,5]]\n\u003cstrong\u003e输出：\u003c/strong\u003e17\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == accounts.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == accounts[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 50\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= accounts[i][j] \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "最富有客户的资产总量"
  },
  "roman-to-integer": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "rotate-array": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "rotate-image": {
   "content": "\u003cp\u003eYou are given an \u003ccode\u003en x n\u003c/code\u003e 2D \u003ccode\u003ematrix\u003c/code\u003e representing an image, rotate the image by \u003cstrong\u003e90\u003c/strong\u003e degrees (clockwise).\u003c/p\u003e\n\n\u003cp\u003eYou have to rotate the image \u003ca href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"\u003e\u003cstrong\u003ein-place\u003c/strong\u003e\u003c/a\u003e, which means you have to modify the input 2D matrix directly. \u003cstrong\u003eDO NOT\u003c/strong\u003e allocate another 2D matrix and do the rotation.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"width: 500px; height: 188px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[7,4,1],[8,5,2],[9,6,3]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"width: 500px; height: 201px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix.length == matrix[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= matrix[i][j] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "48",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个 \u003cem\u003en\u0026nbsp;\u003c/em\u003e×\u0026nbsp;\u003cem\u003en\u003c/em\u003e 的二维矩阵\u0026nbsp;\u003ccode\u003ematrix\u003c/code\u003e 表示一个图像。请你将图像顺时针旋转 90 度。\u003c/p\u003e\n\n\u003cp\u003e你必须在\u003cstrong\u003e\u003ca href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"\u003e 原地\u003c/a\u003e\u003c/strong\u003e 旋转图像，这意味着你需要直接修改输入的二维矩阵。\u003cstrong\u003e请不要 \u003c/strong\u003e使用另一个矩阵来旋转图像。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"height: 188px; width: 500px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[1,2,3],[4,5,6],[7,8,9]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[7,4,1],[8,5,2],[9,6,3]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"height: 201px; width: 500px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix.length == matrix[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= matrix[i][j] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n",
   "translatedTitle": "旋转图像"
  },
  "rotate-list": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003ehead\u003c/code\u003e of a linked\u0026nbsp;list, rotate the list to the right by \u003ccode\u003ek\u003c/code\u003e places.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg\" style=\"width: 450px; height: 191px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,4,5], k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e [4,5,1,2,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg\" style=\"width: 305px; height: 350px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [0,1,2], k = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2,0,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is in the range \u003ccode\u003e[0, 500]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= k \u0026lt;= 2 * 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "61",
   "similarQuestions": "[{\"title\": \"Rotate Array\", \"titleSlug\": \"rotate-array\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u8f6e\\u8f6c\\u6570\\u7ec4\"}, {\"title\": \"Split Linked List in Parts\", \"titleSlug\": \"split-linked-list-in-parts\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5206\\u9694\\u94fe\\u8868\"}]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个链表的头节点 \u003ccode\u003ehead\u003c/code\u003e ，旋转链表，将链表每个节点向右移动\u0026nbsp;\u003ccode\u003ek\u003c/code\u003e\u003cem\u003e\u0026nbsp;\u003c/em\u003e个位置。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg\" style=\"width: 450px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,4,5], k = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e[4,5,1,2,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg\" style=\"width: 305px; height: 350px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [0,1,2], k = 4\n\u003cstrong\u003e输出：\u003c/strong\u003e[2,0,1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点的数目在范围 \u003ccode\u003e[0, 500]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= k \u0026lt;= 2 * 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "旋转链表"
  },
  "rotate-string": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "rotated-digits": {
   "content": "\u003cp\u003eAn integer \u003ccode\u003ex\u003c/code\u003e is a \u003cstrong\u003egood\u003c/strong\u003e if after rotating each digit individually by 180 degrees, we get a valid number that is different from \u003ccode\u003ex\u003c/code\u003e. Each digit must be rotated - we cannot choose to leave it alone.\u003c/p\u003e\n\n\u003cp\u003eA number is valid if each digit remains a digit after rotation. For example:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003e1\u003c/code\u003e, and \u003ccode\u003e8\u003c/code\u003e rotate to themselves,\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e2\u003c/code\u003e and \u003ccode\u003e5\u003c/code\u003e rotate to each other (in this case they are rotated in a different direction, in other words, \u003ccode\u003e2\u003c/code\u003e or \u003ccode\u003e5\u003c/code\u003e gets mirrored),\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e6\u003c/code\u003e and \u003ccode\u003e9\u003c/code\u003e rotate to each other, and\u003c/li\u003e\n\t\u003cli\u003ethe rest of the numbers do not rotate to any other number and become invalid.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eGiven an integer \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003ethe number of \u003cstrong\u003egood\u003c/strong\u003e integers in the range \u003c/em\u003e\u003ccode\u003e[1, n]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 10\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003cstrong\u003eExplanation:\u003c/strong\u003e There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\nNote that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e 0\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= n \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "804",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。\u003c/p\u003e\n\n\u003cp\u003e如果一个数的每位数字被旋转以后仍然还是一个数字，\u0026nbsp;则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。\u003c/p\u003e\n\n\u003cp\u003e现在我们有一个正整数\u0026nbsp;\u003ccode\u003eN\u003c/code\u003e, 计算从\u0026nbsp;\u003ccode\u003e1\u003c/code\u003e 到\u0026nbsp;\u003ccode\u003eN\u003c/code\u003e 中有多少个数\u0026nbsp;X 是好数？\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e 10\n\u003cstrong\u003e输出:\u003c/strong\u003e 4\n\u003cstrong\u003e解释:\u003c/strong\u003e \n在[1, 10]中有四个好数： 2, 5, 6, 9。\n注意 1 和 10 不是好数, 因为他们在旋转之后不变。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eN\u0026nbsp;的取值范围是\u0026nbsp;\u003ccode\u003e[1, 10000]\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "旋转数字"
  },
  "same-tree": {
   "content": "\u003cp\u003eGiven the roots of two binary trees \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003eq\u003c/code\u003e, write a function to check if they are the same or not.\u003c/p\u003e\n\n\u003cp\u003eTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e p = [1,2,3], q = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e p = [1,2], q = [1,null,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e p = [1,2,1], q = [1,1,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in both trees is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "100",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给你两棵二叉树的根节点 \u003ccode\u003ep\u003c/code\u003e 和 \u003ccode\u003eq\u003c/code\u003e ，编写一个函数来检验这两棵树是否相同。\u003c/p\u003e\n\n\u003cp\u003e如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ep = [1,2,3], q = [1,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ep = [1,2], q = [1,null,2]\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ep = [1,2,1], q = [1,1,2]\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e两棵树上的节点数目都在范围 \u003ccode\u003e[0, 100]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u003c= Node.val \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "相同的树"
  },
  "search-a-2d-matrix": {
   "content": "\u003cp\u003eWrite an efficient algorithm that searches for a value \u003ccode\u003etarget\u003c/code\u003e in an \u003ccode\u003em x n\u003c/code\u003e integer matrix \u003ccode\u003ematrix\u003c/code\u003e. This matrix has the following properties:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eIntegers in each row are sorted from left to right.\u003c/li\u003e\n\t\u003cli\u003eThe first integer of each row is greater than the last integer of the previous row.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == matrix.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= matrix[i][j], target \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "74",
   "similarQuestions": "[{\"title\": \"Search a 2D Matrix II\", \"titleSlug\": \"search-a-2d-matrix-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u641c\\u7d22\\u4e8c\\u7ef4\\u77e9\\u9635 II\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    }
   ],
   "translatedContent": "\u003cp\u003e编写一个高效的算法来判断 \u003ccode\u003em x n\u003c/code\u003e 矩阵中，是否存在一个目标值。该矩阵具有如下特性：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e每行中的整数从左到右按升序排列。\u003c/li\u003e\n\t\u003cli\u003e每行的第一个整数大于前一行的最后一个整数。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == matrix.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= m, n \u003c= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u003c= matrix[i][j], target \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "搜索二维矩阵"
  },
  "search-in-a-binary-search-tree": {
   "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a binary search tree (BST) and an integer \u003ccode\u003eval\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFind the node in the BST that the node\u0026#39;s value equals \u003ccode\u003eval\u003c/code\u003e and return the subtree rooted with that node. If such a node does not exist, return \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg\" style=\"width: 422px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,2,7,1,3], val = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2,1,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg\" style=\"width: 422px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,2,7,1,3], val = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 5000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e7\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e is a binary search tree.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= val \u0026lt;= 10\u003csup\u003e7\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "783",
   "similarQuestions": "[{\"title\": \"Closest Binary Search Tree Value\", \"titleSlug\": \"closest-binary-search-tree-value\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6700\\u63a5\\u8fd1\\u7684\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u503c\"}, {\"title\": \"Insert into a Binary Search Tree\", \"titleSlug\": \"insert-into-a-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u4e2d\\u7684\\u63d2\\u5165\\u64cd\\u4f5c\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定二叉搜索树（BST）的根节点\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;和一个整数值\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003eval\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e你需要在 BST 中找到节点值等于\u0026nbsp;\u003ccode\u003eval\u003c/code\u003e\u0026nbsp;的节点。 返回以该节点为根的子树。 如果节点不存在，则返回\u003cmeta charset=\"UTF-8\" /\u003e\u0026nbsp;\u003ccode\u003enull\u003c/code\u003e\u0026nbsp;。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg\" style=\"height: 179px; width: 250px;\" /\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003eroot = [4,2,7,1,3], val = 2\n\u003cb\u003e输出：\u003c/b\u003e[2,1,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg\" style=\"height: 179px; width: 250px;\" /\u003e\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003eroot = [4,2,7,1,3], val = 5\n\u003cb\u003e输出：\u003c/b\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e数中节点数在\u0026nbsp;\u003ccode\u003e[1, 5000]\u003c/code\u003e\u0026nbsp;范围内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e7\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;是二叉搜索树\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= val \u0026lt;= 10\u003csup\u003e7\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉搜索树中的搜索"
  },
  "search-in-a-sorted-array-of-unknown-size": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "search-in-rotated-sorted-array": {
   "content": "\u003cp\u003eThere is an integer array \u003ccode\u003enums\u003c/code\u003e sorted in ascending order (with \u003cstrong\u003edistinct\u003c/strong\u003e values).\u003c/p\u003e\n\n\u003cp\u003ePrior to being passed to your function, \u003ccode\u003enums\u003c/code\u003e is \u003cstrong\u003epossibly rotated\u003c/strong\u003e at an unknown pivot index \u003ccode\u003ek\u003c/code\u003e (\u003ccode\u003e1 \u0026lt;= k \u0026lt; nums.length\u003c/code\u003e) such that the resulting array is \u003ccode\u003e[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\u003c/code\u003e (\u003cstrong\u003e0-indexed\u003c/strong\u003e). For example, \u003ccode\u003e[0,1,2,4,5,6,7]\u003c/code\u003e might be rotated at pivot index \u003ccode\u003e3\u003c/code\u003e and become \u003ccode\u003e[4,5,6,7,0,1,2]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eGiven the array \u003ccode\u003enums\u003c/code\u003e \u003cstrong\u003eafter\u003c/strong\u003e the possible rotation and an integer \u003ccode\u003etarget\u003c/code\u003e, return \u003cem\u003ethe index of \u003c/em\u003e\u003ccode\u003etarget\u003c/code\u003e\u003cem\u003e if it is in \u003c/em\u003e\u003ccode\u003enums\u003c/code\u003e\u003cem\u003e, or \u003c/em\u003e\u003ccode\u003e-1\u003c/code\u003e\u003cem\u003e if it is not in \u003c/em\u003e\u003ccode\u003enums\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou must write an algorithm with \u003ccode\u003eO(log n)\u003c/code\u003e runtime complexity.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [4,5,6,7,0,1,2], target = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [4,5,6,7,0,1,2], target = 3\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1], target = 0\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eAll values of \u003ccode\u003enums\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e is an ascending array that is possibly rotated.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= target \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "33",
   "similarQuestions": "[{\"title\": \"Search in Rotated Sorted Array II\", \"titleSlug\": \"search-in-rotated-sorted-array-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u641c\\u7d22\\u65cb\\u8f6c\\u6392\\u5e8f\\u6570\\u7ec4 II\"}, {\"title\": \"Find Minimum in Rotated Sorted Array\", \"titleSlug\": \"find-minimum-in-rotated-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5bfb\\u627e\\u65cb\\u8f6c\\u6392\\u5e8f\\u6570\\u7ec4\\u4e2d\\u7684\\u6700\\u5c0f\\u503c\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e整数数组 \u003ccode\u003enums\u003c/code\u003e 按升序排列，数组中的值 \u003cstrong\u003e互不相同\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e在传递给函数之前，\u003ccode\u003enums\u003c/code\u003e 在预先未知的某个下标 \u003ccode\u003ek\u003c/code\u003e（\u003ccode\u003e0 \u003c= k \u003c nums.length\u003c/code\u003e）上进行了 \u003cstrong\u003e旋转\u003c/strong\u003e，使数组变为 \u003ccode\u003e[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\u003c/code\u003e（下标 \u003cstrong\u003e从 0 开始\u003c/strong\u003e 计数）。例如， \u003ccode\u003e[0,1,2,4,5,6,7]\u003c/code\u003e 在下标 \u003ccode\u003e3\u003c/code\u003e 处经旋转后可能变为 \u003ccode\u003e[4,5,6,7,0,1,2]\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e给你 \u003cstrong\u003e旋转后\u003c/strong\u003e 的数组 \u003ccode\u003enums\u003c/code\u003e 和一个整数 \u003ccode\u003etarget\u003c/code\u003e ，如果 \u003ccode\u003enums\u003c/code\u003e 中存在这个目标值 \u003ccode\u003etarget\u003c/code\u003e ，则返回它的下标，否则返回 \u003ccode\u003e-1\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [\u003ccode\u003e4,5,6,7,0,1,2]\u003c/code\u003e, target = 0\n\u003cstrong\u003e输出：\u003c/strong\u003e4\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [\u003ccode\u003e4,5,6,7,0,1,2]\u003c/code\u003e, target = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e-1\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [1], target = 0\n\u003cstrong\u003e输出：\u003c/strong\u003e-1\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= nums.length \u003c= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10^4 \u003c= nums[i] \u003c= 10^4\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e 中的每个值都 \u003cstrong\u003e独一无二\u003c/strong\u003e\u003c/li\u003e\n\t\u003cli\u003e题目数据保证 \u003ccode\u003enums\u003c/code\u003e 在预先未知的某个下标上进行了旋转\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10^4 \u003c= target \u003c= 10^4\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你可以设计一个时间复杂度为 \u003ccode\u003eO(log n)\u003c/code\u003e 的解决方案吗？\u003c/p\u003e\n",
   "translatedTitle": "搜索旋转排序数组"
  },
  "search-insert-position": {
   "content": "\u003cp\u003eGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\u003c/p\u003e\n\n\u003cp\u003eYou must\u0026nbsp;write an algorithm with\u0026nbsp;\u003ccode\u003eO(log n)\u003c/code\u003e runtime complexity.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,3,5,6], target = 5\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,3,5,6], target = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,3,5,6], target = 7\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e contains \u003cstrong\u003edistinct\u003c/strong\u003e values sorted in \u003cstrong\u003eascending\u003c/strong\u003e order.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= target \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "35",
   "similarQuestions": "[{\"title\": \"First Bad Version\", \"titleSlug\": \"first-bad-version\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u7b2c\\u4e00\\u4e2a\\u9519\\u8bef\\u7684\\u7248\\u672c\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\u003c/p\u003e\n\n\u003cp\u003e请必须使用时间复杂度为 \u003ccode\u003eO(log n)\u003c/code\u003e 的算法。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1,3,5,6], target = 5\n\u003cstrong\u003e输出:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1,3,5,6], target = 2\n\u003cstrong\u003e输出:\u003c/strong\u003e 1\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1,3,5,6], target = 7\n\u003cstrong\u003e输出:\u003c/strong\u003e 4\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enums\u003c/code\u003e 为\u0026nbsp;\u003cstrong\u003e无重复元素\u0026nbsp;\u003c/strong\u003e的\u0026nbsp;\u003cstrong\u003e升序\u0026nbsp;\u003c/strong\u003e排列数组\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= target \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "搜索插入位置"
  },
  "second-highest-salary": {
   "content": "\u003cp\u003eTable: \u003ccode\u003eEmployee\u003c/code\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\nid is the primary key column for this table.\nEach row of this table contains information about the salary of an employee.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003eWrite an SQL query to report the second highest salary from the \u003ccode\u003eEmployee\u003c/code\u003e table. If there is no second highest salary, the query should report \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe query result format is in the following example.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\u003cstrong\u003eOutput:\u003c/strong\u003e \n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\n\u003cstrong\u003eOutput:\u003c/strong\u003e \n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| null                |\n+---------------------+\n\u003c/pre\u003e\n",
   "hints": [],
   "questionId": "176",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Database",
     "slug": "database",
     "translatedName": "数据库"
    }
   ],
   "translatedContent": "\u003ccode\u003eEmployee\u003c/code\u003e 表：\n\u003cdiv class=\"original__bRMd\"\u003e\n\u003cdiv\u003e\n\u003cpre\u003e\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\nid 是这个表的主键。\n表的每一行包含员工的工资信息。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e编写一个 SQL 查询，获取并返回 \u003ccode\u003eEmployee\u003c/code\u003e\u0026nbsp;表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 \u003ccode\u003enull\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e查询结果如下例所示。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e\nEmployee 表：\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n\u003cstrong\u003e输出：\u003c/strong\u003e\n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003e\nEmployee 表：\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\n\u003cstrong\u003e输出：\u003c/strong\u003e\n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| null                |\n+---------------------+\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n",
   "translatedTitle": "第二高的薪水"
  },
  "second-minimum-node-in-a-binary-tree": {
   "content": "\u003cp\u003eGiven a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly \u003ccode\u003etwo\u003c/code\u003e or \u003ccode\u003ezero\u003c/code\u003e sub-node. If the node has two sub-nodes, then this node\u0026#39;s value is the smaller value among its two sub-nodes. More formally, the property\u0026nbsp;\u003ccode\u003eroot.val = min(root.left.val, root.right.val)\u003c/code\u003e\u0026nbsp;always holds.\u003c/p\u003e\n\n\u003cp\u003eGiven such a binary tree, you need to output the \u003cb\u003esecond minimum\u003c/b\u003e value in the set made of all the nodes\u0026#39; value in the whole tree.\u003c/p\u003e\n\n\u003cp\u003eIf no such second minimum value exists, output -1 instead.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" style=\"width: 431px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,2,5,null,null,5,7]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 5\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The smallest value is 2, the second smallest value is 5.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" style=\"width: 321px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,2,2]\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The smallest value is 2, but there isn\u0026#39;t any second smallest value.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 25]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot.val == min(root.left.val, root.right.val)\u003c/code\u003e\u0026nbsp;for each internal node of the tree.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "671",
   "similarQuestions": "[{\"title\": \"Kth Smallest Element in a BST\", \"titleSlug\": \"kth-smallest-element-in-a-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u4e2d\\u7b2cK\\u5c0f\\u7684\\u5143\\u7d20\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为\u0026nbsp;\u003ccode\u003e2\u003c/code\u003e\u0026nbsp;或\u0026nbsp;\u003ccode\u003e0\u003c/code\u003e。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。\u003c/p\u003e\n\n\u003cp\u003e更正式地说，即\u0026nbsp;\u003ccode\u003eroot.val = min(root.left.val, root.right.val)\u003c/code\u003e 总成立。\u003c/p\u003e\n\n\u003cp\u003e给出这样的一个二叉树，你需要输出所有节点中的\u0026nbsp;\u003cstrong\u003e第二小的值 \u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e如果第二小的值不存在的话，输出 -1 \u003cstrong\u003e。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" style=\"height: 210px; width: 300px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [2,2,5,null,null,5,7]\n\u003cstrong\u003e输出：\u003c/strong\u003e5\n\u003cstrong\u003e解释：\u003c/strong\u003e最小的值是 2 ，第二小的值是 5 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" style=\"height: 113px; width: 200px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [2,2,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e-1\n\u003cstrong\u003e解释：\u003c/strong\u003e最小的值是 2, 但是不存在第二小的值。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数目在范围 \u003ccode\u003e[1, 25]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= Node.val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e对于树中每个节点 \u003ccode\u003eroot.val == min(root.left.val, root.right.val)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树中第二小的节点"
  },
  "serialize-and-deserialize-binary-tree": {
   "content": "\u003cp\u003eSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\u003c/p\u003e\n\n\u003cp\u003eDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eClarification:\u003c/strong\u003e The input/output format is the same as \u003ca href=\"/faq/#binary-tree\" target=\"_blank\"\u003ehow LeetCode serializes a binary tree\u003c/a\u003e. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3,null,null,4,5]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,3,null,null,4,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= Node.val \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "297",
   "similarQuestions": "[{\"title\": \"Encode and Decode Strings\", \"titleSlug\": \"encode-and-decode-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b57\\u7b26\\u4e32\\u7684\\u7f16\\u7801\\u4e0e\\u89e3\\u7801\"}, {\"title\": \"Serialize and Deserialize BST\", \"titleSlug\": \"serialize-and-deserialize-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5e8f\\u5217\\u5316\\u548c\\u53cd\\u5e8f\\u5217\\u5316\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\"}, {\"title\": \"Find Duplicate Subtrees\", \"titleSlug\": \"find-duplicate-subtrees\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5bfb\\u627e\\u91cd\\u590d\\u7684\\u5b50\\u6811\"}, {\"title\": \"Serialize and Deserialize N-ary Tree\", \"titleSlug\": \"serialize-and-deserialize-n-ary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u5e8f\\u5217\\u5316\\u548c\\u53cd\\u5e8f\\u5217\\u5316 N \\u53c9\\u6811\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Design",
     "slug": "design",
     "translatedName": "设计"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\u003c/p\u003e\n\n\u003cp\u003e请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示: \u003c/strong\u003e输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 \u003ca href=\"/faq/#binary-tree\"\u003eLeetCode 序列化二叉树的格式\u003c/a\u003e。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2,3,null,null,4,5]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2,3,null,null,4,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = []\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2]\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中结点数在范围 \u003ccode\u003e[0, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u003c= Node.val \u003c= 1000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "二叉树的序列化与反序列化"
  },
  "set-matrix-zeroes": {
   "content": "\u003cp\u003eGiven an \u003ccode\u003em x n\u003c/code\u003e integer matrix \u003ccode\u003ematrix\u003c/code\u003e, if an element is \u003ccode\u003e0\u003c/code\u003e, set its entire row and column to \u003ccode\u003e0\u003c/code\u003e\u0026#39;s.\u003c/p\u003e\n\n\u003cp\u003eYou must do it \u003ca href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"\u003ein place\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" style=\"width: 450px; height: 169px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[1,1,1],[1,0,1],[1,1,1]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[1,0,1],[0,0,0],[1,0,1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" style=\"width: 450px; height: 137px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == matrix.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix[0].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= matrix[i][j] \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eA straightforward solution using \u003ccode\u003eO(mn)\u003c/code\u003e space is probably a bad idea.\u003c/li\u003e\n\t\u003cli\u003eA simple improvement uses \u003ccode\u003eO(m + n)\u003c/code\u003e space, but still not the best solution.\u003c/li\u003e\n\t\u003cli\u003eCould you devise a constant space solution?\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "If any cell of the matrix has a zero we can record its row and column number using additional memory.\r\nBut if you don't want to use extra memory then you can manipulate the array instead. i.e. simulating exactly what the question says.",
    "Setting cell values to zero on the fly while iterating might lead to discrepancies. What if you use some other integer value as your marker?\r\nThere is still a better approach for this problem with 0(1) space.",
    "We could have used 2 sets to keep a record of rows/columns which need to be set to zero. But for an O(1) space solution, you can use one of the rows and and one of the columns to keep track of this information.",
    "We can use the first cell of every row and column as a flag. This flag would determine whether a row or column has been set to zero."
   ],
   "questionId": "73",
   "similarQuestions": "[{\"title\": \"Game of Life\", \"titleSlug\": \"game-of-life\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u751f\\u547d\\u6e38\\u620f\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个\u0026nbsp;\u003ccode\u003e\u003cem\u003em\u003c/em\u003e x \u003cem\u003en\u003c/em\u003e\u003c/code\u003e 的矩阵，如果一个元素为 \u003cstrong\u003e0 \u003c/strong\u003e，则将其所在行和列的所有元素都设为 \u003cstrong\u003e0\u003c/strong\u003e 。请使用 \u003cstrong\u003e\u003ca href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"\u003e原地\u003c/a\u003e\u003c/strong\u003e 算法\u003cstrong\u003e。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" style=\"width: 450px; height: 169px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[1,1,1],[1,0,1],[1,1,1]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[1,0,1],[0,0,0],[1,0,1]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" style=\"width: 450px; height: 137px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == matrix.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix[0].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= matrix[i][j] \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e一个直观的解决方案是使用 \u0026nbsp;\u003ccode\u003eO(\u003cem\u003em\u003c/em\u003e\u003cem\u003en\u003c/em\u003e)\u003c/code\u003e\u0026nbsp;的额外空间，但这并不是一个好的解决方案。\u003c/li\u003e\n\t\u003cli\u003e一个简单的改进方案是使用 \u003ccode\u003eO(\u003cem\u003em\u003c/em\u003e\u0026nbsp;+\u0026nbsp;\u003cem\u003en\u003c/em\u003e)\u003c/code\u003e 的额外空间，但这仍然不是最好的解决方案。\u003c/li\u003e\n\t\u003cli\u003e你能想出一个仅使用常量空间的解决方案吗？\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "矩阵置零"
  },
  "shan-chu-lian-biao-de-jie-dian-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "shu-zu-zhong-zhong-fu-de-shu-zi-lcof": {
   "content": "\u003cp\u003eEnglish description is not available for the problem. Please switch to Chinese.\u003c/p\u003e\r\n",
   "hints": [],
   "questionId": "100275",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e找出数组中重复的数字。\u003c/p\u003e\n\n\u003cp\u003e\u003cbr\u003e\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003e\n[2, 3, 1, 0, 2, 5, 3]\n\u003cstrong\u003e输出：\u003c/strong\u003e2 或 3 \n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e限制：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e2 \u0026lt;= n \u0026lt;= 100000\u003c/code\u003e\u003c/p\u003e\n",
   "translatedTitle": "数组中重复的数字"
  },
  "simplify-path": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "single-element-in-a-sorted-array": {
   "content": "\u003cp\u003eYou are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe single element that appears only once\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eYour solution must run in \u003ccode\u003eO(log n)\u003c/code\u003e time and \u003ccode\u003eO(1)\u003c/code\u003e space.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,1,2,3,3,4,4,8,8]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [3,3,7,7,10,11,11]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 10\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums[i] \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "540",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。\u003c/p\u003e\n\n\u003cp\u003e请你找出并返回只出现一次的那个数。\u003c/p\u003e\n\n\u003cp\u003e你设计的解决方案必须满足 \u003ccode\u003eO(log n)\u003c/code\u003e 时间复杂度和 \u003ccode\u003eO(1)\u003c/code\u003e 空间复杂度。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums = [1,1,2,3,3,4,4,8,8]\n\u003cstrong\u003e输出:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e nums =  [3,3,7,7,10,11,11]\n\u003cstrong\u003e输出:\u003c/strong\u003e 10\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cmeta charset=\"UTF-8\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums[i]\u0026nbsp;\u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "有序数组中的单一元素"
  },
  "single-number": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "sliding-window-maximum": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "sort-array-by-parity": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e, move all the even integers at the beginning of the array followed by all the odd integers.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003e\u003cstrong\u003eany array\u003c/strong\u003e that satisfies this condition\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [3,1,2,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2,4,3,1]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [0]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= nums[i] \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "941",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个非负整数数组 \u003ccode\u003eA\u003c/code\u003e，返回一个数组，在该数组中，\u0026nbsp;\u003ccode\u003eA\u003c/code\u003e 的所有偶数元素之后跟着所有奇数元素。\u003c/p\u003e\n\n\u003cp\u003e你可以返回满足此条件的任何数组作为答案。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入：\u003c/strong\u003e[3,1,2,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e[2,4,3,1]\n输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003col\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= A.length \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= A[i] \u0026lt;= 5000\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n",
   "translatedTitle": "按奇偶排序数组"
  },
  "sort-characters-by-frequency": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e, sort it in \u003cstrong\u003edecreasing order\u003c/strong\u003e based on the \u003cstrong\u003efrequency\u003c/strong\u003e of the characters. The \u003cstrong\u003efrequency\u003c/strong\u003e of a character is the number of times it appears in the string.\u003c/p\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe sorted string\u003c/em\u003e. If there are multiple answers, return \u003cem\u003eany of them\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;tree\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;eert\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026#39;e\u0026#39; appears twice while \u0026#39;r\u0026#39; and \u0026#39;t\u0026#39; both appear once.\nSo \u0026#39;e\u0026#39; must appear before both \u0026#39;r\u0026#39; and \u0026#39;t\u0026#39;. Therefore \u0026quot;eetr\u0026quot; is also a valid answer.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;cccaaa\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;aaaccc\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Both \u0026#39;c\u0026#39; and \u0026#39;a\u0026#39; appear three times, so both \u0026quot;cccaaa\u0026quot; and \u0026quot;aaaccc\u0026quot; are valid answers.\nNote that \u0026quot;cacaca\u0026quot; is incorrect, as the same characters must be together.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;Aabb\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;bbAa\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026quot;bbaA\u0026quot; is also a valid answer, but \u0026quot;Aabb\u0026quot; is incorrect.\nNote that \u0026#39;A\u0026#39; and \u0026#39;a\u0026#39; are treated as two different characters.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 5 * 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consists of uppercase and lowercase English letters and digits.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "451",
   "similarQuestions": "[{\"title\": \"Top K Frequent Elements\", \"titleSlug\": \"top-k-frequent-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u524d K \\u4e2a\\u9ad8\\u9891\\u5143\\u7d20\"}, {\"title\": \"First Unique Character in a String\", \"titleSlug\": \"first-unique-character-in-a-string\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5b57\\u7b26\\u4e32\\u4e2d\\u7684\\u7b2c\\u4e00\\u4e2a\\u552f\\u4e00\\u5b57\\u7b26\"}]",
   "topicTags": [
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Bucket Sort",
     "slug": "bucket-sort",
     "translatedName": "桶排序"
    },
    {
     "name": "Counting",
     "slug": "counting",
     "translatedName": "计数"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    },
    {
     "name": "Heap (Priority Queue)",
     "slug": "heap-priority-queue",
     "translatedName": "堆（优先队列）"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个字符串 \u003ccode\u003es\u003c/code\u003e ，根据字符出现的 \u003cstrong\u003e频率\u003c/strong\u003e 对其进行 \u003cstrong\u003e降序排序\u003c/strong\u003e 。一个字符出现的 \u003cstrong\u003e频率\u003c/strong\u003e 是它出现在字符串中的次数。\u003c/p\u003e\n\n\u003cp\u003e返回 \u003cem\u003e已排序的字符串\u0026nbsp;\u003c/em\u003e。如果有多个答案，返回其中任何一个。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003es = \"tree\"\n\u003cstrong\u003e输出: \u003c/strong\u003e\"eert\"\n\u003cstrong\u003e解释: \u003c/strong\u003e'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003es = \"cccaaa\"\n\u003cstrong\u003e输出: \u003c/strong\u003e\"cccaaa\"\n\u003cstrong\u003e解释: \u003c/strong\u003e'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003es = \"Aabb\"\n\u003cstrong\u003e输出: \u003c/strong\u003e\"bbAa\"\n\u003cstrong\u003e解释: \u003c/strong\u003e此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 5 * 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e\u0026nbsp;由大小写英文字母和数字组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "根据字符出现频率排序"
  },
  "sort-colors": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "sort-list": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003ehead\u003c/code\u003e of a linked list, return \u003cem\u003ethe list after sorting it in \u003cstrong\u003eascending order\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 450px; height: 194px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [4,2,1,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,3,4]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 550px; height: 184px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [-1,5,3,4,0]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [-1,0,3,4,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the list is in the range \u003ccode\u003e[0, 5 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e Can you sort the linked list in \u003ccode\u003eO(n logn)\u003c/code\u003e time and \u003ccode\u003eO(1)\u003c/code\u003e memory (i.e. constant space)?\u003c/p\u003e\n",
   "hints": [],
   "questionId": "148",
   "similarQuestions": "[{\"title\": \"Merge Two Sorted Lists\", \"titleSlug\": \"merge-two-sorted-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5408\\u5e76\\u4e24\\u4e2a\\u6709\\u5e8f\\u94fe\\u8868\"}, {\"title\": \"Sort Colors\", \"titleSlug\": \"sort-colors\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u989c\\u8272\\u5206\\u7c7b\"}, {\"title\": \"Insertion Sort List\", \"titleSlug\": \"insertion-sort-list\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5bf9\\u94fe\\u8868\\u8fdb\\u884c\\u63d2\\u5165\\u6392\\u5e8f\"}]",
   "topicTags": [
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Divide and Conquer",
     "slug": "divide-and-conquer",
     "translatedName": "分治"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    },
    {
     "name": "Merge Sort",
     "slug": "merge-sort",
     "translatedName": "归并排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给你链表的头结点\u0026nbsp;\u003ccode\u003ehead\u003c/code\u003e\u0026nbsp;，请将其按 \u003cstrong\u003e升序\u003c/strong\u003e 排列并返回 \u003cstrong\u003e排序后的链表\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cul\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 450px;\" /\u003e\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003ehead = [4,2,1,3]\n\u003cb\u003e输出：\u003c/b\u003e[1,2,3,4]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 550px;\" /\u003e\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003ehead = [-1,5,3,4,0]\n\u003cb\u003e输出：\u003c/b\u003e[-1,0,3,4,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003ehead = []\n\u003cb\u003e输出：\u003c/b\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e提示：\u003c/b\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点的数目在范围\u0026nbsp;\u003ccode\u003e[0, 5 * 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e\u0026nbsp;内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e\u0026nbsp;\u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e进阶：\u003c/b\u003e你可以在\u0026nbsp;\u003ccode\u003eO(n\u0026nbsp;log\u0026nbsp;n)\u003c/code\u003e 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\u003c/p\u003e\n",
   "translatedTitle": "排序链表"
  },
  "spiral-matrix": {
   "content": "\u003cp\u003eGiven an \u003ccode\u003em x n\u003c/code\u003e \u003ccode\u003ematrix\u003c/code\u003e, return \u003cem\u003eall elements of the\u003c/em\u003e \u003ccode\u003ematrix\u003c/code\u003e \u003cem\u003ein spiral order\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,3,6,9,8,7,4,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2,3,4,8,12,11,10,9,5,6,7]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == matrix.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 10\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= matrix[i][j] \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Well for some problems, the best way really is to come up with some algorithms for simulation. Basically, you need to simulate what the problem asks us to do.",
    "We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column and then we move inwards by 1 and then repeat. That's all, that is all the simulation that we need.",
    "Think about when you want to switch the progress on one of the indexes. If you progress on \u003cpre\u003ei\u003c/pre\u003e out of \u003cpre\u003e[i, j]\u003c/pre\u003e, you'd be shifting in the same column. Similarly, by changing values for \u003cpre\u003ej\u003c/pre\u003e, you'd be shifting in the same row.\r\nAlso, keep track of the end of a boundary so that you can move inwards and then keep repeating. It's always best to run the simulation on edge cases like a single column or a single row to see if anything breaks or not."
   ],
   "questionId": "54",
   "similarQuestions": "[{\"title\": \"Spiral Matrix II\", \"titleSlug\": \"spiral-matrix-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u87ba\\u65cb\\u77e9\\u9635 II\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    },
    {
     "name": "Simulation",
     "slug": "simulation",
     "translatedName": "模拟"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个 \u003ccode\u003em\u003c/code\u003e 行 \u003ccode\u003en\u003c/code\u003e 列的矩阵 \u003ccode\u003ematrix\u003c/code\u003e ，请按照 \u003cstrong\u003e顺时针螺旋顺序\u003c/strong\u003e ，返回矩阵中的所有元素。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[1,2,3],[4,5,6],[7,8,9]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2,3,6,9,8,7,4,5]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ematrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2,3,4,8,12,11,10,9,5,6,7]\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == matrix.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en == matrix[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= m, n \u003c= 10\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u003c= matrix[i][j] \u003c= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "螺旋矩阵"
  },
  "spiral-matrix-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "split-linked-list-in-parts": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "sqrtx": {
   "content": "\u003cp\u003eGiven a non-negative integer \u003ccode\u003ex\u003c/code\u003e,\u0026nbsp;compute and return \u003cem\u003ethe square root of\u003c/em\u003e \u003ccode\u003ex\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSince the return type\u0026nbsp;is an integer, the decimal digits are \u003cstrong\u003etruncated\u003c/strong\u003e, and only \u003cstrong\u003ethe integer part\u003c/strong\u003e of the result\u0026nbsp;is returned.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u0026nbsp;\u003c/strong\u003eYou are not allowed to use any built-in exponent function or operator, such as \u003ccode\u003epow(x, 0.5)\u003c/code\u003e or\u0026nbsp;\u003ccode\u003ex ** 0.5\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e x = 4\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e x = 8\n\u003cstrong\u003eOutput:\u003c/strong\u003e 2\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= x \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "Try exploring all integers. (Credits: @annujoshi)",
    "Use the sorted property of integers to reduced the search space. (Credits: @annujoshi)"
   ],
   "questionId": "69",
   "similarQuestions": "[{\"title\": \"Pow(x, n)\", \"titleSlug\": \"powx-n\", \"difficulty\": \"Medium\", \"translatedTitle\": \"Pow(x, n)\"}, {\"title\": \"Valid Perfect Square\", \"titleSlug\": \"valid-perfect-square\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u6709\\u6548\\u7684\\u5b8c\\u5168\\u5e73\\u65b9\\u6570\"}]",
   "topicTags": [
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个非负整数 \u003ccode\u003ex\u003c/code\u003e ，计算并返回\u0026nbsp;\u003ccode\u003ex\u003c/code\u003e\u0026nbsp;的 \u003cstrong\u003e算术平方根\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e由于返回类型是整数，结果只保留 \u003cstrong\u003e整数部分 \u003c/strong\u003e，小数部分将被 \u003cstrong\u003e舍去 。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e不允许使用任何内置指数函数和算符，例如 \u003ccode\u003epow(x, 0.5)\u003c/code\u003e 或者 \u003ccode\u003ex ** 0.5\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ex = 4\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ex = 8\n\u003cstrong\u003e输出：\u003c/strong\u003e2\n\u003cstrong\u003e解释：\u003c/strong\u003e8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= x \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "x 的平方根 "
  },
  "string-compression": {
   "content": "\u003cp\u003eGiven an array of characters \u003ccode\u003echars\u003c/code\u003e, compress it using the following algorithm:\u003c/p\u003e\n\n\u003cp\u003eBegin with an empty string \u003ccode\u003es\u003c/code\u003e. For each group of \u003cstrong\u003econsecutive repeating characters\u003c/strong\u003e in \u003ccode\u003echars\u003c/code\u003e:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eIf the group\u0026#39;s length is \u003ccode\u003e1\u003c/code\u003e, append the character to \u003ccode\u003es\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eOtherwise, append the character followed by the group\u0026#39;s length.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe compressed string \u003ccode\u003es\u003c/code\u003e \u003cstrong\u003eshould not be returned separately\u003c/strong\u003e, but instead, be stored \u003cstrong\u003ein the input character array \u003ccode\u003echars\u003c/code\u003e\u003c/strong\u003e. Note that group lengths that are \u003ccode\u003e10\u003c/code\u003e or longer will be split into multiple characters in \u003ccode\u003echars\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAfter you are done \u003cstrong\u003emodifying the input array,\u003c/strong\u003e return \u003cem\u003ethe new length of the array\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou must write an algorithm that uses only constant extra space.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e chars = [\u0026quot;a\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;c\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e Return 6, and the first 6 characters of the input array should be: [\u0026quot;a\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;3\u0026quot;]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The groups are \u0026quot;aa\u0026quot;, \u0026quot;bb\u0026quot;, and \u0026quot;ccc\u0026quot;. This compresses to \u0026quot;a2b2c3\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e chars = [\u0026quot;a\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e Return 1, and the first character of the input array should be: [\u0026quot;a\u0026quot;]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The only group is \u0026quot;a\u0026quot;, which remains uncompressed since it\u0026#39;s a single character.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e chars = [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;b\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e Return 4, and the first 4 characters of the input array should be: [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;2\u0026quot;].\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The groups are \u0026quot;a\u0026quot; and \u0026quot;bbbbbbbbbbbb\u0026quot;. This compresses to \u0026quot;ab12\u0026quot;.\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= chars.length \u0026lt;= 2000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003echars[i]\u003c/code\u003e is a lowercase English letter, uppercase English letter, digit, or symbol.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "How do you know if you are at the end of a consecutive group of characters?"
   ],
   "questionId": "443",
   "similarQuestions": "[{\"title\": \"Count and Say\", \"titleSlug\": \"count-and-say\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5916\\u89c2\\u6570\\u5217\"}, {\"title\": \"Encode and Decode Strings\", \"titleSlug\": \"encode-and-decode-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5b57\\u7b26\\u4e32\\u7684\\u7f16\\u7801\\u4e0e\\u89e3\\u7801\"}, {\"title\": \"Design Compressed String Iterator\", \"titleSlug\": \"design-compressed-string-iterator\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u8fed\\u4ee3\\u538b\\u7f29\\u5b57\\u7b26\\u4e32\"}]",
   "topicTags": [
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个字符数组 \u003ccode\u003echars\u003c/code\u003e ，请使用下述算法压缩：\u003c/p\u003e\n\n\u003cp\u003e从一个空字符串 \u003ccode\u003es\u003c/code\u003e 开始。对于 \u003ccode\u003echars\u003c/code\u003e 中的每组 \u003cstrong\u003e连续重复字符\u003c/strong\u003e ：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e如果这一组长度为 \u003ccode\u003e1\u003c/code\u003e ，则将字符追加到 \u003ccode\u003es\u003c/code\u003e 中。\u003c/li\u003e\n\t\u003cli\u003e否则，需要向 \u003ccode\u003es\u003c/code\u003e 追加字符，后跟这一组的长度。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e压缩后得到的字符串 \u003ccode\u003es\u003c/code\u003e \u003cstrong\u003e不应该直接返回\u003c/strong\u003e ，需要转储到字符数组 \u003ccode\u003echars\u003c/code\u003e 中。需要注意的是，如果组长度为 \u003ccode\u003e10\u003c/code\u003e 或 \u003ccode\u003e10\u003c/code\u003e 以上，则在 \u003ccode\u003echars\u003c/code\u003e 数组中会被拆分为多个字符。\u003c/p\u003e\n\n\u003cp\u003e请在 \u003cstrong\u003e修改完输入数组后\u003c/strong\u003e ，返回该数组的新长度。\u003c/p\u003e\n\n\u003cp\u003e你必须设计并实现一个只使用常量额外空间的算法来解决此问题。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003echars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n\u003cstrong\u003e输出：\u003c/strong\u003e返回 6 ，输入数组的前 6 个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n\u003cstrong\u003e解释：\u003c/strong\u003e\"aa\" 被 \"a2\" 替代。\"bb\" 被 \"b2\" 替代。\"ccc\" 被 \"c3\" 替代。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003echars = [\"a\"]\n\u003cstrong\u003e输出：\u003c/strong\u003e返回 1 ，输入数组的前 1 个字符应该是：[\"a\"]\n\u003cstrong\u003e解释：\u003c/strong\u003e唯一的组是“a”，它保持未压缩，因为它是一个字符。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003echars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n\u003cstrong\u003e输出：\u003c/strong\u003e返回 4 ，输入数组的前 4 个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。\n\u003cstrong\u003e解释：\u003c/strong\u003e由于字符 \"a\" 不重复，所以不会被压缩。\"bbbbbbbbbbbb\" 被 “b12” 替代。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= chars.length \u0026lt;= 2000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003echars[i]\u003c/code\u003e 可以是小写英文字母、大写英文字母、数字或符号\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "压缩字符串"
  },
  "string-to-integer-atoi": {
   "content": "\u003cp\u003eImplement the \u003ccode\u003emyAtoi(string s)\u003c/code\u003e function, which converts a string to a 32-bit signed integer (similar to C/C++\u0026#39;s \u003ccode\u003eatoi\u003c/code\u003e function).\u003c/p\u003e\n\n\u003cp\u003eThe algorithm for \u003ccode\u003emyAtoi(string s)\u003c/code\u003e is as follows:\u003c/p\u003e\n\n\u003col\u003e\n\t\u003cli\u003eRead in and ignore any leading whitespace.\u003c/li\u003e\n\t\u003cli\u003eCheck if the next character (if not already at the end of the string) is \u003ccode\u003e\u0026#39;-\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;+\u0026#39;\u003c/code\u003e. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\u003c/li\u003e\n\t\u003cli\u003eRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\u003c/li\u003e\n\t\u003cli\u003eConvert these digits into an integer (i.e. \u003ccode\u003e\u0026quot;123\u0026quot; -\u0026gt; 123\u003c/code\u003e, \u003ccode\u003e\u0026quot;0032\u0026quot; -\u0026gt; 32\u003c/code\u003e). If no digits were read, then the integer is \u003ccode\u003e0\u003c/code\u003e. Change the sign as necessary (from step 2).\u003c/li\u003e\n\t\u003cli\u003eIf the integer is out of the 32-bit signed integer range \u003ccode\u003e[-2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e - 1]\u003c/code\u003e, then clamp the integer so that it remains in the range. Specifically, integers less than \u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e\u003c/code\u003e should be clamped to \u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e\u003c/code\u003e, and integers greater than \u003ccode\u003e2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e should be clamped to \u003ccode\u003e2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eReturn the integer as the final result.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eOnly the space character \u003ccode\u003e\u0026#39; \u0026#39;\u003c/code\u003e is considered a whitespace character.\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eDo not ignore\u003c/strong\u003e any characters other than the leading whitespace or the rest of the string after the digits.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;42\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 42\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \u0026quot;42\u0026quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: \u0026quot;42\u0026quot; (no characters read because there is neither a \u0026#39;-\u0026#39; nor \u0026#39;+\u0026#39;)\n         ^\nStep 3: \u0026quot;\u003cu\u003e42\u003c/u\u003e\u0026quot; (\u0026quot;42\u0026quot; is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e - 1], the final result is 42.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;   -42\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e -42\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nStep 1: \u0026quot;\u003cu\u003e   \u003c/u\u003e-42\u0026quot; (leading whitespace is read and ignored)\n            ^\nStep 2: \u0026quot;   \u003cu\u003e-\u003c/u\u003e42\u0026quot; (\u0026#39;-\u0026#39; is read, so the result should be negative)\n             ^\nStep 3: \u0026quot;   -\u003cu\u003e42\u003c/u\u003e\u0026quot; (\u0026quot;42\u0026quot; is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e - 1], the final result is -42.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;4193 with words\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e 4193\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nStep 1: \u0026quot;4193 with words\u0026quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: \u0026quot;4193 with words\u0026quot; (no characters read because there is neither a \u0026#39;-\u0026#39; nor \u0026#39;+\u0026#39;)\n         ^\nStep 3: \u0026quot;\u003cu\u003e4193\u003c/u\u003e with words\u0026quot; (\u0026quot;4193\u0026quot; is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e - 1], the final result is 4193.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= s.length \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consists of English letters (lower-case and upper-case), digits (\u003ccode\u003e0-9\u003c/code\u003e), \u003ccode\u003e\u0026#39; \u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;+\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;-\u0026#39;\u003c/code\u003e, and \u003ccode\u003e\u0026#39;.\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "8",
   "similarQuestions": "[{\"title\": \"Reverse Integer\", \"titleSlug\": \"reverse-integer\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6574\\u6570\\u53cd\\u8f6c\"}, {\"title\": \"Valid Number\", \"titleSlug\": \"valid-number\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6709\\u6548\\u6570\\u5b57\"}]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e请你来实现一个\u0026nbsp;\u003ccode\u003emyAtoi(string s)\u003c/code\u003e\u0026nbsp;函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 \u003ccode\u003eatoi\u003c/code\u003e 函数）。\u003c/p\u003e\n\n\u003cp\u003e函数\u0026nbsp;\u003ccode\u003emyAtoi(string s)\u003c/code\u003e 的算法如下：\u003c/p\u003e\n\n\u003col\u003e\n\t\u003cli\u003e读入字符串并丢弃无用的前导空格\u003c/li\u003e\n\t\u003cli\u003e检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\u003c/li\u003e\n\t\u003cli\u003e读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\u003c/li\u003e\n\t\u003cli\u003e将前面步骤读入的这些数字转换为整数（即，\"123\" -\u0026gt; 123， \"0032\" -\u0026gt; 32）。如果没有读入数字，则整数为 \u003ccode\u003e0\u003c/code\u003e 。必要时更改符号（从步骤 2 开始）。\u003c/li\u003e\n\t\u003cli\u003e如果整数数超过 32 位有符号整数范围 \u003ccode\u003e[−2\u003csup\u003e31\u003c/sup\u003e,\u0026nbsp; 2\u003csup\u003e31\u0026nbsp;\u003c/sup\u003e− 1]\u003c/code\u003e ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 \u003ccode\u003e−2\u003csup\u003e31\u003c/sup\u003e\u003c/code\u003e 的整数应该被固定为 \u003ccode\u003e−2\u003csup\u003e31\u003c/sup\u003e\u003c/code\u003e ，大于 \u003ccode\u003e2\u003csup\u003e31\u0026nbsp;\u003c/sup\u003e− 1\u003c/code\u003e 的整数应该被固定为 \u003ccode\u003e2\u003csup\u003e31\u0026nbsp;\u003c/sup\u003e− 1\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e返回整数作为最终结果。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e本题中的空白字符只包括空格字符 \u003ccode\u003e' '\u003c/code\u003e 。\u003c/li\u003e\n\t\u003cli\u003e除前导空格或数字后的其余字符串外，\u003cstrong\u003e请勿忽略\u003c/strong\u003e 任何其他字符。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"42\"\n\u003cstrong\u003e输出：\u003c/strong\u003e42\n\u003cstrong\u003e解释：\u003c/strong\u003e加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"\u003cu\u003e42\u003c/u\u003e\"（读入 \"42\"）\n           ^\n解析得到整数 42 。\n由于 \"42\" 在范围 [-2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e - 1] 内，最终结果为 42 。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"   -42\"\n\u003cstrong\u003e输出：\u003c/strong\u003e-42\n\u003cstrong\u003e解释：\u003c/strong\u003e\n第 1 步：\"\u003cu\u003e\u003cstrong\u003e   \u003c/strong\u003e\u003c/u\u003e-42\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   \u003cu\u003e\u003cstrong\u003e-\u003c/strong\u003e\u003c/u\u003e42\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   \u003cu\u003e\u003cstrong\u003e-42\u003c/strong\u003e\u003c/u\u003e\"（读入 \"42\"）\n               ^\n解析得到整数 -42 。\n由于 \"-42\" 在范围 [-2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e - 1] 内，最终结果为 -42 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"4193 with words\"\n\u003cstrong\u003e输出：\u003c/strong\u003e4193\n\u003cstrong\u003e解释：\u003c/strong\u003e\n第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"\u003cu\u003e4193\u003c/u\u003e with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 \"4193\" 在范围 [-2\u003csup\u003e31\u003c/sup\u003e, 2\u003csup\u003e31\u003c/sup\u003e - 1] 内，最终结果为 4193 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= s.length \u0026lt;= 200\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 由英文字母（大写和小写）、数字（\u003ccode\u003e0-9\u003c/code\u003e）、\u003ccode\u003e' '\u003c/code\u003e、\u003ccode\u003e'+'\u003c/code\u003e、\u003ccode\u003e'-'\u003c/code\u003e 和 \u003ccode\u003e'.'\u003c/code\u003e 组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "字符串转换整数 (atoi)"
  },
  "student-attendance-record-i": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "subarray-sum-equals-k": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "subdomain-visit-count": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "subsets": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "subsets-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "sum-lists-lcci": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "sum-of-square-numbers": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "sum-of-two-integers": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "sum-root-to-leaf-numbers": {
   "content": "\u003cp\u003eYou are given the \u003ccode\u003eroot\u003c/code\u003e of a binary tree containing digits from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e9\u003c/code\u003e only.\u003c/p\u003e\n\n\u003cp\u003eEach root-to-leaf path in the tree represents a number.\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFor example, the root-to-leaf path \u003ccode\u003e1 -\u0026gt; 2 -\u0026gt; 3\u003c/code\u003e represents the number \u003ccode\u003e123\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn \u003cem\u003ethe total sum of all root-to-leaf numbers\u003c/em\u003e. Test cases are generated so that the answer will fit in a \u003cstrong\u003e32-bit\u003c/strong\u003e integer.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003eleaf\u003c/strong\u003e node is a node with no children.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 25\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nThe root-to-leaf path \u003ccode\u003e1-\u0026gt;2\u003c/code\u003e represents the number \u003ccode\u003e12\u003c/code\u003e.\nThe root-to-leaf path \u003ccode\u003e1-\u0026gt;3\u003c/code\u003e represents the number \u003ccode\u003e13\u003c/code\u003e.\nTherefore, sum = 12 + 13 = \u003ccode\u003e25\u003c/code\u003e.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [4,9,0,5,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e 1026\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\nThe root-to-leaf path \u003ccode\u003e4-\u0026gt;9-\u0026gt;5\u003c/code\u003e represents the number 495.\nThe root-to-leaf path \u003ccode\u003e4-\u0026gt;9-\u0026gt;1\u003c/code\u003e represents the number 491.\nThe root-to-leaf path \u003ccode\u003e4-\u0026gt;0\u003c/code\u003e represents the number 40.\nTherefore, sum = 495 + 491 + 40 = \u003ccode\u003e1026\u003c/code\u003e.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 1000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 9\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe depth of the tree will not exceed \u003ccode\u003e10\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "129",
   "similarQuestions": "[{\"title\": \"Path Sum\", \"titleSlug\": \"path-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u8def\\u5f84\\u603b\\u548c\"}, {\"title\": \"Binary Tree Maximum Path Sum\", \"titleSlug\": \"binary-tree-maximum-path-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u4e2d\\u7684\\u6700\\u5927\\u8def\\u5f84\\u548c\"}, {\"title\": \"Smallest String Starting From Leaf\", \"titleSlug\": \"smallest-string-starting-from-leaf\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4ece\\u53f6\\u7ed3\\u70b9\\u5f00\\u59cb\\u7684\\u6700\\u5c0f\\u5b57\\u7b26\\u4e32\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "给你一个二叉树的根节点 \u003ccode\u003eroot\u003c/code\u003e ，树中每个节点都存放有一个 \u003ccode\u003e0\u003c/code\u003e 到 \u003ccode\u003e9\u003c/code\u003e 之间的数字。\n\u003cdiv class=\"original__bRMd\"\u003e\n\u003cdiv\u003e\n\u003cp\u003e每条从根节点到叶节点的路径都代表一个数字：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e例如，从根节点到叶节点的路径 \u003ccode\u003e1 -\u003e 2 -\u003e 3\u003c/code\u003e 表示数字 \u003ccode\u003e123\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e计算从根节点到叶节点生成的 \u003cstrong\u003e所有数字之和\u003c/strong\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e叶节点\u003c/strong\u003e 是指没有子节点的节点。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2,3]\n\u003cstrong\u003e输出：\u003c/strong\u003e25\n\u003cstrong\u003e解释：\u003c/strong\u003e\n从根到叶子节点路径 \u003ccode\u003e1-\u003e2\u003c/code\u003e 代表数字 \u003ccode\u003e12\u003c/code\u003e\n从根到叶子节点路径 \u003ccode\u003e1-\u003e3\u003c/code\u003e 代表数字 \u003ccode\u003e13\u003c/code\u003e\n因此，数字总和 = 12 + 13 = \u003ccode\u003e25\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [4,9,0,5,1]\n\u003cstrong\u003e输出：\u003c/strong\u003e1026\n\u003cstrong\u003e解释：\u003c/strong\u003e\n从根到叶子节点路径 \u003ccode\u003e4-\u003e9-\u003e5\u003c/code\u003e 代表数字 495\n从根到叶子节点路径 \u003ccode\u003e4-\u003e9-\u003e1\u003c/code\u003e 代表数字 491\n从根到叶子节点路径 \u003ccode\u003e4-\u003e0\u003c/code\u003e 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = \u003ccode\u003e1026\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点的数目在范围 \u003ccode\u003e[1, 1000]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u003c= Node.val \u003c= 9\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e树的深度不超过 \u003ccode\u003e10\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n",
   "translatedTitle": "求根节点到叶节点数字之和"
  },
  "summary-ranges": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "surrounded-regions": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "swap-nodes-in-pairs": {
   "content": "\u003cp\u003eGiven a\u0026nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without\u0026nbsp;modifying the values in the list\u0026#39;s nodes (i.e., only nodes themselves may be changed.)\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1,2,3,4]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [2,1,4,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = []\n\u003cstrong\u003eOutput:\u003c/strong\u003e []\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e head = [1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the\u0026nbsp;list\u0026nbsp;is in the range \u003ccode\u003e[0, 100]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "24",
   "similarQuestions": "[{\"title\": \"Reverse Nodes in k-Group\", \"titleSlug\": \"reverse-nodes-in-k-group\", \"difficulty\": \"Hard\", \"translatedTitle\": \"K \\u4e2a\\u4e00\\u7ec4\\u7ffb\\u8f6c\\u94fe\\u8868\"}]",
   "topicTags": [
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "Linked List",
     "slug": "linked-list",
     "translatedName": "链表"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1,2,3,4]\n\u003cstrong\u003e输出：\u003c/strong\u003e[2,1,4,3]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = []\n\u003cstrong\u003e输出：\u003c/strong\u003e[]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ehead = [1]\n\u003cstrong\u003e输出：\u003c/strong\u003e[1]\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e链表中节点的数目在范围 \u003ccode\u003e[0, 100]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "两两交换链表中的节点"
  },
  "symmetric-tree": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, \u003cem\u003echeck whether it is a mirror of itself\u003c/em\u003e (i.e., symmetric around its center).\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg\" style=\"width: 354px; height: 291px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,2,3,4,4,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg\" style=\"width: 308px; height: 258px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [1,2,2,null,3,null,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 1000]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you solve it both recursively and iteratively?",
   "hints": [],
   "questionId": "101",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个二叉树的根节点 \u003ccode\u003eroot\u003c/code\u003e ， 检查它是否轴对称。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg\" style=\"width: 354px; height: 291px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2,2,3,4,4,3]\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg\" style=\"width: 308px; height: 258px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [1,2,2,null,3,null,3]\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数目在范围 \u003ccode\u003e[1, 1000]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-100 \u0026lt;= Node.val \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你可以运用递归和迭代两种方法解决这个问题吗？\u003c/p\u003e\n",
   "translatedTitle": "对称二叉树"
  },
  "tenth-line": {
   "content": "\u003cp\u003eGiven a text file\u0026nbsp;\u003ccode\u003efile.txt\u003c/code\u003e, print\u0026nbsp;just the 10th line of the\u0026nbsp;file.\u003c/p\u003e\r\n\r\n\u003cp\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\r\n\r\n\u003cp\u003eAssume that \u003ccode\u003efile.txt\u003c/code\u003e has the following content:\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\nLine 1\r\nLine 2\r\nLine 3\r\nLine 4\r\nLine 5\r\nLine 6\r\nLine 7\r\nLine 8\r\nLine 9\r\nLine 10\r\n\u003c/pre\u003e\r\n\r\n\u003cp\u003eYour script should output the tenth line, which is:\u003c/p\u003e\r\n\r\n\u003cpre\u003e\r\nLine 10\r\n\u003c/pre\u003e\r\n\r\n\u003cdiv class=\"spoilers\"\u003e\u003cb\u003eNote:\u003c/b\u003e\u003cbr /\u003e\r\n1. If the file contains less than 10 lines, what should you output?\u003cbr /\u003e\r\n2. There\u0026#39;s at least three different solutions. Try to explore all possibilities.\u003c/div\u003e\r\n",
   "hints": [],
   "questionId": "195",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Shell",
     "slug": "shell",
     "translatedName": ""
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个文本文件\u0026nbsp;\u003ccode\u003efile.txt\u003c/code\u003e，请只打印这个文件中的第十行。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e假设\u0026nbsp;\u003ccode\u003efile.txt\u003c/code\u003e 有如下内容：\u003c/p\u003e\n\n\u003cpre\u003eLine 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\n\u003c/pre\u003e\n\n\u003cp\u003e你的脚本应当显示第十行：\u003c/p\u003e\n\n\u003cpre\u003eLine 10\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明:\u003c/strong\u003e\u003cbr\u003e\n1. 如果文件少于十行，你应当输出什么？\u003cbr\u003e\n2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。\u003c/p\u003e\n",
   "translatedTitle": "第十行"
  },
  "the-dining-philosophers": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "ti-huan-kong-ge-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "to-lower-case": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "top-k-frequent-elements": {
   "content": "\u003cp\u003eGiven an integer array \u003ccode\u003enums\u003c/code\u003e and an integer \u003ccode\u003ek\u003c/code\u003e, return \u003cem\u003ethe\u003c/em\u003e \u003ccode\u003ek\u003c/code\u003e \u003cem\u003emost frequent elements\u003c/em\u003e. You may return the answer in \u003cstrong\u003eany order\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1,1,1,2,2,3], k = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2]\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e nums = [1], k = 1\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1]\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ek\u003c/code\u003e is in the range \u003ccode\u003e[1, the number of unique elements in the array]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003eIt is \u003cstrong\u003eguaranteed\u003c/strong\u003e that the answer is \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e Your algorithm\u0026#39;s time complexity must be better than \u003ccode\u003eO(n log n)\u003c/code\u003e, where n is the array\u0026#39;s size.\u003c/p\u003e\n",
   "hints": [],
   "questionId": "347",
   "similarQuestions": "[{\"title\": \"Word Frequency\", \"titleSlug\": \"word-frequency\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u7edf\\u8ba1\\u8bcd\\u9891\"}, {\"title\": \"Kth Largest Element in an Array\", \"titleSlug\": \"kth-largest-element-in-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6570\\u7ec4\\u4e2d\\u7684\\u7b2cK\\u4e2a\\u6700\\u5927\\u5143\\u7d20\"}, {\"title\": \"Sort Characters By Frequency\", \"titleSlug\": \"sort-characters-by-frequency\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6839\\u636e\\u5b57\\u7b26\\u51fa\\u73b0\\u9891\\u7387\\u6392\\u5e8f\"}, {\"title\": \"Split Array into Consecutive Subsequences\", \"titleSlug\": \"split-array-into-consecutive-subsequences\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5206\\u5272\\u6570\\u7ec4\\u4e3a\\u8fde\\u7eed\\u5b50\\u5e8f\\u5217\"}, {\"title\": \"Top K Frequent Words\", \"titleSlug\": \"top-k-frequent-words\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u524dK\\u4e2a\\u9ad8\\u9891\\u5355\\u8bcd\"}, {\"title\": \"K Closest Points to Origin\", \"titleSlug\": \"k-closest-points-to-origin\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u63a5\\u8fd1\\u539f\\u70b9\\u7684 K \\u4e2a\\u70b9\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Divide and Conquer",
     "slug": "divide-and-conquer",
     "translatedName": "分治"
    },
    {
     "name": "Bucket Sort",
     "slug": "bucket-sort",
     "translatedName": "桶排序"
    },
    {
     "name": "Counting",
     "slug": "counting",
     "translatedName": "计数"
    },
    {
     "name": "Quickselect",
     "slug": "quickselect",
     "translatedName": "快速选择"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    },
    {
     "name": "Heap (Priority Queue)",
     "slug": "heap-priority-queue",
     "translatedName": "堆（优先队列）"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数数组 \u003ccode\u003enums\u003c/code\u003e 和一个整数 \u003ccode\u003ek\u003c/code\u003e ，请你返回其中出现频率前 \u003ccode\u003ek\u003c/code\u003e 高的元素。你可以按 \u003cstrong\u003e任意顺序\u003c/strong\u003e 返回答案。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003enums = [1,1,1,2,2,3], k = 2\n\u003cstrong\u003e输出: \u003c/strong\u003e[1,2]\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入: \u003c/strong\u003enums = [1], k = 1\n\u003cstrong\u003e输出: \u003c/strong\u003e[1]\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= nums.length \u003c= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ek\u003c/code\u003e 的取值范围是 \u003ccode\u003e[1, 数组中不相同的元素的个数]\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e题目数据保证答案唯一，换句话说，数组中前 \u003ccode\u003ek\u003c/code\u003e 个高频元素的集合是唯一的\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你所设计算法的时间复杂度 \u003cstrong\u003e必须\u003c/strong\u003e 优于 \u003ccode\u003eO(n log n)\u003c/code\u003e ，其中 \u003ccode\u003en\u003c/code\u003e\u003cem\u003e \u003c/em\u003e是数组大小。\u003c/p\u003e\n",
   "translatedTitle": "前 K 个高频元素"
  },
  "top-k-frequent-words": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "traffic-light-controlled-intersection": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "transpose-matrix": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "trapping-rain-water": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "triangle": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "two-sum": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "two-sum-ii-input-array-is-sorted": {
   "content": "\u003cp\u003eGiven a \u003cstrong\u003e1-indexed\u003c/strong\u003e array of integers \u003ccode\u003enumbers\u003c/code\u003e that is already \u003cstrong\u003e\u003cem\u003esorted in non-decreasing order\u003c/em\u003e\u003c/strong\u003e, find two numbers such that they add up to a specific \u003ccode\u003etarget\u003c/code\u003e number. Let these two numbers be \u003ccode\u003enumbers[index\u003csub\u003e1\u003c/sub\u003e]\u003c/code\u003e and \u003ccode\u003enumbers[index\u003csub\u003e2\u003c/sub\u003e]\u003c/code\u003e where \u003ccode\u003e1 \u0026lt;= index\u003csub\u003e1\u003c/sub\u003e \u0026lt; index\u003csub\u003e2\u003c/sub\u003e \u0026lt;= numbers.length\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturn\u003cem\u003e the indices of the two numbers, \u003c/em\u003e\u003ccode\u003eindex\u003csub\u003e1\u003c/sub\u003e\u003c/code\u003e\u003cem\u003e and \u003c/em\u003e\u003ccode\u003eindex\u003csub\u003e2\u003c/sub\u003e\u003c/code\u003e\u003cem\u003e, \u003cstrong\u003eadded by one\u003c/strong\u003e as an integer array \u003c/em\u003e\u003ccode\u003e[index\u003csub\u003e1\u003c/sub\u003e, index\u003csub\u003e2\u003c/sub\u003e]\u003c/code\u003e\u003cem\u003e of length 2.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe tests are generated such that there is \u003cstrong\u003eexactly one solution\u003c/strong\u003e. You \u003cstrong\u003emay not\u003c/strong\u003e use the same element twice.\u003c/p\u003e\n\n\u003cp\u003eYour solution must use only constant extra space.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e numbers = [\u003cu\u003e2\u003c/u\u003e,\u003cu\u003e7\u003c/u\u003e,11,15], target = 9\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The sum of 2 and 7 is 9. Therefore, index\u003csub\u003e1\u003c/sub\u003e = 1, index\u003csub\u003e2\u003c/sub\u003e = 2. We return [1, 2].\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e numbers = [\u003cu\u003e2\u003c/u\u003e,3,\u003cu\u003e4\u003c/u\u003e], target = 6\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,3]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The sum of 2 and 4 is 6. Therefore index\u003csub\u003e1\u003c/sub\u003e = 1, index\u003csub\u003e2\u003c/sub\u003e = 3. We return [1, 3].\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e numbers = [\u003cu\u003e-1\u003c/u\u003e,\u003cu\u003e0\u003c/u\u003e], target = -1\n\u003cstrong\u003eOutput:\u003c/strong\u003e [1,2]\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The sum of -1 and 0 is -1. Therefore index\u003csub\u003e1\u003c/sub\u003e = 1, index\u003csub\u003e2\u003c/sub\u003e = 2. We return [1, 2].\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e2 \u0026lt;= numbers.length \u0026lt;= 3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= numbers[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enumbers\u003c/code\u003e is sorted in \u003cstrong\u003enon-decreasing order\u003c/strong\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= target \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003eThe tests are generated such that there is \u003cstrong\u003eexactly one solution\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "167",
   "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e24\\u6570\\u4e4b\\u548c\"}, {\"title\": \"Two Sum IV - Input is a BST\", \"titleSlug\": \"two-sum-iv-input-is-a-bst\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e24\\u6570\\u4e4b\\u548c IV - \\u8f93\\u5165 BST\"}, {\"title\": \"Two Sum Less Than K\", \"titleSlug\": \"two-sum-less-than-k\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u5c0f\\u4e8e K \\u7684\\u4e24\\u6570\\u4e4b\\u548c\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个下标从 \u003cstrong\u003e1\u003c/strong\u003e 开始的整数数组\u0026nbsp;\u003ccode\u003enumbers\u003c/code\u003e ，该数组已按\u003cstrong\u003e\u003cem\u003e \u003c/em\u003e非递减顺序排列\u0026nbsp; \u003c/strong\u003e，请你从数组中找出满足相加之和等于目标数\u0026nbsp;\u003ccode\u003etarget\u003c/code\u003e 的两个数。如果设这两个数分别是 \u003ccode\u003enumbers[index\u003csub\u003e1\u003c/sub\u003e]\u003c/code\u003e 和 \u003ccode\u003enumbers[index\u003csub\u003e2\u003c/sub\u003e]\u003c/code\u003e ，则 \u003ccode\u003e1 \u0026lt;= index\u003csub\u003e1\u003c/sub\u003e \u0026lt; index\u003csub\u003e2\u003c/sub\u003e \u0026lt;= numbers.length\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e以长度为 2 的整数数组 \u003ccode\u003e[index\u003csub\u003e1\u003c/sub\u003e, index\u003csub\u003e2\u003c/sub\u003e]\u003c/code\u003e 的形式返回这两个整数的下标 \u003ccode\u003eindex\u003csub\u003e1\u003c/sub\u003e\u003c/code\u003e\u003cem\u003e \u003c/em\u003e和\u003cem\u003e \u003c/em\u003e\u003ccode\u003eindex\u003csub\u003e2\u003c/sub\u003e\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e你可以假设每个输入 \u003cstrong\u003e只对应唯一的答案\u003c/strong\u003e ，而且你 \u003cstrong\u003e不可以\u003c/strong\u003e 重复使用相同的元素。\u003c/p\u003e\n\n\u003cp\u003e你所设计的解决方案必须只使用常量级的额外空间。\u003c/p\u003e\n\u0026nbsp;\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enumbers = [\u003cstrong\u003e\u003cem\u003e2\u003c/em\u003e\u003c/strong\u003e,\u003cstrong\u003e\u003cem\u003e7\u003c/em\u003e\u003c/strong\u003e,11,15], target = 9\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2]\n\u003cstrong\u003e解释：\u003c/strong\u003e2 与 7 之和等于目标数 9 。因此 index\u003csub\u003e1\u003c/sub\u003e = 1, index\u003csub\u003e2\u003c/sub\u003e = 2 。返回 [1, 2] 。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enumbers = [\u003cstrong\u003e\u003cem\u003e2\u003c/em\u003e\u003c/strong\u003e,3,\u003cstrong\u003e\u003cem\u003e4\u003c/em\u003e\u003c/strong\u003e], target = 6\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,3]\n\u003cstrong\u003e解释：\u003c/strong\u003e2 与 4 之和等于目标数 6 。因此 index\u003csub\u003e1\u003c/sub\u003e = 1, index\u003csub\u003e2\u003c/sub\u003e = 3 。返回 [1, 3] 。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enumbers = [\u003cstrong\u003e\u003cem\u003e-1\u003c/em\u003e\u003c/strong\u003e,\u003cstrong\u003e\u003cem\u003e0\u003c/em\u003e\u003c/strong\u003e], target = -1\n\u003cstrong\u003e输出：\u003c/strong\u003e[1,2]\n\u003cstrong\u003e解释：\u003c/strong\u003e-1 与 0 之和等于目标数 -1 。因此 index\u003csub\u003e1\u003c/sub\u003e = 1, index\u003csub\u003e2\u003c/sub\u003e = 2 。返回 [1, 2] 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e2 \u0026lt;= numbers.length \u0026lt;= 3 * 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= numbers[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003enumbers\u003c/code\u003e 按 \u003cstrong\u003e非递减顺序\u003c/strong\u003e 排列\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-1000 \u0026lt;= target \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003e仅存在一个有效答案\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "两数之和 II - 输入有序数组"
  },
  "two-sum-iv-input-is-a-bst": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a Binary Search Tree and a target number \u003ccode\u003ek\u003c/code\u003e, return \u003cem\u003e\u003ccode\u003etrue\u003c/code\u003e if there exist two elements in the BST such that their sum is equal to the given target\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg\" style=\"width: 400px; height: 229px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,3,6,2,4,null,7], k = 9\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg\" style=\"width: 400px; height: 229px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,3,6,2,4,null,7], k = 28\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e\u0026nbsp;\u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e is guaranteed to be a \u003cstrong\u003evalid\u003c/strong\u003e binary search tree.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e\u0026nbsp;\u0026lt;= k \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "653",
   "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e24\\u6570\\u4e4b\\u548c\"}, {\"title\": \"Two Sum II - Input Array Is Sorted\", \"titleSlug\": \"two-sum-ii-input-array-is-sorted\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e24\\u6570\\u4e4b\\u548c II - \\u8f93\\u5165\\u6709\\u5e8f\\u6570\\u7ec4\"}, {\"title\": \"Two Sum III - Data structure design\", \"titleSlug\": \"two-sum-iii-data-structure-design\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e24\\u6570\\u4e4b\\u548c III - \\u6570\\u636e\\u7ed3\\u6784\\u8bbe\\u8ba1\"}, {\"title\": \"Two Sum BSTs\", \"titleSlug\": \"two-sum-bsts\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u67e5\\u627e\\u4e24\\u68f5\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u4e4b\\u548c\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Breadth-First Search",
     "slug": "breadth-first-search",
     "translatedName": "广度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个二叉搜索树 \u003ccode\u003eroot\u003c/code\u003e 和一个目标结果 \u003ccode\u003ek\u003c/code\u003e，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 \u003ccode\u003etrue\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg\" style=\"height: 229px; width: 400px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e root = [5,3,6,2,4,null,7], k = 9\n\u003cstrong\u003e输出:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg\" style=\"height: 229px; width: 400px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e root = [5,3,6,2,4,null,7], k = 28\n\u003cstrong\u003e输出:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e二叉树的节点个数的范围是\u0026nbsp;\u0026nbsp;\u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e\u0026nbsp;\u0026lt;= Node.val \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e\u0026nbsp;为二叉搜索树\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e5\u003c/sup\u003e\u0026nbsp;\u0026lt;= k \u0026lt;= 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "两数之和 IV - 输入 BST"
  },
  "two-sum-less-than-k": {
   "content": "\u003cp\u003eGiven an array \u003ccode\u003enums\u003c/code\u003e of integers and\u0026nbsp;integer \u003ccode\u003ek\u003c/code\u003e, return the maximum \u003ccode\u003esum\u003c/code\u003e such that there exists \u003ccode\u003ei \u0026lt; j\u003c/code\u003e with \u003ccode\u003enums[i] + nums[j] = sum\u003c/code\u003e and \u003ccode\u003esum \u0026lt; k\u003c/code\u003e. If no \u003ccode\u003ei\u003c/code\u003e, \u003ccode\u003ej\u003c/code\u003e exist satisfying this equation, return \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [34,23,1,24,75,33,54,8], k = 60\n\u003cstrong\u003eOutput:\u003c/strong\u003e 58\n\u003cstrong\u003eExplanation: \u003c/strong\u003eWe can use 34 and 24 to sum 58 which is less than 60.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e nums = [10,20,30], k = 15\n\u003cstrong\u003eOutput:\u003c/strong\u003e -1\n\u003cstrong\u003eExplanation: \u003c/strong\u003eIn this case it is not possible to get a pair sum less that 15.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums.length \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= nums[i] \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= k \u0026lt;= 2000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "What if we have the array sorted?",
    "Loop the array and get the value A[i] then we need to find a value A[j] such that A[i] + A[j] \u003c K  which means A[j] \u003c K - A[i]. In order to do that we can find that value with a binary search."
   ],
   "questionId": "1083",
   "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e24\\u6570\\u4e4b\\u548c\"}, {\"title\": \"Two Sum II - Input Array Is Sorted\", \"titleSlug\": \"two-sum-ii-input-array-is-sorted\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e24\\u6570\\u4e4b\\u548c II - \\u8f93\\u5165\\u6709\\u5e8f\\u6570\\u7ec4\"}, {\"title\": \"3Sum Smaller\", \"titleSlug\": \"3sum-smaller\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u8f83\\u5c0f\\u7684\\u4e09\\u6570\\u4e4b\\u548c\"}, {\"title\": \"Subarray Product Less Than K\", \"titleSlug\": \"subarray-product-less-than-k\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e58\\u79ef\\u5c0f\\u4e8eK\\u7684\\u5b50\\u6570\\u7ec4\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    },
    {
     "name": "Sorting",
     "slug": "sorting",
     "translatedName": "排序"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个整数数组 \u003ccode\u003enums\u003c/code\u003e 和整数 \u003ccode\u003ek\u003c/code\u003e ，返回最大和 \u003ccode\u003esum\u003c/code\u003e ，满足存在 \u003ccode\u003ei \u003c j\u003c/code\u003e 使得 \u003ccode\u003enums[i] + nums[j] = sum\u003c/code\u003e 且 \u003ccode\u003esum \u003c k\u003c/code\u003e 。如果没有满足此等式的 \u003ccode\u003ei,j\u003c/code\u003e 存在，则返回 \u003ccode\u003e-1\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [34,23,1,24,75,33,54,8], k = 60\n\u003cstrong\u003e输出：\u003c/strong\u003e58\n\u003cstrong\u003e解释：\u003c/strong\u003e\n34 和 24 相加得到 58，58 小于 60，满足题意。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enums = [10,20,30], k = 15\n\u003cstrong\u003e输出：\u003c/strong\u003e-1\n\u003cstrong\u003e解释：\u003c/strong\u003e\n我们无法找到和小于 15 的两个元素。\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= nums.length \u003c= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= nums[i] \u003c= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= k \u003c= 2000\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "小于 K 的两数之和"
  },
  "ugly-number": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "ugly-number-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "unique-binary-search-trees": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "unique-email-addresses": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "unique-morse-code-words": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "unique-paths": {
   "content": "\u003cp\u003eThere is a robot on an \u003ccode\u003em x n\u003c/code\u003e grid. The robot is initially located at the \u003cstrong\u003etop-left corner\u003c/strong\u003e (i.e., \u003ccode\u003egrid[0][0]\u003c/code\u003e). The robot tries to move to the \u003cstrong\u003ebottom-right corner\u003c/strong\u003e (i.e., \u003ccode\u003egrid[m - 1][n - 1]\u003c/code\u003e). The robot can only move either down or right at any point in time.\u003c/p\u003e\n\n\u003cp\u003eGiven the two integers \u003ccode\u003em\u003c/code\u003e and \u003ccode\u003en\u003c/code\u003e, return \u003cem\u003ethe number of possible unique paths that the robot can take to reach the bottom-right corner\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe test cases are generated so that the answer will be less than or equal to \u003ccode\u003e2 * 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" style=\"width: 400px; height: 183px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e m = 3, n = 7\n\u003cstrong\u003eOutput:\u003c/strong\u003e 28\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e m = 3, n = 2\n\u003cstrong\u003eOutput:\u003c/strong\u003e 3\n\u003cstrong\u003eExplanation:\u003c/strong\u003e From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -\u0026gt; Down -\u0026gt; Down\n2. Down -\u0026gt; Down -\u0026gt; Right\n3. Down -\u0026gt; Right -\u0026gt; Down\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 100\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "62",
   "similarQuestions": "[{\"title\": \"Unique Paths II\", \"titleSlug\": \"unique-paths-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u4e0d\\u540c\\u8def\\u5f84 II\"}, {\"title\": \"Minimum Path Sum\", \"titleSlug\": \"minimum-path-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u6700\\u5c0f\\u8def\\u5f84\\u548c\"}, {\"title\": \"Dungeon Game\", \"titleSlug\": \"dungeon-game\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u5730\\u4e0b\\u57ce\\u6e38\\u620f\"}]",
   "topicTags": [
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    },
    {
     "name": "Combinatorics",
     "slug": "combinatorics",
     "translatedName": "组合数学"
    }
   ],
   "translatedContent": "\u003cp\u003e一个机器人位于一个 \u003ccode\u003em x n\u003c/code\u003e\u003cem\u003e \u003c/em\u003e网格的左上角 （起始点在下图中标记为 “Start” ）。\u003c/p\u003e\n\n\u003cp\u003e机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\u003c/p\u003e\n\n\u003cp\u003e问总共有多少条不同的路径？\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003em = 3, n = 7\n\u003cstrong\u003e输出：\u003c/strong\u003e28\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003em = 3, n = 2\n\u003cstrong\u003e输出：\u003c/strong\u003e3\n\u003cstrong\u003e解释：\u003c/strong\u003e\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -\u003e 向下 -\u003e 向下\n2. 向下 -\u003e 向下 -\u003e 向右\n3. 向下 -\u003e 向右 -\u003e 向下\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003em = 7, n = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e28\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003em = 3, n = 3\n\u003cstrong\u003e输出：\u003c/strong\u003e6\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= m, n \u003c= 100\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e题目数据保证答案小于等于 \u003ccode\u003e2 * 10\u003csup\u003e9\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "不同路径"
  },
  "unique-paths-ii": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "univalued-binary-tree": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "utf-8-validation": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "valid-anagram": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "valid-palindrome": {
   "content": "\u003cp\u003eA phrase is a \u003cstrong\u003epalindrome\u003c/strong\u003e if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\u003c/p\u003e\n\n\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e\u003cem\u003e if it is a \u003cstrong\u003epalindrome\u003c/strong\u003e, or \u003c/em\u003e\u003ccode\u003efalse\u003c/code\u003e\u003cem\u003e otherwise\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;A man, a plan, a canal: Panama\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026quot;amanaplanacanalpanama\u0026quot; is a palindrome.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;race a car\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026quot;raceacar\u0026quot; is not a palindrome.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot; \u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e s is an empty string \u0026quot;\u0026quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 2 * 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consists only of printable ASCII characters.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "125",
   "similarQuestions": "[{\"title\": \"Palindrome Linked List\", \"titleSlug\": \"palindrome-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u56de\\u6587\\u94fe\\u8868\"}, {\"title\": \"Valid Palindrome II\", \"titleSlug\": \"valid-palindrome-ii\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u9a8c\\u8bc1\\u56de\\u6587\\u5b57\\u7b26\\u4e32 \\u2161\"}]",
   "topicTags": [
    {
     "name": "Two Pointers",
     "slug": "two-pointers",
     "translatedName": "双指针"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e本题中，我们将空字符串定义为有效的回文串。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e \"A man, a plan, a canal: Panama\"\n\u003cstrong\u003e输出:\u003c/strong\u003e true\n\u003cstrong\u003e解释：\u003c/strong\u003e\"amanaplanacanalpanama\" 是回文串\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e \"race a car\"\n\u003cstrong\u003e输出:\u003c/strong\u003e false\n\u003cstrong\u003e解释：\u003c/strong\u003e\"raceacar\" 不是回文串\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= s.length \u003c= 2 * 10\u003csup\u003e5\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e字符串 \u003ccode\u003es\u003c/code\u003e 由 ASCII 字符组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "验证回文串"
  },
  "valid-parentheses": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e containing just the characters \u003ccode\u003e\u0026#39;(\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;)\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;{\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;}\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;[\u0026#39;\u003c/code\u003e and \u003ccode\u003e\u0026#39;]\u0026#39;\u003c/code\u003e, determine if the input string is valid.\u003c/p\u003e\n\n\u003cp\u003eAn input string is valid if:\u003c/p\u003e\n\n\u003col\u003e\n\t\u003cli\u003eOpen brackets must be closed by the same type of brackets.\u003c/li\u003e\n\t\u003cli\u003eOpen brackets must be closed in the correct order.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;()\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;()[]{}\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;(]\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e consists of parentheses only \u003ccode\u003e\u0026#39;()[]{}\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [
    "An interesting property about a valid parenthesis expression is that a sub-expression of a valid expression should also be a valid expression. (Not every sub-expression) e.g.\r\n\r\n\u003cpre\u003e\r\n{ { } [ ] [ [ [ ] ] ] } is VALID expression\r\n          [ [ [ ] ] ]    is VALID sub-expression\r\n  { } [ ]                is VALID sub-expression\r\n\u003c/pre\u003e\r\n\r\nCan we exploit this recursive structure somehow?",
    "What if whenever we encounter a matching pair of parenthesis in the expression, we simply remove it from the expression? This would keep on shortening the expression. e.g.\r\n\r\n\u003cpre\u003e\r\n{ { ( { } ) } }\r\n      |_|\r\n\r\n{ { (      ) } }\r\n    |______|\r\n\r\n{ {          } }\r\n  |__________|\r\n\r\n{                }\r\n|________________|\r\n\r\nVALID EXPRESSION!\r\n\u003c/pre\u003e",
    "The \u003cb\u003estack\u003c/b\u003e data structure can come in handy here in representing this recursive structure of the problem. We can't really process this from the inside out because we don't have an idea about the overall structure. But, the stack can help us process this recursively i.e. from outside to inwards."
   ],
   "questionId": "20",
   "similarQuestions": "[{\"title\": \"Generate Parentheses\", \"titleSlug\": \"generate-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u62ec\\u53f7\\u751f\\u6210\"}, {\"title\": \"Longest Valid Parentheses\", \"titleSlug\": \"longest-valid-parentheses\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6700\\u957f\\u6709\\u6548\\u62ec\\u53f7\"}, {\"title\": \"Remove Invalid Parentheses\", \"titleSlug\": \"remove-invalid-parentheses\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u5220\\u9664\\u65e0\\u6548\\u7684\\u62ec\\u53f7\"}, {\"title\": \"Check If Word Is Valid After Substitutions\", \"titleSlug\": \"check-if-word-is-valid-after-substitutions\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u68c0\\u67e5\\u66ff\\u6362\\u540e\\u7684\\u8bcd\\u662f\\u5426\\u6709\\u6548\"}]",
   "topicTags": [
    {
     "name": "Stack",
     "slug": "stack",
     "translatedName": "栈"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个只包括 \u003ccode\u003e'('\u003c/code\u003e，\u003ccode\u003e')'\u003c/code\u003e，\u003ccode\u003e'{'\u003c/code\u003e，\u003ccode\u003e'}'\u003c/code\u003e，\u003ccode\u003e'['\u003c/code\u003e，\u003ccode\u003e']'\u003c/code\u003e 的字符串 \u003ccode\u003es\u003c/code\u003e ，判断字符串是否有效。\u003c/p\u003e\n\n\u003cp\u003e有效字符串需满足：\u003c/p\u003e\n\n\u003col\u003e\n\t\u003cli\u003e左括号必须用相同类型的右括号闭合。\u003c/li\u003e\n\t\u003cli\u003e左括号必须以正确的顺序闭合。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"()\"\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"()[]{}\"\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"(]\"\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 4：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"([)]\"\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 5：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003es = \"{[]}\"\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= s.length \u003c= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 仅由括号 \u003ccode\u003e'()[]{}'\u003c/code\u003e 组成\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "有效的括号"
  },
  "valid-perfect-square": {
   "content": "\u003cp\u003eGiven a \u003cstrong\u003epositive\u003c/strong\u003e integer \u003ci\u003enum\u003c/i\u003e, write a function which returns True if \u003ci\u003enum\u003c/i\u003e is a perfect square else False.\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003eFollow up:\u003c/b\u003e \u003cb\u003eDo not\u003c/b\u003e use any built-in library function such as \u003ccode\u003esqrt\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e num = 16\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003cstrong\u003eInput:\u003c/strong\u003e num = 14\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= num \u0026lt;= 2^31 - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "367",
   "similarQuestions": "[{\"title\": \"Sqrt(x)\", \"titleSlug\": \"sqrtx\", \"difficulty\": \"Easy\", \"translatedTitle\": \"x \\u7684\\u5e73\\u65b9\\u6839 \"}, {\"title\": \"Sum of Square Numbers\", \"titleSlug\": \"sum-of-square-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5e73\\u65b9\\u6570\\u4e4b\\u548c\"}]",
   "topicTags": [
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    },
    {
     "name": "Binary Search",
     "slug": "binary-search",
     "translatedName": "二分查找"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个 \u003cstrong\u003e正整数\u003c/strong\u003e \u003ccode\u003enum\u003c/code\u003e ，编写一个函数，如果 \u003ccode\u003enum\u003c/code\u003e 是一个完全平方数，则返回 \u003ccode\u003etrue\u003c/code\u003e ，否则返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：不要\u003c/strong\u003e 使用任何内置的库函数，如  \u003ccode\u003esqrt\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enum = 16\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003enum = 14\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= num \u003c= 2^31 - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "有效的完全平方数"
  },
  "valid-square": {
   "content": "\u003cp\u003eGiven the coordinates of four points in 2D space \u003ccode\u003ep1\u003c/code\u003e, \u003ccode\u003ep2\u003c/code\u003e, \u003ccode\u003ep3\u003c/code\u003e and \u003ccode\u003ep4\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e \u003cem\u003eif the four points construct a square\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe coordinate of a point \u003ccode\u003ep\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e is represented as \u003ccode\u003e[x\u003csub\u003ei\u003c/sub\u003e, y\u003csub\u003ei\u003c/sub\u003e]\u003c/code\u003e. The input is \u003cstrong\u003enot\u003c/strong\u003e given in any order.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003evalid square\u003c/strong\u003e has four equal sides with positive length and four equal angles (90-degree angles).\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003ep1.length == p2.length == p3.length == p4.length == 2\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e \u0026lt;= x\u003csub\u003ei\u003c/sub\u003e, y\u003csub\u003ei\u003c/sub\u003e \u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "593",
   "similarQuestions": "[]",
   "topicTags": [
    {
     "name": "Geometry",
     "slug": "geometry",
     "translatedName": "几何"
    },
    {
     "name": "Math",
     "slug": "math",
     "translatedName": "数学"
    }
   ],
   "translatedContent": "\u003cp\u003e给定2D空间中四个点的坐标\u0026nbsp;\u003ccode\u003ep1\u003c/code\u003e,\u0026nbsp;\u003ccode\u003ep2\u003c/code\u003e,\u0026nbsp;\u003ccode\u003ep3\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003ep4\u003c/code\u003e，如果这四个点构成一个正方形，则返回 \u003ccode\u003etrue\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e点的坐标\u0026nbsp;\u003ccode\u003ep\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e 表示为 \u003ccode\u003e[xi, yi]\u003c/code\u003e 。输入 \u003cstrong\u003e不是\u003c/strong\u003e 按任何顺序给出的。\u003c/p\u003e\n\n\u003cp\u003e一个 \u003cstrong\u003e有效的正方形\u003c/strong\u003e 有四条等边和四个等角(90度角)。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n\u003cstrong\u003e输出:\u003c/strong\u003e True\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003ep1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n\u003cb\u003e输出：\u003c/b\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cb\u003e输入：\u003c/b\u003ep1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n\u003cb\u003e输出：\u003c/b\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003ep1.length == p2.length == p3.length == p4.length == 2\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-10\u003csup\u003e4\u003c/sup\u003e\u0026nbsp;\u0026lt;= x\u003csub\u003ei\u003c/sub\u003e, y\u003csub\u003ei\u003c/sub\u003e\u0026nbsp;\u0026lt;= 10\u003csup\u003e4\u003c/sup\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "有效的正方形"
  },
  "validate-binary-search-tree": {
   "content": "\u003cp\u003eGiven the \u003ccode\u003eroot\u003c/code\u003e of a binary tree, \u003cem\u003edetermine if it is a valid binary search tree (BST)\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eA \u003cstrong\u003evalid BST\u003c/strong\u003e is defined as follows:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe left subtree of a node contains only nodes with keys \u003cstrong\u003eless than\u003c/strong\u003e the node\u0026#39;s key.\u003c/li\u003e\n\t\u003cli\u003eThe right subtree of a node contains only nodes with keys \u003cstrong\u003egreater than\u003c/strong\u003e the node\u0026#39;s key.\u003c/li\u003e\n\t\u003cli\u003eBoth the left and right subtrees must also be binary search trees.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [2,1,3]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e root = [5,1,4,null,null,3,6]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e The root node\u0026#39;s value is 5 but its right child\u0026#39;s value is 4.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eThe number of nodes in the tree is in the range \u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "98",
   "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u6811\\u7684\\u4e2d\\u5e8f\\u904d\\u5386\"}, {\"title\": \"Find Mode in Binary Search Tree\", \"titleSlug\": \"find-mode-in-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u4e8c\\u53c9\\u641c\\u7d22\\u6811\\u4e2d\\u7684\\u4f17\\u6570\"}]",
   "topicTags": [
    {
     "name": "Tree",
     "slug": "tree",
     "translatedName": "树"
    },
    {
     "name": "Depth-First Search",
     "slug": "depth-first-search",
     "translatedName": "深度优先搜索"
    },
    {
     "name": "Binary Search Tree",
     "slug": "binary-search-tree",
     "translatedName": "二叉搜索树"
    },
    {
     "name": "Binary Tree",
     "slug": "binary-tree",
     "translatedName": "二叉树"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个二叉树的根节点 \u003ccode\u003eroot\u003c/code\u003e ，判断其是否是一个有效的二叉搜索树。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e有效\u003c/strong\u003e 二叉搜索树定义如下：\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e节点的左子树只包含\u003cstrong\u003e 小于 \u003c/strong\u003e当前节点的数。\u003c/li\u003e\n\t\u003cli\u003e节点的右子树只包含 \u003cstrong\u003e大于\u003c/strong\u003e 当前节点的数。\u003c/li\u003e\n\t\u003cli\u003e所有左子树和右子树自身必须也是二叉搜索树。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [2,1,3]\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eroot = [5,1,4,null,null,3,6]\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003cstrong\u003e解释：\u003c/strong\u003e根节点的值是 5 ，但是右子节点的值是 4 。\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e树中节点数目范围在\u003ccode\u003e[1, 10\u003csup\u003e4\u003c/sup\u003e]\u003c/code\u003e 内\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e-2\u003csup\u003e31\u003c/sup\u003e \u0026lt;= Node.val \u0026lt;= 2\u003csup\u003e31\u003c/sup\u003e - 1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "验证二叉搜索树"
  },
  "validate-ip-address": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003equeryIP\u003c/code\u003e, return \u003ccode\u003e\u0026quot;IPv4\u0026quot;\u003c/code\u003e if IP is a valid IPv4 address, \u003ccode\u003e\u0026quot;IPv6\u0026quot;\u003c/code\u003e if IP is a valid IPv6 address or \u003ccode\u003e\u0026quot;Neither\u0026quot;\u003c/code\u003e if IP is not a correct IP of any type.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eA valid IPv4\u003c/strong\u003e address is an IP in the form \u003ccode\u003e\u0026quot;x\u003csub\u003e1\u003c/sub\u003e.x\u003csub\u003e2\u003c/sub\u003e.x\u003csub\u003e3\u003c/sub\u003e.x\u003csub\u003e4\u003c/sub\u003e\u0026quot;\u003c/code\u003e where \u003ccode\u003e0 \u0026lt;= x\u003csub\u003ei\u003c/sub\u003e \u0026lt;= 255\u003c/code\u003e and \u003ccode\u003ex\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e \u003cstrong\u003ecannot contain\u003c/strong\u003e leading zeros. For example, \u003ccode\u003e\u0026quot;192.168.1.1\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;192.168.1.0\u0026quot;\u003c/code\u003e are valid IPv4 addresses but \u003ccode\u003e\u0026quot;192.168.01.1\u0026quot;\u003c/code\u003e, while \u003ccode\u003e\u0026quot;192.168.1.00\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;192.168@1.1\u0026quot;\u003c/code\u003e are invalid IPv4 addresses.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eA valid IPv6\u003c/strong\u003e address is an IP in the form \u003ccode\u003e\u0026quot;x\u003csub\u003e1\u003c/sub\u003e:x\u003csub\u003e2\u003c/sub\u003e:x\u003csub\u003e3\u003c/sub\u003e:x\u003csub\u003e4\u003c/sub\u003e:x\u003csub\u003e5\u003c/sub\u003e:x\u003csub\u003e6\u003c/sub\u003e:x\u003csub\u003e7\u003c/sub\u003e:x\u003csub\u003e8\u003c/sub\u003e\u0026quot;\u003c/code\u003e where:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= x\u003csub\u003ei\u003c/sub\u003e.length \u0026lt;= 4\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ex\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e is a \u003cstrong\u003ehexadecimal string\u003c/strong\u003e which may contain digits, lower-case English letter (\u003ccode\u003e\u0026#39;a\u0026#39;\u003c/code\u003e to \u003ccode\u003e\u0026#39;f\u0026#39;\u003c/code\u003e) and upper-case English letters (\u003ccode\u003e\u0026#39;A\u0026#39;\u003c/code\u003e to \u003ccode\u003e\u0026#39;F\u0026#39;\u003c/code\u003e).\u003c/li\u003e\n\t\u003cli\u003eLeading zeros are allowed in \u003ccode\u003ex\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eFor example, \u0026quot;\u003ccode\u003e2001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026quot;\u003c/code\u003e and \u0026quot;\u003ccode\u003e2001:db8:85a3:0:0:8A2E:0370:7334\u0026quot;\u003c/code\u003e are valid IPv6 addresses, while \u0026quot;\u003ccode\u003e2001:0db8:85a3::8A2E:037j:7334\u0026quot;\u003c/code\u003e and \u0026quot;\u003ccode\u003e02001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026quot;\u003c/code\u003e are invalid IPv6 addresses.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e queryIP = \u0026quot;172.16.254.1\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;IPv4\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e This is a valid IPv4 address, return \u0026quot;IPv4\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e queryIP = \u0026quot;2001:0db8:85a3:0:0:8A2E:0370:7334\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;IPv6\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e This is a valid IPv6 address, return \u0026quot;IPv6\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e queryIP = \u0026quot;256.256.256.256\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e \u0026quot;Neither\u0026quot;\n\u003cstrong\u003eExplanation:\u003c/strong\u003e This is neither a IPv4 address nor a IPv6 address.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003equeryIP\u003c/code\u003e consists only of English letters, digits and the characters \u003ccode\u003e\u0026#39;.\u0026#39;\u003c/code\u003e and \u003ccode\u003e\u0026#39;:\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "468",
   "similarQuestions": "[{\"title\": \"IP to CIDR\", \"titleSlug\": \"ip-to-cidr\", \"difficulty\": \"Medium\", \"translatedTitle\": \"IP \\u5230 CIDR\"}]",
   "topicTags": [
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个字符串\u0026nbsp;\u003ccode\u003equeryIP\u003c/code\u003e。如果是有效的 IPv4 地址，返回 \u003ccode\u003e\"IPv4\"\u003c/code\u003e ；如果是有效的 IPv6 地址，返回 \u003ccode\u003e\"IPv6\"\u003c/code\u003e ；如果不是上述类型的 IP 地址，返回 \u003ccode\u003e\"Neither\"\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e有效的IPv4地址\u003c/strong\u003e 是 \u003ccode\u003e“x1.x2.x3.x4”\u003c/code\u003e 形式的IP地址。 其中\u0026nbsp;\u003ccode\u003e0 \u0026lt;= x\u003csub\u003ei\u003c/sub\u003e\u0026nbsp;\u0026lt;= 255\u003c/code\u003e\u0026nbsp;且\u0026nbsp;\u003ccode\u003ex\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e\u0026nbsp;\u003cstrong\u003e不能包含\u003c/strong\u003e 前导零。例如:\u0026nbsp;\u003ccode\u003e“192.168.1.1”\u003c/code\u003e\u0026nbsp;、 \u003ccode\u003e“192.168.1.0”\u003c/code\u003e 为有效IPv4地址， \u003ccode\u003e“192.168.01.1”\u003c/code\u003e 为无效IPv4地址; \u003ccode\u003e“192.168.1.00”\u003c/code\u003e 、 \u003ccode\u003e“192.168@1.1”\u003c/code\u003e 为无效IPv4地址。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e一个有效的IPv6地址\u0026nbsp;\u003c/strong\u003e是一个格式为\u003ccode\u003e“x1:x2:x3:x4:x5:x6:x7:x8”\u003c/code\u003e 的IP地址，其中:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= x\u003csub\u003ei\u003c/sub\u003e.length \u0026lt;= 4\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ex\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e\u0026nbsp;是一个 \u003cstrong\u003e十六进制字符串\u003c/strong\u003e ，可以包含数字、小写英文字母( \u003ccode\u003e'a'\u003c/code\u003e 到 \u003ccode\u003e'f'\u003c/code\u003e )和大写英文字母( \u003ccode\u003e'A'\u003c/code\u003e 到 \u003ccode\u003e'F'\u003c/code\u003e )。\u003c/li\u003e\n\t\u003cli\u003e在\u0026nbsp;\u003ccode\u003ex\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e\u0026nbsp;中允许前导零。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e例如 \u003ccode\u003e\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"\u003c/code\u003e 和 \u003ccode\u003e\"2001:db8:85a3:0:0:8A2E:0370:7334\"\u003c/code\u003e 是有效的 IPv6 地址，而 \u003ccode\u003e\"2001:0db8:85a3::8A2E:037j:7334\"\u003c/code\u003e 和 \u003ccode\u003e\"02001:0db8:85a3:0000:0000:8a2e:0370:7334\"\u003c/code\u003e 是无效的 IPv6 地址。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003equeryIP = \"172.16.254.1\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"IPv4\"\n\u003cstrong\u003e解释：\u003c/strong\u003e有效的 IPv4 地址，返回 \"IPv4\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003equeryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"IPv6\"\n\u003cstrong\u003e解释：\u003c/strong\u003e有效的 IPv6 地址，返回 \"IPv6\"\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003equeryIP = \"256.256.256.256\"\n\u003cstrong\u003e输出：\u003c/strong\u003e\"Neither\"\n\u003cstrong\u003e解释：\u003c/strong\u003e既不是 IPv4 地址，又不是 IPv6 地址\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003equeryIP\u003c/code\u003e 仅由英文字母，数字，字符 \u003ccode\u003e'.'\u003c/code\u003e 和 \u003ccode\u003e':'\u003c/code\u003e 组成。\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "验证IP地址"
  },
  "video-stitching": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "wildcard-matching": {
   "content": "\u003cp\u003eGiven an input string (\u003ccode\u003es\u003c/code\u003e) and a pattern (\u003ccode\u003ep\u003c/code\u003e), implement wildcard pattern matching with support for \u003ccode\u003e\u0026#39;?\u0026#39;\u003c/code\u003e and \u003ccode\u003e\u0026#39;*\u0026#39;\u003c/code\u003e where:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e\u0026#39;?\u0026#39;\u003c/code\u003e Matches any single character.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e\u0026#39;*\u0026#39;\u003c/code\u003e Matches any sequence of characters (including the empty sequence).\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe matching should cover the \u003cstrong\u003eentire\u003c/strong\u003e input string (not partial).\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;aa\u0026quot;, p = \u0026quot;a\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e \u0026quot;a\u0026quot; does not match the entire string \u0026quot;aa\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;aa\u0026quot;, p = \u0026quot;*\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\u0026nbsp;\u0026#39;*\u0026#39; matches any sequence.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;cb\u0026quot;, p = \u0026quot;?a\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003cstrong\u003eExplanation:\u003c/strong\u003e\u0026nbsp;\u0026#39;?\u0026#39; matches \u0026#39;c\u0026#39;, but the second letter is \u0026#39;a\u0026#39;, which does not match \u0026#39;b\u0026#39;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e0 \u0026lt;= s.length, p.length \u0026lt;= 2000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e contains only lowercase English letters.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e contains only lowercase English letters, \u003ccode\u003e\u0026#39;?\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;*\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "44",
   "similarQuestions": "[{\"title\": \"Regular Expression Matching\", \"titleSlug\": \"regular-expression-matching\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u6b63\\u5219\\u8868\\u8fbe\\u5f0f\\u5339\\u914d\"}]",
   "topicTags": [
    {
     "name": "Greedy",
     "slug": "greedy",
     "translatedName": "贪心"
    },
    {
     "name": "Recursion",
     "slug": "recursion",
     "translatedName": "递归"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个字符串\u0026nbsp;(\u003ccode\u003es\u003c/code\u003e) 和一个字符模式\u0026nbsp;(\u003ccode\u003ep\u003c/code\u003e) ，实现一个支持\u0026nbsp;\u003ccode\u003e\u0026#39;?\u0026#39;\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003e\u0026#39;*\u0026#39;\u003c/code\u003e\u0026nbsp;的通配符匹配。\u003c/p\u003e\n\n\u003cpre\u003e\u0026#39;?\u0026#39; 可以匹配任何单个字符。\n\u0026#39;*\u0026#39; 可以匹配任意字符串（包括空字符串）。\n\u003c/pre\u003e\n\n\u003cp\u003e两个字符串\u003cstrong\u003e完全匹配\u003c/strong\u003e才算匹配成功。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e说明:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e\u0026nbsp;可能为空，且只包含从\u0026nbsp;\u003ccode\u003ea-z\u003c/code\u003e\u0026nbsp;的小写字母。\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e\u0026nbsp;可能为空，且只包含从\u0026nbsp;\u003ccode\u003ea-z\u003c/code\u003e\u0026nbsp;的小写字母，以及字符\u0026nbsp;\u003ccode\u003e?\u003c/code\u003e\u0026nbsp;和\u0026nbsp;\u003ccode\u003e*\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e\ns = \u0026quot;aa\u0026quot;\np = \u0026quot;a\u0026quot;\n\u003cstrong\u003e输出:\u003c/strong\u003e false\n\u003cstrong\u003e解释:\u003c/strong\u003e \u0026quot;a\u0026quot; 无法匹配 \u0026quot;aa\u0026quot; 整个字符串。\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e\ns = \u0026quot;aa\u0026quot;\np = \u0026quot;*\u0026quot;\n\u003cstrong\u003e输出:\u003c/strong\u003e true\n\u003cstrong\u003e解释:\u003c/strong\u003e\u0026nbsp;\u0026#39;*\u0026#39; 可以匹配任意字符串。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e\ns = \u0026quot;cb\u0026quot;\np = \u0026quot;?a\u0026quot;\n\u003cstrong\u003e输出:\u003c/strong\u003e false\n\u003cstrong\u003e解释:\u003c/strong\u003e\u0026nbsp;\u0026#39;?\u0026#39; 可以匹配 \u0026#39;c\u0026#39;, 但第二个 \u0026#39;a\u0026#39; 无法匹配 \u0026#39;b\u0026#39;。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;4:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e\ns = \u0026quot;adceb\u0026quot;\np = \u0026quot;*a*b\u0026quot;\n\u003cstrong\u003e输出:\u003c/strong\u003e true\n\u003cstrong\u003e解释:\u003c/strong\u003e\u0026nbsp;第一个 \u0026#39;*\u0026#39; 可以匹配空字符串, 第二个 \u0026#39;*\u0026#39; 可以匹配字符串 \u0026quot;dce\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例\u0026nbsp;5:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003cstrong\u003e输入:\u003c/strong\u003e\ns = \u0026quot;acdcb\u0026quot;\np = \u0026quot;a*c?b\u0026quot;\n\u003cstrong\u003e输出:\u003c/strong\u003e false\u003c/pre\u003e\n",
   "translatedTitle": "通配符匹配"
  },
  "word-break": {
   "content": "\u003cp\u003eGiven a string \u003ccode\u003es\u003c/code\u003e and a dictionary of strings \u003ccode\u003ewordDict\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e if \u003ccode\u003es\u003c/code\u003e can be segmented into a space-separated sequence of one or more dictionary words.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that the same word in the dictionary may be reused multiple times in the segmentation.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;leetcode\u0026quot;, wordDict = [\u0026quot;leet\u0026quot;,\u0026quot;code\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Return true because \u0026quot;leetcode\u0026quot; can be segmented as \u0026quot;leet code\u0026quot;.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;applepenapple\u0026quot;, wordDict = [\u0026quot;apple\u0026quot;,\u0026quot;pen\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003cstrong\u003eExplanation:\u003c/strong\u003e Return true because \u0026quot;applepenapple\u0026quot; can be segmented as \u0026quot;apple pen apple\u0026quot;.\nNote that you are allowed to reuse a dictionary word.\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e s = \u0026quot;catsandog\u0026quot;, wordDict = [\u0026quot;cats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;sand\u0026quot;,\u0026quot;and\u0026quot;,\u0026quot;cat\u0026quot;]\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 300\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= wordDict.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= wordDict[i].length \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e and \u003ccode\u003ewordDict[i]\u003c/code\u003e consist of only lowercase English letters.\u003c/li\u003e\n\t\u003cli\u003eAll the strings of \u003ccode\u003ewordDict\u003c/code\u003e are \u003cstrong\u003eunique\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "139",
   "similarQuestions": "[{\"title\": \"Word Break II\", \"titleSlug\": \"word-break-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u5355\\u8bcd\\u62c6\\u5206 II\"}]",
   "topicTags": [
    {
     "name": "Trie",
     "slug": "trie",
     "translatedName": "字典树"
    },
    {
     "name": "Memoization",
     "slug": "memoization",
     "translatedName": "记忆化搜索"
    },
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    },
    {
     "name": "Dynamic Programming",
     "slug": "dynamic-programming",
     "translatedName": "动态规划"
    }
   ],
   "translatedContent": "\u003cp\u003e给你一个字符串 \u003ccode\u003es\u003c/code\u003e 和一个字符串列表 \u003ccode\u003ewordDict\u003c/code\u003e 作为字典。请你判断是否可以利用字典中出现的单词拼接出 \u003ccode\u003es\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n\u003cstrong\u003e输出:\u003c/strong\u003e true\n\u003cstrong\u003e解释:\u003c/strong\u003e 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n\u003cstrong\u003e输出:\u003c/strong\u003e true\n\u003cstrong\u003e解释:\u003c/strong\u003e 返回 true 因为 \u003ccode\u003e\"\u003c/code\u003eapplepenapple\u003ccode\u003e\"\u003c/code\u003e 可以由 \u003ccode\u003e\"\u003c/code\u003eapple\" \"pen\" \"apple\u003ccode\u003e\" 拼接成\u003c/code\u003e。\n\u0026nbsp;    注意，你可以重复使用字典中的单词。\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n\u003cstrong\u003e输出:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 300\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= wordDict.length \u0026lt;= 1000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= wordDict[i].length \u0026lt;= 20\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 和 \u003ccode\u003ewordDict[i]\u003c/code\u003e 仅有小写英文字母组成\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003ewordDict\u003c/code\u003e 中的所有字符串 \u003cstrong\u003e互不相同\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "单词拆分"
  },
  "word-pattern": {
   "content": "\u003cp\u003eGiven a \u003ccode\u003epattern\u003c/code\u003e and a string \u003ccode\u003es\u003c/code\u003e, find if \u003ccode\u003es\u003c/code\u003e\u0026nbsp;follows the same pattern.\u003c/p\u003e\n\n\u003cp\u003eHere \u003cb\u003efollow\u003c/b\u003e means a full match, such that there is a bijection between a letter in \u003ccode\u003epattern\u003c/code\u003e and a \u003cb\u003enon-empty\u003c/b\u003e word in \u003ccode\u003es\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e pattern = \u0026quot;abba\u0026quot;, s = \u0026quot;dog cat cat dog\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e pattern = \u0026quot;abba\u0026quot;, s = \u0026quot;dog cat cat fish\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e pattern = \u0026quot;aaaa\u0026quot;, s = \u0026quot;dog cat cat dog\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= pattern.length \u0026lt;= 300\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epattern\u003c/code\u003e contains only lower-case English letters.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 3000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e contains only lowercase English letters and spaces \u003ccode\u003e\u0026#39; \u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e \u003cstrong\u003edoes not contain\u003c/strong\u003e any leading or trailing spaces.\u003c/li\u003e\n\t\u003cli\u003eAll the words in \u003ccode\u003es\u003c/code\u003e are separated by a \u003cstrong\u003esingle space\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
   "hints": [],
   "questionId": "290",
   "similarQuestions": "[{\"title\": \"Isomorphic Strings\", \"titleSlug\": \"isomorphic-strings\", \"difficulty\": \"Easy\", \"translatedTitle\": \"\\u540c\\u6784\\u5b57\\u7b26\\u4e32\"}, {\"title\": \"Word Pattern II\", \"titleSlug\": \"word-pattern-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": \"\\u5355\\u8bcd\\u89c4\\u5f8b II\"}]",
   "topicTags": [
    {
     "name": "Hash Table",
     "slug": "hash-table",
     "translatedName": "哈希表"
    },
    {
     "name": "String",
     "slug": "string",
     "translatedName": "字符串"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一种规律 \u003ccode\u003epattern\u003c/code\u003e\u0026nbsp;和一个字符串\u0026nbsp;\u003ccode\u003es\u003c/code\u003e\u0026nbsp;，判断 \u003ccode\u003es\u003c/code\u003e\u0026nbsp;是否遵循相同的规律。\u003c/p\u003e\n\n\u003cp\u003e这里的\u0026nbsp;\u003cstrong\u003e遵循\u0026nbsp;\u003c/strong\u003e指完全匹配，例如，\u0026nbsp;\u003ccode\u003epattern\u003c/code\u003e\u0026nbsp;里的每个字母和字符串\u0026nbsp;\u003ccode\u003estr\u003c/code\u003e\u003cstrong\u003e\u0026nbsp;\u003c/strong\u003e中的每个非空单词之间存在着双向连接的对应规律。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例1:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e pattern = \u003ccode\u003e\"abba\"\u003c/code\u003e, str = \u003ccode\u003e\"dog cat cat dog\"\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e true\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003epattern = \u003ccode\u003e\"abba\"\u003c/code\u003e, str = \u003ccode\u003e\"dog cat cat fish\"\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e false\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\n\u003cstrong\u003e输入:\u003c/strong\u003e pattern = \u003ccode\u003e\"aaaa\"\u003c/code\u003e, str = \u003ccode\u003e\"dog cat cat dog\"\u003c/code\u003e\n\u003cstrong\u003e输出:\u003c/strong\u003e false\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= pattern.length \u0026lt;= 300\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003epattern\u003c/code\u003e\u0026nbsp;只包含小写英文字母\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= s.length \u0026lt;= 3000\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e\u0026nbsp;只包含小写英文字母和\u0026nbsp;\u003ccode\u003e' '\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e\u0026nbsp;\u003cstrong\u003e不包含\u003c/strong\u003e 任何前导或尾随对空格\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003es\u003c/code\u003e\u0026nbsp;中每个单词都被 \u003cstrong\u003e单个空格 \u003c/strong\u003e分隔\u003c/li\u003e\n\u003c/ul\u003e\n",
   "translatedTitle": "单词规律"
  },
  "word-search": {
   "content": "\u003cp\u003eGiven an \u003ccode\u003em x n\u003c/code\u003e grid of characters \u003ccode\u003eboard\u003c/code\u003e and a string \u003ccode\u003eword\u003c/code\u003e, return \u003ccode\u003etrue\u003c/code\u003e \u003cem\u003eif\u003c/em\u003e \u003ccode\u003eword\u003c/code\u003e \u003cem\u003eexists in the grid\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e board = [[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;E\u0026quot;],[\u0026quot;S\u0026quot;,\u0026quot;F\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;S\u0026quot;],[\u0026quot;A\u0026quot;,\u0026quot;D\u0026quot;,\u0026quot;E\u0026quot;,\u0026quot;E\u0026quot;]], word = \u0026quot;ABCCED\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e board = [[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;E\u0026quot;],[\u0026quot;S\u0026quot;,\u0026quot;F\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;S\u0026quot;],[\u0026quot;A\u0026quot;,\u0026quot;D\u0026quot;,\u0026quot;E\u0026quot;,\u0026quot;E\u0026quot;]], word = \u0026quot;SEE\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e true\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eExample 3:\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003eInput:\u003c/strong\u003e board = [[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;E\u0026quot;],[\u0026quot;S\u0026quot;,\u0026quot;F\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;S\u0026quot;],[\u0026quot;A\u0026quot;,\u0026quot;D\u0026quot;,\u0026quot;E\u0026quot;,\u0026quot;E\u0026quot;]], word = \u0026quot;ABCB\u0026quot;\n\u003cstrong\u003eOutput:\u003c/strong\u003e false\n\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == board.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en = board[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= m, n \u0026lt;= 6\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u0026lt;= word.length \u0026lt;= 15\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboard\u003c/code\u003e and \u003ccode\u003eword\u003c/code\u003e consists of only lowercase and uppercase English letters.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFollow up:\u003c/strong\u003e Could you use search pruning to make your solution faster with a larger \u003ccode\u003eboard\u003c/code\u003e?\u003c/p\u003e\n",
   "hints": [],
   "questionId": "79",
   "similarQuestions": "[{\"title\": \"Word Search II\", \"titleSlug\": \"word-search-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": \"\\u5355\\u8bcd\\u641c\\u7d22 II\"}]",
   "topicTags": [
    {
     "name": "Array",
     "slug": "array",
     "translatedName": "数组"
    },
    {
     "name": "Backtracking",
     "slug": "backtracking",
     "translatedName": "回溯"
    },
    {
     "name": "Matrix",
     "slug": "matrix",
     "translatedName": "矩阵"
    }
   ],
   "translatedContent": "\u003cp\u003e给定一个 \u003ccode\u003em x n\u003c/code\u003e 二维字符网格 \u003ccode\u003eboard\u003c/code\u003e 和一个字符串单词 \u003ccode\u003eword\u003c/code\u003e 。如果 \u003ccode\u003eword\u003c/code\u003e 存在于网格中，返回 \u003ccode\u003etrue\u003c/code\u003e ；否则，返回 \u003ccode\u003efalse\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\u003c/p\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n\u003cstrong\u003e输出：\u003c/strong\u003etrue\n\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\u003cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" /\u003e\n\u003cpre\u003e\n\u003cstrong\u003e输入：\u003c/strong\u003eboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n\u003cstrong\u003e输出：\u003c/strong\u003efalse\n\u003c/pre\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e提示：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003ccode\u003em == board.length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003en = board[i].length\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= m, n \u003c= 6\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003e1 \u003c= word.length \u003c= 15\u003c/code\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ccode\u003eboard\u003c/code\u003e 和 \u003ccode\u003eword\u003c/code\u003e 仅由大小写英文字母组成\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e进阶：\u003c/strong\u003e你可以使用搜索剪枝的技术来优化解决方案，使其在 \u003ccode\u003eboard\u003c/code\u003e 更大的情况下可以更快解决问题？\u003c/p\u003e\n",
   "translatedTitle": "单词搜索"
  },
  "xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "yong-liang-ge-zhan-shi-xian-dui-lie-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  },
  "zui-xiao-de-kge-shu-lcof": {
   "content": "",
   "hints": null,
   "questionId": "",
   "similarQuestions": "",
   "topicTags": null,
   "translatedContent": "",
   "translatedTitle": ""
  }
 },
 "ac_submissions": {
  "1-bit-and-2-bit-characters": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "bool isOneBitCharacter(int* bits, int bitsSize){\n    int i = bitsSize - 2;\n    while (i \u003e= 0 \u0026\u0026 bits[i] == 1)i--;\n    return (bitsSize-2-i) % 2 == 0;\n}",
    "id": "264295179",
    "lang": "c",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "717",
     "title": "1-bit and 2-bit Characters",
     "titleSlug": "1-bit-and-2-bit-characters",
     "translatedTitle": "1 比特与 2 比特字符"
    },
    "rawMemory": "6188000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/1-bit-and-2-bit-characters/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643798743,
    "totalTestCaseCnt": 93
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isOneBitCharacter(vector\u003cint\u003e\u0026 bits) {\n        for (int i = 0; i \u003c bits.size();) {\n            if (bits[i] == 1 \u0026\u0026 i + 2 == bits.size()) {\n                return false;\n            }\n            i += bits[i] + 1;\n        }\n        return true;\n    }\n};",
    "id": "264252455",
    "lang": "cpp",
    "memory": "9.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "717",
     "title": "1-bit and 2-bit Characters",
     "titleSlug": "1-bit-and-2-bit-characters",
     "translatedTitle": "1 比特与 2 比特字符"
    },
    "rawMemory": "9728000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/1-bit-and-2-bit-characters/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643787255,
    "totalTestCaseCnt": 93
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\n    public boolean isOneBitCharacter(int[] bits) {\n        int i = 0;\n        while (i \u003c bits.length - 1) {\n            i += bits[i] + 1;\n        }\n        return i == bits.length - 1;\n    }\n}",
    "id": "264290478",
    "lang": "java",
    "memory": "40.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "717",
     "title": "1-bit and 2-bit Characters",
     "titleSlug": "1-bit-and-2-bit-characters",
     "translatedTitle": "1 比特与 2 比特字符"
    },
    "rawMemory": "41904000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/1-bit-and-2-bit-characters/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643797922,
    "totalTestCaseCnt": 93
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def isOneBitCharacter(self, bits: List[int]) -\u003e bool:\n        i = len(bits) - 2\n        while i \u003e= 0 and bits[i] == 1:\n            i -= 1\n        return (len(bits)-2-i) % 2 ==  0",
    "id": "264272469",
    "lang": "python3",
    "memory": "15 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "717",
     "title": "1-bit and 2-bit Characters",
     "titleSlug": "1-bit-and-2-bit-characters",
     "translatedTitle": "1 比特与 2 比特字符"
    },
    "rawMemory": "15348000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/1-bit-and-2-bit-characters/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643792484,
    "totalTestCaseCnt": 93
   },
   "typescript": {
    "__typename": "GeneralSubmissionNode",
    "code": "function isOneBitCharacter(bits: number[]): boolean {\n    let i = bits.length - 2\n    while (i \u003e= 0 \u0026\u0026 bits[i] == 1)i--;\n    return (bits.length - 2 - i) % 2 == 0\n\n};",
    "id": "264294081",
    "lang": "typescript",
    "memory": "42.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "717",
     "title": "1-bit and 2-bit Characters",
     "titleSlug": "1-bit-and-2-bit-characters",
     "translatedTitle": "1 比特与 2 比特字符"
    },
    "rawMemory": "43404000",
    "runtime": "68 ms",
    "sourceUrl": "/problems/1-bit-and-2-bit-characters/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643798343,
    "totalTestCaseCnt": 93
   }
  },
  "3sum": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cvector\u003cint\u003e \u003e ret;\n        if (nums.size() == 0) return ret;\n        sort(nums.begin(), nums.end());\n\n        for (int i = 0; i \u003c nums.size(); i++) {\n            if (nums[i] \u003e 0) break;\n            if (i \u003e 0 \u0026\u0026 nums[i - 1] == nums[i]) continue;\n            int target = -nums[i];\n            int l = i + 1, r = nums.size() - 1;\n            while (l \u003c r) {\n                if (nums[l] + nums[r] == target) {\n                    ret.push_back({nums[i], nums[l], nums[r]});\n                    //哈哈\\U0001f604\n                    while (l \u003c r \u0026\u0026 nums[l] == nums[l + 1]) l++;\n                    while (l \u003c r \u0026\u0026 nums[r] == nums[r - 1]) r--;\n                    l++;\n                    r--;\n                } else if (nums[l] + nums[r] \u003e target) {\n                    r--;\n                } else {\n                    l++;\n                }\n            }\n        }\n        return ret;\n    }\n};",
    "id": "261946012",
    "lang": "cpp",
    "memory": "19.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 318,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "15",
     "title": "3Sum",
     "titleSlug": "3sum",
     "translatedTitle": "三数之和"
    },
    "rawMemory": "19944000",
    "runtime": "64 ms",
    "sourceUrl": "/problems/3sum/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "经典的双指针啊",
     "flagType": "RED"
    },
    "timestamp": 1643021795,
    "totalTestCaseCnt": 318
   }
  },
  "N6YdxV": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int searchInsert(vector\u003cint\u003e\u0026 nums, int target) {\n        int lo = 0, hi = nums.size();\n        while (lo \u003c hi) {\n            int m = (lo + hi) \u003e\u003e 1;\n            if (nums[m] \u003c target) {\n                lo = m + 1;\n            } else if (nums[m] \u003e target) {\n                hi = m;\n            } else {\n                return m;\n            }\n        }\n        return lo;\n    }\n};",
    "id": "265482847",
    "lang": "cpp",
    "memory": "9.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 62,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000332",
     "title": "查找插入位置",
     "titleSlug": "N6YdxV",
     "translatedTitle": "查找插入位置"
    },
    "rawMemory": "9516000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/N6YdxV/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644218408,
    "totalTestCaseCnt": 62
   }
  },
  "SLwz0R": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        if (head == nullptr) return nullptr;\n        ListNode dummy(-1, head);\n        ListNode *fast = head, *slow = \u0026dummy;\n        for (int i = 0; i \u003c n \u0026\u0026 fast != nullptr; i++) {\n            fast = fast-\u003enext;\n        }\n        while (fast) {\n            fast = fast-\u003enext;\n            slow = slow-\u003enext;\n        }\n        auto next = slow-\u003enext-\u003enext;\n        delete slow-\u003enext;\n        slow-\u003enext = next;\n\n        return dummy.next;\n    }\n};",
    "id": "264968531",
    "lang": "cpp",
    "memory": "10.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000257",
     "title": "删除链表的倒数第 n 个结点",
     "titleSlug": "SLwz0R",
     "translatedTitle": "删除链表的倒数第 n 个结点"
    },
    "rawMemory": "10760000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/SLwz0R/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644058269,
    "totalTestCaseCnt": 208
   }
  },
  "UHnkqh": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (head == nullptr || head-\u003enext == nullptr) return head;\n        auto newHead = reverseList(head-\u003enext);\n        head-\u003enext-\u003enext = head;\n        head-\u003enext = nullptr;\n        return newHead;\n    }\n};",
    "id": "264679343",
    "lang": "cpp",
    "memory": "8.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000260",
     "title": "反转链表",
     "titleSlug": "UHnkqh",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "8360000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/UHnkqh/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "递归。",
     "flagType": "PURPLE"
    },
    "timestamp": 1643954604,
    "totalTestCaseCnt": 28
   }
  },
  "aMhZSa": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nbool isPalindrome(struct ListNode* head){\n    if (head == NULL) return false;\n    if (head-\u003enext == NULL) return true;\n    struct ListNode *fast = head, *slow = head;\n    while (fast \u0026\u0026 fast-\u003enext) {\n        fast = fast-\u003enext-\u003enext;\n        slow = slow-\u003enext;\n    }\n    struct ListNode* pre = NULL, *next = NULL;\n    while (slow) {\n        next = slow-\u003enext;\n        slow-\u003enext = pre;\n        pre = slow;\n        slow = next;\n    }\n\n    while (pre \u0026\u0026 head) {\n        if (pre-\u003eval != head-\u003eval) {\n            return false;\n        }\n        pre = pre-\u003enext;\n        head = head-\u003enext;\n    }\n    return true;\n}",
    "id": "264821463",
    "lang": "c",
    "memory": "40.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 85,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000263",
     "title": "回文链表",
     "titleSlug": "aMhZSa",
     "translatedTitle": "回文链表"
    },
    "rawMemory": "41404000",
    "runtime": "128 ms",
    "sourceUrl": "/problems/aMhZSa/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643996274,
    "totalTestCaseCnt": 85
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        vector\u003cListNode*\u003e vec;\n        while (head) {\n            vec.emplace_back(head);\n            head = head-\u003enext;\n        }\n\n        for (int i = 0; i \u003c vec.size()/2; i++) {\n            if (vec[i]-\u003eval != vec[vec.size() - 1 -i]-\u003eval) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
    "id": "264820955",
    "lang": "cpp",
    "memory": "134.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 85,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000263",
     "title": "回文链表",
     "titleSlug": "aMhZSa",
     "translatedTitle": "回文链表"
    },
    "rawMemory": "137760000",
    "runtime": "204 ms",
    "sourceUrl": "/problems/aMhZSa/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643995770,
    "totalTestCaseCnt": 85
   }
  },
  "add-binary": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string base , adder;\n        if (a.size() \u003e b.size()) {\n            base = a;\n            adder = b;\n        } else {\n            base = b;\n            adder = a;\n        }\n\n        int carry = 0;\n        for (int i = base.size() - 1, j = adder.size() - 1 ; i \u003e= 0; i--, j--) {\n            int sum = 0;\n            if (j \u003e= 0) {\n               sum = (base[i] - 0x30) + (adder[j] - 0x30) + carry;\n            } else {\n                sum = base[i] - 0x30 + carry;\n            }\n            base[i] = (sum % 2) + 0x30;\n            carry = sum / 2;\n        }\n\n        if (carry) {\n            base.insert(base.begin(), '1');\n        }\n\n        return base;\n    }\n};",
    "id": "9859534",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 294,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "67",
     "title": "Add Binary",
     "titleSlug": "add-binary",
     "translatedTitle": "二进制求和"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/add-binary/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543391472,
    "totalTestCaseCnt": 294
   }
  },
  "add-digits": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int addDigits(int num) {\n        while (num \u003e 9) {\n            int res = 0;\n            while (num \u003e 0) {\n                res += num%10;\n                num /= 10;\n            }\n            num = res;\n        }\n        return num;\n    }\n};",
    "id": "262619148",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1101,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "258",
     "title": "Add Digits",
     "titleSlug": "add-digits",
     "translatedTitle": "各位相加"
    },
    "rawMemory": "5912000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/add-digits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643197944,
    "totalTestCaseCnt": 1101
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func addDigits(num int) int {\n    if num \u003e 9 {\n        return addDigits(func(n int) int {\n            res := 0\n            for n \u003e 0 {\n                res += n % 10\n                n /= 10\n            }\n            return res\n        }(num))\n    }\n    return num\n}",
    "id": "262638604",
    "lang": "golang",
    "memory": "2.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1101,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "258",
     "title": "Add Digits",
     "titleSlug": "add-digits",
     "translatedTitle": "各位相加"
    },
    "rawMemory": "2184000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/add-digits/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "递归解法。\n",
     "flagType": "RED"
    },
    "timestamp": 1643202061,
    "totalTestCaseCnt": 1101
   },
   "javascript": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * @param {number} num\n * @return {number}\n */\nvar addDigits = function(num) {\n    return (num - 1) % 9 + 1\n};",
    "id": "233425908",
    "lang": "javascript",
    "memory": "39 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1101,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "258",
     "title": "Add Digits",
     "titleSlug": "add-digits",
     "translatedTitle": "各位相加"
    },
    "rawMemory": "39956000",
    "runtime": "84 ms",
    "sourceUrl": "/problems/add-digits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635477060,
    "totalTestCaseCnt": 1101
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def addDigits(self, num: int) -\u003e int:\n        if num \u003c 10:\n            return num\n        next = 0\n        while num \u003e 0:\n            next += num%10\n            num = num//10\n        return self.addDigits(next)",
    "id": "233425584",
    "lang": "python3",
    "memory": "14.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1101,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "258",
     "title": "Add Digits",
     "titleSlug": "add-digits",
     "translatedTitle": "各位相加"
    },
    "rawMemory": "15248000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/add-digits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635477019,
    "totalTestCaseCnt": 1101
   },
   "rust": {
    "__typename": "GeneralSubmissionNode",
    "code": "impl Solution {\n    pub fn add_digits(num: i32) -\u003e i32 {\n        (num - 1) % 9 + 1\n    }\n}",
    "id": "233420373",
    "lang": "rust",
    "memory": "1.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1101,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "258",
     "title": "Add Digits",
     "titleSlug": "add-digits",
     "translatedTitle": "各位相加"
    },
    "rawMemory": "1996000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/add-digits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635476299,
    "totalTestCaseCnt": 1101
   }
  },
  "add-strings": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string base = num2, adder = num1;\n        int carry = 0;\n        if (num1.size() \u003e num2.size()) {\n            base = num1;\n            adder = num2;\n        }\n        for (int i = base.size() - 1, j = adder.size() - 1 ; i \u003e= 0; i--, j--) {\n            int sum = 0;\n            if (j \u003e= 0) {\n                sum = (base[i] - 0x30) + (adder[j] - 0x30) + carry;\n            } else {\n                sum = base[i] - 0x30 + carry;\n            }\n            base[i] = (sum % 10) + 0x30;\n            carry = sum / 10;\n        }\n\n        if (carry) {\n            base.insert(base.begin(), '1');\n        }\n        return base;\n    }\n};\n",
    "id": "10179008",
    "lang": "cpp",
    "memory": "2.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 315,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "415",
     "title": "Add Strings",
     "titleSlug": "add-strings",
     "translatedTitle": "字符串相加"
    },
    "rawMemory": "2187264",
    "runtime": "4 ms",
    "sourceUrl": "/problems/add-strings/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544087501,
    "totalTestCaseCnt": 317
   }
  },
  "add-two-numbers": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* l3 = \u0026dummy;\n        int add = 0;\n        while (l1 || l2 || add) {\n            if (l1) {\n                add += l1-\u003eval;\n                l1 = l1-\u003enext;\n            }\n            if (l2) {\n                add += l2-\u003eval;\n                l2 = l2-\u003enext;\n            }\n            l3-\u003enext = new ListNode(add % 10);\n            l3 = l3-\u003enext;\n            add = add / 10; \n        }\n        return dummy.next;\n    }\n};",
    "id": "266276454",
    "lang": "cpp",
    "memory": "69.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1568,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "2",
     "title": "Add Two Numbers",
     "titleSlug": "add-two-numbers",
     "translatedTitle": "两数相加"
    },
    "rawMemory": "70980000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/add-two-numbers/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644397170,
    "totalTestCaseCnt": 1568
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n\thead := new(ListNode)\n\tcarry, sum, curr := 0, 0, head\n\n\tfor l1 != nil || l2 != nil || carry != 0 {\n\t\tif l1 != nil {\n\t\t\tsum += l1.Val\n\t\t\tl1 = l1.Next\n\t\t}\n\t\tif l2 != nil {\n\t\t\tsum += l2.Val\n\t\t\tl2 = l2.Next\n\t\t}\n\t\tcurr.Next = \u0026ListNode{\n\t\t\tVal:  sum % 10,\n\t\t\tNext: nil,\n\t\t}\n\t\tcarry = sum / 10\n\t\tcurr = curr.Next\n\t\tsum = carry\n\t}\n\n\treturn head.Next\n}\n",
    "id": "179264703",
    "lang": "golang",
    "memory": "4.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1568,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "2",
     "title": "Add Two Numbers",
     "titleSlug": "add-two-numbers",
     "translatedTitle": "两数相加"
    },
    "rawMemory": "4756000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/add-two-numbers/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "慢吗？",
     "flagType": "RED"
    },
    "timestamp": 1621498477,
    "totalTestCaseCnt": 1568
   }
  },
  "add-two-numbers-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        stack\u003cint\u003e s1, s2;\n\n        while (l1) s1.push(l1-\u003eval), l1 = l1-\u003enext;\n        while (l2) s2.push(l2-\u003eval), l2 = l2-\u003enext;\n        \n        int add = 0;\n        while (!s1.empty() || !s2.empty() || add) {\n            if (!s1.empty()) {\n                add += s1.top();\n                s1.pop();\n            }\n            if (!s2.empty()) {\n                add += s2.top();\n                s2.pop();\n            }\n            ListNode* node = new ListNode(add % 10, dummy.next);\n            dummy.next = node;\n            add = add / 10;\n        }\n        return dummy.next;\n    }\n};",
    "id": "266285072",
    "lang": "cpp",
    "memory": "71.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1563,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "445",
     "title": "Add Two Numbers II",
     "titleSlug": "add-two-numbers-ii",
     "translatedTitle": "两数相加 II"
    },
    "rawMemory": "73456000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/add-two-numbers-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644398148,
    "totalTestCaseCnt": 1563
   }
  },
  "arranging-coins": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    // total = (n+1)*n / 2\n    int arrangeCoins(int n) {\n        int left = 1, right = n;\n        while (left \u003c right) {\n            int mid = (right - left + 1) / 2 + left;\n            if ((long long) mid * (mid + 1) \u003e (long long) 2 * n) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return left;\n    }\n};",
    "id": "277936648",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1335,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "441",
     "title": "Arranging Coins",
     "titleSlug": "arranging-coins",
     "translatedTitle": "排列硬币"
    },
    "rawMemory": "5944000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/arranging-coins/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646493722,
    "totalTestCaseCnt": 1335
   }
  },
  "assign-cookies": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int findContentChildren(vector\u003cint\u003e\u0026 g, vector\u003cint\u003e\u0026 s) {\n        std::sort(g.begin(), g.end());\n        std::sort(s.begin(), s.end());\n        int i = 0, j = 0;\n        int ret = 0;\n        while (i \u003c g.size() \u0026\u0026 j \u003c s.size()) {\n            if (s[j] \u003c g[i]) {\n                j++;\n            } else {\n                j++;\n                i++;\n                ret++;\n            }\n        }\n        return ret;\n    }\n};",
    "id": "263022475",
    "lang": "cpp",
    "memory": "17.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "455",
     "title": "Assign Cookies",
     "titleSlug": "assign-cookies",
     "translatedTitle": "分发饼干"
    },
    "rawMemory": "17492000",
    "runtime": "28 ms",
    "sourceUrl": "/leetbook/read/greedy/rvrk1c/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643300604,
    "totalTestCaseCnt": 21
   }
  },
  "average-of-levels-in-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector\u003cdouble\u003e averageOfLevels(TreeNode* root) {\n        vector\u003cdouble\u003e res;\n        if (root == nullptr) return res;\n        queue\u003cTreeNode*\u003e q;\n\n        q.push(root);\n        while (!q.empty()) {\n            int levelSize = q.size();\n            double sum = 0.0;\n            for (int i =  0; i \u003c levelSize; i++) {\n                auto node = q.front(); q.pop();\n                sum += (double)node-\u003eval; \n                if (node-\u003eleft) q.push(node-\u003eleft);\n                if (node-\u003eright) q.push(node-\u003eright);\n            }\n            res.push_back(sum / levelSize);\n        }\n\n        return res;\n    }\n};",
    "id": "234547232",
    "lang": "cpp",
    "memory": "21.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 66,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "637",
     "title": "Average of Levels in Binary Tree",
     "titleSlug": "average-of-levels-in-binary-tree",
     "translatedTitle": "二叉树的层平均值"
    },
    "rawMemory": "22408000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/average-of-levels-in-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635785257,
    "totalTestCaseCnt": 66
   }
  },
  "balanced-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        if (root == nullptr) {\n            return true;\n        }\n        TreeNode* left = root-\u003eleft;\n        TreeNode* right = root-\u003eright;\n\n        return abs(hight(left) - hight(right)) \u003c= 1 \u0026\u0026 isBalanced(left) \u0026\u0026 isBalanced(right); \n    }\n\n    int hight(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        return std::max(hight(root-\u003eleft), hight(root-\u003eright)) + 1;\n    }\n};",
    "id": "234699908",
    "lang": "cpp",
    "memory": "20.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 228,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "110",
     "title": "Balanced Binary Tree",
     "titleSlug": "balanced-binary-tree",
     "translatedTitle": "平衡二叉树"
    },
    "rawMemory": "20852000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/balanced-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635837694,
    "totalTestCaseCnt": 228
   }
  },
  "best-time-to-buy-and-sell-stock": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        int max_profit = 0;\n        int min_price = prices[0];\n        for (int i = 1; i \u003c prices.size(); i++) {\n            max_profit = std::max(max_profit, prices[i] - min_price);\n            min_price = std::min(min_price, prices[i]);\n        }\n        return max_profit;\n    }\n};",
    "id": "263181518",
    "lang": "cpp",
    "memory": "91.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 211,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "121",
     "title": "Best Time to Buy and Sell Stock",
     "titleSlug": "best-time-to-buy-and-sell-stock",
     "translatedTitle": "买卖股票的最佳时机"
    },
    "rawMemory": "93240000",
    "runtime": "100 ms",
    "sourceUrl": "/problems/best-time-to-buy-and-sell-stock/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643355597,
    "totalTestCaseCnt": 211
   }
  },
  "best-time-to-buy-and-sell-stock-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        int res = 0;\n        for (int i = 1; i \u003c prices.size(); i++) {\n            // 把所有可能的利润都算上，自然就是最大的总利润\n            if (prices[i] \u003e prices[i - 1]) {\n                res += prices[i] - prices[i - 1];\n            }\n        }\n        return res;\n    }\n};",
    "id": "234415932",
    "lang": "cpp",
    "memory": "12.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 200,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "122",
     "title": "Best Time to Buy and Sell Stock II",
     "titleSlug": "best-time-to-buy-and-sell-stock-ii",
     "translatedTitle": "买卖股票的最佳时机 II"
    },
    "rawMemory": "12952000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/best-time-to-buy-and-sell-stock-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635763195,
    "totalTestCaseCnt": 200
   }
  },
  "binary-gap": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int binaryGap(int N) {\n        vector\u003cint\u003e indexes;\n        int index = 0;\n        while (N){\n            if (N \u0026 1)\n                indexes.push_back(index);\n            index ++;\n            N \u003e\u003e= 1;\n        }\n\n        int res = 0;\n        for (int i = 1 ; i \u003c indexes.size() ; i ++)\n            res = max(res, indexes[i] - indexes[i - 1]);\n\n        return res;\n    }\n};",
    "id": "9820923",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 260,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "899",
     "title": "Binary Gap",
     "titleSlug": "binary-gap",
     "translatedTitle": "二进制间距"
    },
    "rawMemory": "N/A",
    "runtime": "12 ms",
    "sourceUrl": "/problems/binary-gap/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543307328,
    "totalTestCaseCnt": 261
   }
  },
  "binary-prefix-divisible-by-5": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cbool\u003e prefixesDivBy5(vector\u003cint\u003e\u0026 nums) {\n        int size = nums.size();\n        vector\u003cbool\u003e res(size, false);\n        int num = 0;\n        for (int i = 0; i \u003c size; i++) {\n            num = (num \u003c\u003c 1) + nums[i];\n            num = num % 5;\n            res[i] = (num == 0);\n        }\n        return res;\n    }\n};",
    "id": "233536944",
    "lang": "cpp",
    "memory": "13.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1071",
     "title": "Binary Prefix Divisible By 5",
     "titleSlug": "binary-prefix-divisible-by-5",
     "translatedTitle": "可被 5 整除的二进制前缀"
    },
    "rawMemory": "13864000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/binary-prefix-divisible-by-5/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635498153,
    "totalTestCaseCnt": 24
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func prefixesDivBy5(nums []int) []bool {\n    ans := make([]bool, len(nums))\n    x := 0\n    // 如果x为和而不取模，有溢出问题啊！！！\n    for i, v := range nums {\n        x = (x\u003c\u003c1 | v) % 5\n        ans[i] = x == 0\n    }\n    return ans\n}",
    "id": "233019840",
    "lang": "golang",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1071",
     "title": "Binary Prefix Divisible By 5",
     "titleSlug": "binary-prefix-divisible-by-5",
     "translatedTitle": "可被 5 整除的二进制前缀"
    },
    "rawMemory": "6048000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/binary-prefix-divisible-by-5/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635349628,
    "totalTestCaseCnt": 24
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\n    // 有限状态机 DFA ？\n    public List\u003cBoolean\u003e prefixesDivBy5(int[] nums) {\n        List\u003cBoolean\u003e res = new ArrayList\u003c\u003e();\n        if (nums.length \u003c 1) {\n            return res;\n        }\n        int StateSet[][] = new int[][]{\n                {0, 1},\n                {2, 3},\n                {4, 0},\n                {1, 2},\n                {3, 4}\n        };\n        int state = 0;\n        for (int i = 0; i \u003c nums.length; i++) {\n            state = StateSet[state][nums[i]];  //转换后的状态\n            if (state == 0) {\n                res.add(Boolean.TRUE);\n            } else {\n                res.add(Boolean.FALSE);\n            }\n        }\n        return res;\n    }\n}",
    "id": "233018650",
    "lang": "java",
    "memory": "39.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1071",
     "title": "Binary Prefix Divisible By 5",
     "titleSlug": "binary-prefix-divisible-by-5",
     "translatedTitle": "可被 5 整除的二进制前缀"
    },
    "rawMemory": "39996000",
    "runtime": "2 ms",
    "sourceUrl": "/problems/binary-prefix-divisible-by-5/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635349359,
    "totalTestCaseCnt": 24
   }
  },
  "binary-search": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int search(int* nums, int numsSize, int target){\n    int i = 0, j = numsSize;\n    while (i \u003c j) {\n        int m = (i+j)\u003e\u003e1;\n        if (nums[m] \u003c target) {\n            i = m + 1;\n        } else if (nums[m] \u003e target) {\n            j = m;\n        } else {\n            return m; \n        }\n    }\n    return -1;\n}",
    "id": "265691065",
    "lang": "c",
    "memory": "6.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "792",
     "title": "Binary Search",
     "titleSlug": "binary-search",
     "translatedTitle": "二分查找"
    },
    "rawMemory": "6988000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/binary-search/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644261607,
    "totalTestCaseCnt": 47
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int search(vector\u003cint\u003e\u0026 nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l \u003c= r) {\n            int mid = l + (r - l)/2;\n            if (target \u003e nums[mid]) {\n                l = mid + 1;\n            } else if (target \u003c nums[mid]) {\n                r = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    }\n};",
    "id": "257003282",
    "lang": "cpp",
    "memory": "26.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "792",
     "title": "Binary Search",
     "titleSlug": "binary-search",
     "translatedTitle": "二分查找"
    },
    "rawMemory": "27516000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/binary-search/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1641811474,
    "totalTestCaseCnt": 47
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func search(nums []int, target int) int {\n    j, k := 0, len(nums)\n    for j \u003c k {\n        m := (j + k) \u003e\u003e 1\n        if nums[m] \u003c target {\n            j = m + 1\n        } else if (nums[m] \u003e target) {\n            k = m\n        } else {\n            return m\n        }\n    }\n    return -1\n}",
    "id": "264317012",
    "lang": "golang",
    "memory": "6.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "792",
     "title": "Binary Search",
     "titleSlug": "binary-search",
     "translatedTitle": "二分查找"
    },
    "rawMemory": "6708000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/binary-search/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643805705,
    "totalTestCaseCnt": 47
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def search(self, nums: List[int], target: int) -\u003e int:\n        i, j = 0, len(nums)\n        while i \u003c j:\n            m = (i + j)//2\n            if nums[m] == target:\n                return m\n            elif nums[m] \u003c target:\n                i = m + 1\n            else:\n                j = m\n\n        return -1\n",
    "id": "262387676",
    "lang": "python3",
    "memory": "16.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "792",
     "title": "Binary Search",
     "titleSlug": "binary-search",
     "translatedTitle": "二分查找"
    },
    "rawMemory": "16588000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/binary-search/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643130999,
    "totalTestCaseCnt": 47
   },
   "rust": {
    "__typename": "GeneralSubmissionNode",
    "code": "impl Solution {\n    pub fn search(nums: Vec\u003ci32\u003e, target: i32) -\u003e i32 {\n        let mut left = 0;\n        let mut right = nums.len();\n        while left \u003c right {\n            let mid = left + ((right - left) \u003e\u003e 1) ;\n            if target == nums[mid] {\n                return mid as i32;\n            } else if target \u003c nums[mid] {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return -1;\n    }\n}",
    "id": "231214581",
    "lang": "rust",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "792",
     "title": "Binary Search",
     "titleSlug": "binary-search",
     "translatedTitle": "二分查找"
    },
    "rawMemory": "2088000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-search/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "左闭右开",
     "flagType": "RED"
    },
    "timestamp": 1634866858,
    "totalTestCaseCnt": 47
   }
  },
  "binary-search-tree-iterator": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\n\ntypedef struct {\n    struct TreeNode* head;\n} BSTIterator;\n\nvoid inorder(BSTIterator* bst_iter, struct TreeNode* root) {\n    if (root == NULL) return;\n    inorder(bst_iter, root-\u003eright);\n    root-\u003eright = bst_iter-\u003ehead-\u003eright;\n    bst_iter-\u003ehead-\u003eright = root;\n    inorder(bst_iter, root-\u003eleft);\n}\n\nBSTIterator* bSTIteratorCreate(struct TreeNode* root) {\n    BSTIterator* bst_iter = malloc(sizeof(BSTIterator));\n    bst_iter-\u003ehead = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    bst_iter-\u003ehead-\u003eleft = NULL;\n    bst_iter-\u003ehead-\u003eright = NULL;\n\n    inorder(bst_iter, root);\n    return bst_iter;\n}\n\nint bSTIteratorNext(BSTIterator* obj) {\n    if (obj-\u003ehead-\u003eright == NULL) {\n        return -1;\n    }\n    int ret = obj-\u003ehead-\u003eright-\u003eval;\n    // for free\n    obj-\u003ehead-\u003eright-\u003eleft = obj-\u003ehead-\u003eleft;\n    obj-\u003ehead-\u003eleft = obj-\u003ehead-\u003eright;\n\n    obj-\u003ehead-\u003eright = obj-\u003ehead-\u003eright-\u003eright;\n    return ret;\n}\n\nbool bSTIteratorHasNext(BSTIterator* obj) {\n    return obj-\u003ehead-\u003eright != NULL;\n}\n\nvoid bSTIteratorFree(BSTIterator* obj) {\n    if (obj) {\n        while (obj-\u003ehead-\u003eleft) {\n            struct TreeNode* f = obj-\u003ehead-\u003eleft;\n            obj-\u003ehead-\u003eleft = obj-\u003ehead-\u003eleft-\u003eleft;\n            free(f);\n        }\n        free(obj-\u003ehead);\n        free(obj);\n    }\n}\n\n/**\n * Your BSTIterator struct will be instantiated and called as such:\n * BSTIterator* obj = bSTIteratorCreate(root);\n * int param_1 = bSTIteratorNext(obj);\n \n * bool param_2 = bSTIteratorHasNext(obj);\n \n * bSTIteratorFree(obj);\n*/",
    "id": "269281412",
    "lang": "c",
    "memory": "16.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "173",
     "title": "Binary Search Tree Iterator",
     "titleSlug": "binary-search-tree-iterator",
     "translatedTitle": "二叉搜索树迭代器"
    },
    "rawMemory": "17184000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/binary-search-tree-iterator/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "牛逼的解法。",
     "flagType": "RED"
    },
    "timestamp": 1645038172,
    "totalTestCaseCnt": 61
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass BSTIterator {\npublic:\n    BSTIterator(TreeNode* root) : vec_(0), index_(0) {\n        std::function\u003cvoid(TreeNode*)\u003e inorder = [\u0026,this](TreeNode *node) {\n            if (node == nullptr) return;\n            inorder(node-\u003eleft);\n            vec_.push_back(node-\u003eval);\n            inorder(node-\u003eright);\n        };\n        inorder(root);\n    }\n    \n    int next() {\n        return vec_[index_++];\n    }\n    \n    bool hasNext() {\n        if (index_ == vec_.size()) {\n            return false;\n        }\n        return true;\n    }\nprivate:\n    vector\u003cint\u003e vec_;\n    int index_;\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator* obj = new BSTIterator(root);\n * int param_1 = obj-\u003enext();\n * bool param_2 = obj-\u003ehasNext();\n */",
    "id": "263272759",
    "lang": "cpp",
    "memory": "24.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "173",
     "title": "Binary Search Tree Iterator",
     "titleSlug": "binary-search-tree-iterator",
     "translatedTitle": "二叉搜索树迭代器"
    },
    "rawMemory": "25216000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/binary-search-tree-iterator/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "递归先存数据。",
     "flagType": "RED"
    },
    "timestamp": 1643373022,
    "totalTestCaseCnt": 61
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\ntype BSTIterator struct {\n    root  *TreeNode\n    stack []*TreeNode\n}\n\n\nfunc Constructor(root *TreeNode) BSTIterator {\n    return BSTIterator{\n        root: root,\n    }\n}\n\n\nfunc (this *BSTIterator) Next() int {\n    if !this.HasNext() {\n        return -1\n    }\n\n    for this.root != nil {\n        this.stack = append(this.stack, this.root)\n        this.root = this.root.Left\n    }\n    topIndex := len(this.stack) - 1\n    this.root = this.stack[topIndex]\n    this.stack = this.stack[:topIndex]\n    ret := this.root.Val\n    this.root = this.root.Right\n    return ret\n}\n\n\nfunc (this *BSTIterator) HasNext() bool {\n    return this.root != nil || len(this.stack) != 0 \n}\n\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * obj := Constructor(root);\n * param_1 := obj.Next();\n * param_2 := obj.HasNext();\n */",
    "id": "269276544",
    "lang": "golang",
    "memory": "9.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "173",
     "title": "Binary Search Tree Iterator",
     "titleSlug": "binary-search-tree-iterator",
     "translatedTitle": "二叉搜索树迭代器"
    },
    "rawMemory": "9684000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/binary-search-tree-iterator/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1645035053,
    "totalTestCaseCnt": 61
   }
  },
  "binary-search-tree-to-greater-sum-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* bstToGst(TreeNode* root) {\n        std::stack\u003cTreeNode*\u003e stk;\n        TreeNode* curr = root;\n        int sum = 0;\n        while (curr || !stk.empty()) {\n            while (curr) {\n                stk.push(curr);\n                curr = curr-\u003eright;\n            }\n            curr = stk.top(), stk.pop();\n            sum += curr-\u003eval;\n            curr-\u003eval = sum;\n            curr = curr-\u003eleft;\n        }\n        return root;\n    }\n};",
    "id": "268331386",
    "lang": "cpp",
    "memory": "8.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1114",
     "title": "Binary Search Tree to Greater Sum Tree",
     "titleSlug": "binary-search-tree-to-greater-sum-tree",
     "translatedTitle": "从二叉搜索树到更大和树"
    },
    "rawMemory": "8360000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-search-tree-to-greater-sum-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644843419,
    "totalTestCaseCnt": 28
   }
  },
  "binary-tree-inorder-traversal": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector\u003cint\u003e inorderTraversal(TreeNode* root) {\n        stack\u003cTreeNode*\u003e st;\n        vector\u003cint\u003e res;\n        while (root || !st.empty()) {\n            while (root) {\n                st.push(root);\n                root = root-\u003eleft;\n            }\n            auto node = st.top(); st.pop();\n            res.emplace_back(node-\u003eval);\n            root = node-\u003eright;\n        }\n        return res;\n    }\n};",
    "id": "264671405",
    "lang": "cpp",
    "memory": "8.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "94",
     "title": "Binary Tree Inorder Traversal",
     "titleSlug": "binary-tree-inorder-traversal",
     "translatedTitle": "二叉树的中序遍历"
    },
    "rawMemory": "8276000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/binary-tree-inorder-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643951954,
    "totalTestCaseCnt": 70
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\nfunc inorderTraversal(root *TreeNode) []int {\r\n\tres := []int{}\r\n\tvar inorder func(*TreeNode)\r\n\r\n\tinorder = func(n *TreeNode) {\r\n\t\tif n == nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tinorder(n.Left)\r\n\t\tres = append(res, n.Val)\r\n\t\tinorder(n.Right)\r\n\t}\r\n\r\n\tinorder(root)\r\n\treturn res\r\n}\r\n",
    "id": "193165214",
    "lang": "golang",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "94",
     "title": "Binary Tree Inorder Traversal",
     "titleSlug": "binary-tree-inorder-traversal",
     "translatedTitle": "二叉树的中序遍历"
    },
    "rawMemory": "2060000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-tree-inorder-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1625630088,
    "totalTestCaseCnt": 70
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -\u003e List[int]:\n        stack = []\n        res = []\n        while root or len(stack) \u003e 0:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res",
    "id": "264670337",
    "lang": "python3",
    "memory": "15 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "94",
     "title": "Binary Tree Inorder Traversal",
     "titleSlug": "binary-tree-inorder-traversal",
     "translatedTitle": "二叉树的中序遍历"
    },
    "rawMemory": "15396000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/binary-tree-inorder-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643951600,
    "totalTestCaseCnt": 70
   }
  },
  "binary-tree-level-order-traversal": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e levelOrder(TreeNode* root) {\n        vector\u003cvector\u003cint\u003e\u003e res;\n        queue\u003cTreeNode*\u003e _q;\n        _q.push(root);\n\n        vector\u003cint\u003e tmp;\n        while (!_q.empty()) {\n            int n = _q.size();\n            for (int i = 0; i \u003c n; i++) {\n                TreeNode* node = _q.front();\n                _q.pop();\n                if (node == nullptr) continue;\n                tmp.push_back(node-\u003eval);\n                _q.push(node-\u003eleft);\n                _q.push(node-\u003eright);\n            }\n            if (tmp.size() \u003e 0) {\n                res.push_back(tmp);\n                tmp.clear();\n            }\n        }\n        return res;\n    }\n};",
    "id": "262483654",
    "lang": "cpp",
    "memory": "12.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "102",
     "title": "Binary Tree Level Order Traversal",
     "titleSlug": "binary-tree-level-order-traversal",
     "translatedTitle": "二叉树的层序遍历"
    },
    "rawMemory": "12432000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-tree-level-order-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "可以插入null",
     "flagType": "RED"
    },
    "timestamp": 1643174419,
    "totalTestCaseCnt": 34
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrder(root *TreeNode) [][]int {\n    res := make([][]int, 0)\n    q := make([]*TreeNode, 0)\n\n    q = append(q, root)\n    for len(q) \u003e 0 {\n        tmp := []int{}\n        size := len(q)\n        for i := 0; i \u003c size; i++ {\n            node := q[i]\n            if node != nil {\n                tmp = append(tmp, node.Val)\n                q = append(q, node.Left, node.Right)\n            }\n        }\n        q = q[size:]\n        if len(tmp) \u003e 0 {\n            res = append(res, tmp)\n        }\n    }\n    return res;\n}",
    "id": "269264257",
    "lang": "golang",
    "memory": "2.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "102",
     "title": "Binary Tree Level Order Traversal",
     "titleSlug": "binary-tree-level-order-traversal",
     "translatedTitle": "二叉树的层序遍历"
    },
    "rawMemory": "2760000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-tree-level-order-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1645028568,
    "totalTestCaseCnt": 34
   }
  },
  "binary-tree-level-order-traversal-ii": {
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrderBottom(root *TreeNode) [][]int {\n    res := [][]int{}\n    if root == nil {\n        return res\n    }\n    q := []*TreeNode{}\n    q = append(q, root)\n    for {\n        levelLen := len(q)\n        if levelLen == 0 {\n            break;\n        }\n        levelVec := make([]int, 0, levelLen)\n        for i := 0; i \u003c levelLen; i++ {\n            levelVec = append(levelVec, q[i].Val)\n            if q[i].Left != nil {\n                q = append(q, q[i].Left)\n            }\n\n            if q[i].Right != nil {\n                q = append(q, q[i].Right)\n            }\n        }\n        res = append(res, levelVec)\n        q = q[levelLen: len(q)]\n    }\n    reverse(res)\n    return res;\n}\n\nfunc reverse(vec [][]int) {\n    l, r := 0, len(vec)\n    if r == 0 {\n        return \n    } else {\n        r--\n    }\n\n    for (l \u003c r) {\n        vec[l], vec[r] = vec[r], vec[l]\n        l++\n        r--\n    }\n}\n\n",
    "id": "234659485",
    "lang": "golang",
    "memory": "2.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "107",
     "title": "Binary Tree Level Order Traversal II",
     "titleSlug": "binary-tree-level-order-traversal-ii",
     "translatedTitle": "二叉树的层序遍历 II"
    },
    "rawMemory": "2852000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-tree-level-order-traversal-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635830687,
    "totalTestCaseCnt": 34
   }
  },
  "binary-tree-maximum-path-sum": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        int res = INT_MIN;\n        calculateSum(root, res);\n        return res;\n    }\n\n    int calculateSum(TreeNode* root, int\u0026 res) {\n        if (root == nullptr) return 0;\n        int s1 = calculateSum(root-\u003eleft, res);\n        int s2 = calculateSum(root-\u003eright, res);\n        s1 = max(0, s1);\n        s2 = max(0, s2);\n        res = max(res, s1 + s2 + root-\u003eval);\n        return max(s1, s2) + root-\u003eval;\n    }\n};",
    "id": "265268827",
    "lang": "cpp",
    "memory": "26.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 94,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "124",
     "title": "Binary Tree Maximum Path Sum",
     "titleSlug": "binary-tree-maximum-path-sum",
     "translatedTitle": "二叉树中的最大路径和"
    },
    "rawMemory": "27532000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/binary-tree-maximum-path-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644150595,
    "totalTestCaseCnt": 94
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxPathSum(root *TreeNode) int {\n    res := -1\u003c\u003c31\n    var dfs func(root *TreeNode) int = nil\n    dfs = func(root *TreeNode) int {\n        if root == nil {\n            return 0\n        }\n        x := max(0, dfs(root.Left))\n        y := max(0, dfs(root.Right))\n        res = max(res, x + y + root.Val)\n        return max(x, y) + root.Val\n    }\n    dfs(root)\n    return res\n}\n\nfunc max(a, b int) int {\n    if a \u003e b {\n        return a\n    }\n    return b\n}",
    "id": "265280867",
    "lang": "golang",
    "memory": "7.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 94,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "124",
     "title": "Binary Tree Maximum Path Sum",
     "titleSlug": "binary-tree-maximum-path-sum",
     "translatedTitle": "二叉树中的最大路径和"
    },
    "rawMemory": "7600000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/binary-tree-maximum-path-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "DFS  INT_MIN = -1 \u003c\u003c 31",
     "flagType": "ORANGE"
    },
    "timestamp": 1644153170,
    "totalTestCaseCnt": 94
   }
  },
  "binary-tree-paths": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n\n\n    \npublic:\n    vector\u003cstring\u003e binaryTreePaths(TreeNode* root) {\n        vector\u003cstring\u003e res;\n        if (root == NULL) return res;\n        \n        string v = to_string(root-\u003eval);\n        \n        if (root-\u003eleft == NULL \u0026\u0026 root-\u003eright == NULL) {\n            res.push_back(v);\n            return res;\n        }\n        \n        vector\u003cstring\u003e lv = binaryTreePaths(root-\u003eleft);\n        vector\u003cstring\u003e rv = binaryTreePaths(root-\u003eright);\n        \n        \n        for (string s : lv) {\n            res.push_back(v + \"-\u003e\" + s);\n        }\n        for (string s : rv) {\n            res.push_back(v + \"-\u003e\" + s);\n        }\n        \n        return res;\n    }\n};",
    "id": "8562298",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 209,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "257",
     "title": "Binary Tree Paths",
     "titleSlug": "binary-tree-paths",
     "translatedTitle": "二叉树的所有路径"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/binary-tree-paths/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1540217522,
    "totalTestCaseCnt": 208
   }
  },
  "binary-tree-postorder-traversal": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector\u003cint\u003e postorderTraversal(TreeNode* root) {\n        vector\u003cint\u003e res;\n        if (root == NULL)\n            return res;\n\n        stack\u003cTreeNode*\u003e stack, output;\n\n        TreeNode* p = root;\n        while (p != NULL || !stack.empty()) {\n            if (p != NULL) {\n                stack.push(p);\n                output.push(p);\n                p = p-\u003eright;\n            } else {\n                p = stack.top();\n                stack.pop();\n                p = p-\u003eleft;\n            }\n        }\n\n        while (!output.empty()) {\n            res.push_back((output.top())-\u003eval);\n            output.pop();\n        }\n        return res;\n    }\n};\n",
    "id": "10396559",
    "lang": "cpp",
    "memory": "856.1 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "145",
     "title": "Binary Tree Postorder Traversal",
     "titleSlug": "binary-tree-postorder-traversal",
     "translatedTitle": "二叉树的后序遍历"
    },
    "rawMemory": "856064",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-tree-postorder-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544607224,
    "totalTestCaseCnt": 68
   }
  },
  "binary-tree-preorder-traversal": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector\u003cint\u003e preorderTraversal(TreeNode* root) {\n        std::vector\u003cint\u003e res;\n        if (root == nullptr) {\n            return res;\n        }\n        std::stack\u003cTreeNode*\u003e stk;\n        while (root || !stk.empty()) {\n            while (root) {\n                stk.push(root);\n                res.push_back(root-\u003eval);\n                root = root-\u003eleft;\n            }\n            root = stk.top();\n            stk.pop();\n            root = root-\u003eright;\n        }\n\n        return res;\n    }\n};",
    "id": "276875845",
    "lang": "cpp",
    "memory": "8.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 69,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "144",
     "title": "Binary Tree Preorder Traversal",
     "titleSlug": "binary-tree-preorder-traversal",
     "translatedTitle": "二叉树的前序遍历"
    },
    "rawMemory": "8304000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-tree-preorder-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646321124,
    "totalTestCaseCnt": 69
   }
  },
  "binary-tree-pruning": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* pruneTree(struct TreeNode* root){\n    if (root == NULL) {\n        return NULL;\n    }\n    root-\u003eleft = pruneTree(root-\u003eleft);\n    root-\u003eright = pruneTree(root-\u003eright);\n    if (!root-\u003eleft \u0026\u0026 !root-\u003eright \u0026\u0026 !root-\u003eval) {\n        return NULL;\n    }\n\n    return root;\n}",
    "id": "275539879",
    "lang": "c",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 30,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "832",
     "title": "Binary Tree Pruning",
     "titleSlug": "binary-tree-pruning",
     "translatedTitle": "二叉树剪枝"
    },
    "rawMemory": "6156000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-tree-pruning/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646141369,
    "totalTestCaseCnt": 30
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if (root == nullptr) {\n            return nullptr;\n        }\n        root-\u003eright = pruneTree(root-\u003eright);\n        root-\u003eleft = pruneTree(root-\u003eleft);\n        if (!root-\u003eright \u0026\u0026 !root-\u003eleft \u0026\u0026 !root-\u003eval) {\n            return nullptr;\n        }\n        return root;\n    }\n};",
    "id": "275537866",
    "lang": "cpp",
    "memory": "8.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 30,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "832",
     "title": "Binary Tree Pruning",
     "titleSlug": "binary-tree-pruning",
     "translatedTitle": "二叉树剪枝"
    },
    "rawMemory": "8656000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/binary-tree-pruning/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646141216,
    "totalTestCaseCnt": 30
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc pruneTree(root *TreeNode) *TreeNode {\n    if root == nil {\n        return nil\n    }\n    root.Left = pruneTree(root.Left)\n    root.Right = pruneTree(root.Right)\n    if root.Left == nil \u0026\u0026 root.Right == nil \u0026\u0026 root.Val == 0 {\n        return nil\n    }\n    return root;\n}",
    "id": "275541087",
    "lang": "golang",
    "memory": "2.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 30,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "832",
     "title": "Binary Tree Pruning",
     "titleSlug": "binary-tree-pruning",
     "translatedTitle": "二叉树剪枝"
    },
    "rawMemory": "2244000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/binary-tree-pruning/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646141460,
    "totalTestCaseCnt": 30
   }
  },
  "binary-tree-right-side-view": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector\u003cint\u003e rightSideView(TreeNode* root) {\n        vector\u003cint\u003e res;\n        if (root == nullptr) return  res;\n        queue\u003cTreeNode*\u003e q;\n        q.push(root);\n\n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i \u003c size; i++) {\n                auto node = q.front();\n                q.pop();\n                if (i == size - 1) res.push_back(node-\u003eval);\n                if (node-\u003eleft) q.push(node-\u003eleft);\n                if (node-\u003eright) q.push(node-\u003eright);\n            }\n        }\n        return res;\n    }\n};",
    "id": "264817785",
    "lang": "cpp",
    "memory": "11.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 215,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "199",
     "title": "Binary Tree Right Side View",
     "titleSlug": "binary-tree-right-side-view",
     "translatedTitle": "二叉树的右视图"
    },
    "rawMemory": "12036000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/binary-tree-right-side-view/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "主要是思路啊。",
     "flagType": "ORANGE"
    },
    "timestamp": 1643993293,
    "totalTestCaseCnt": 215
   }
  },
  "binary-tree-zigzag-level-order-traversal": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e zigzagLevelOrder(TreeNode* root) {\n        vector\u003cvector\u003cint\u003e\u003e res;\n        queue\u003cTreeNode*\u003e q;\n        q.push(root);\n\n        vector\u003cint\u003e tmp;\n        int cnt = 0;\n        while (q.size() \u003e 0) {\n            tmp.clear();\n            auto len = q.size();\n            for (int i = 0; i \u003c len; i++) {\n                auto node = q.front();\n                q.pop();\n                if (node) {\n                    tmp.push_back(node-\u003eval);\n                    q.push(node-\u003eleft);\n                    q.push(node-\u003eright);\n                }\n            }\n            if (tmp.size() \u003e 0) {\n                if (++cnt % 2 == 0) reverse(tmp.begin(), tmp.end());\n                res.emplace_back(tmp);\n            }\n        }\n\n        return res;\n    }\n};",
    "id": "269266276",
    "lang": "cpp",
    "memory": "11.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 33,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "103",
     "title": "Binary Tree Zigzag Level Order Traversal",
     "titleSlug": "binary-tree-zigzag-level-order-traversal",
     "translatedTitle": "二叉树的锯齿形层序遍历"
    },
    "rawMemory": "12072000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/binary-tree-zigzag-level-order-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1645029186,
    "totalTestCaseCnt": 33
   }
  },
  "build-an-array-with-stack-operations": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cstring\u003e buildArray(vector\u003cint\u003e\u0026 target, int n) {\n        vector\u003cstring\u003e res;\n        int cnt_neq = 0;\n        for (int i = 1, j = 0; i \u003c= n \u0026\u0026 j \u003c target.size(); i++) {\n            res.emplace_back(\"Push\");\n            if (target[j] != i) {\n                res.emplace_back(\"Pop\");\n            } else {\n                j++;\n            }\n        }\n        return res;\n    }\n};",
    "id": "263033004",
    "lang": "cpp",
    "memory": "7.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 49,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1552",
     "title": "Build an Array With Stack Operations",
     "titleSlug": "build-an-array-with-stack-operations",
     "translatedTitle": "用栈操作构建数组"
    },
    "rawMemory": "7728000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/build-an-array-with-stack-operations/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643306346,
    "totalTestCaseCnt": 49
   }
  },
  "building-h2o": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "typedef struct {\n    // User defined data may be declared here.\n    pthread_mutex_t mu;\n    pthread_cond_t cond;\n    int h_left;\n} H2O;\n\nH2O* h2oCreate() {\n    H2O* obj = (H2O*) malloc(sizeof(H2O));\n    \n    // Initialize user defined data here.\n    obj-\u003eh_left = 0;\n    pthread_mutex_init(\u0026obj-\u003emu, NULL);\n    pthread_cond_init(\u0026obj-\u003econd, NULL);\n    return obj;\n}\n\nvoid hydrogen(H2O* obj) {\n    pthread_mutex_lock(\u0026obj-\u003emu);\n    while (obj-\u003eh_left == 2) {\n      pthread_cond_wait(\u0026obj-\u003econd, \u0026obj-\u003emu);\n    }\n    // releaseHydrogen() outputs \"H\". Do not change or remove this line.\n    releaseHydrogen();\n    obj-\u003eh_left++;\n    pthread_cond_broadcast(\u0026obj-\u003econd);\n    pthread_mutex_unlock(\u0026obj-\u003emu);\n}\n\nvoid oxygen(H2O* obj) {\n    pthread_mutex_lock(\u0026obj-\u003emu);\n    while (obj-\u003eh_left \u003c 2) {\n        pthread_cond_wait(\u0026obj-\u003econd, \u0026obj-\u003emu);\n    }\n    // releaseOxygen() outputs \"O\". Do not change or remove this line.\n    releaseOxygen();\n    obj-\u003eh_left = 0;\n    pthread_cond_broadcast(\u0026obj-\u003econd);\n    pthread_mutex_unlock(\u0026obj-\u003emu);\n}\n\nvoid h2oFree(H2O* obj) {\n    // User defined data may be cleaned up here.\n    if (obj) {\n      pthread_mutex_destroy(\u0026obj-\u003emu);\n      pthread_cond_destroy(\u0026obj-\u003econd);\n      free(obj);\n    }\n}",
    "id": "267405193",
    "lang": "c",
    "memory": "8.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 11,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1186",
     "title": "Building H2O",
     "titleSlug": "building-h2o",
     "translatedTitle": "H2O 生成"
    },
    "rawMemory": "8580000",
    "runtime": "148 ms",
    "sourceUrl": "/problems/building-h2o/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644650665,
    "totalTestCaseCnt": 11
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class H2O {\npublic:\n    H2O() {\n      hydrogen_left_ = 0;\n    }\n\n    void hydrogen(function\u003cvoid()\u003e releaseHydrogen) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        cv_.wait(lk, [this]{ return hydrogen_left_ \u003c 2; });\n        // releaseHydrogen() outputs \"H\". Do not change or remove this line.\n        releaseHydrogen();\n        hydrogen_left_++;\n        lk.unlock();\n        cv_.notify_all();\n    }\n\n    void oxygen(function\u003cvoid()\u003e releaseOxygen) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        cv_.wait(lk, [this]{ return hydrogen_left_ == 2; });\n        // releaseOxygen() outputs \"O\". Do not change or remove this line.\n        releaseOxygen();\n        hydrogen_left_ = 0;\n        lk.unlock();\n        cv_.notify_all();\n    }\nprivate:\n  std::mutex mu_;\n  std::condition_variable cv_;\n  int hydrogen_left_;\n};",
    "id": "267401480",
    "lang": "cpp",
    "memory": "8.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 11,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1186",
     "title": "Building H2O",
     "titleSlug": "building-h2o",
     "translatedTitle": "H2O 生成"
    },
    "rawMemory": "8832000",
    "runtime": "112 ms",
    "sourceUrl": "/problems/building-h2o/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644650108,
    "totalTestCaseCnt": 11
   }
  },
  "check-if-a-number-is-majority-element-in-a-sorted-array": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "bool isMajorityElement(int* nums, int numsSize, int target){\n    int start = 0, end = numsSize-1;\n    int targetSize = 0;\n    while (start \u003c end) {\n        if (nums[start] != target) {\n            start++;\n        } else if (nums[end] != target) {\n            end--;\n        }\n        if (targetSize == end-start+1) {\n            return targetSize \u003e numsSize/2;\n        } else {\n            targetSize = end-start+1;\n        }\n    }\n    return false;\n}",
    "id": "265422322",
    "lang": "c",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1102",
     "title": "Check If a Number Is Majority Element in a Sorted Array",
     "titleSlug": "check-if-a-number-is-majority-element-in-a-sorted-array",
     "translatedTitle": "检查一个数是否在数组中占绝大多数"
    },
    "rawMemory": "5984000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/check-if-a-number-is-majority-element-in-a-sorted-array/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "双指针",
     "flagType": "GREEN"
    },
    "timestamp": 1644206248,
    "totalTestCaseCnt": 39
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isMajorityElement(vector\u003cint\u003e\u0026 nums, int target) {\n        int cnt = 0;\n        for (auto n : nums) {\n            if (target == n) cnt++;\n            else if (target \u003c n) break;\n        }\n        return cnt \u003e nums.size()/2;\n    }\n};",
    "id": "265415860",
    "lang": "cpp",
    "memory": "7.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1102",
     "title": "Check If a Number Is Majority Element in a Sorted Array",
     "titleSlug": "check-if-a-number-is-majority-element-in-a-sorted-array",
     "translatedTitle": "检查一个数是否在数组中占绝大多数"
    },
    "rawMemory": "7552000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/check-if-a-number-is-majority-element-in-a-sorted-array/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "直接统计",
     "flagType": "PURPLE"
    },
    "timestamp": 1644205184,
    "totalTestCaseCnt": 39
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func isMajorityElement(nums []int, target int) bool {\n    j , k := 0, len(nums)\n    for j \u003c k {\n        m := (j+k)\u003e\u003e1\n        if nums[m] \u003c target {\n            j = m + 1\n        } else {\n            k = m\n        }\n    }\n    j += len(nums)/2\n    return j \u003c len(nums) \u0026\u0026 nums[j] == target\n}",
    "id": "265428634",
    "lang": "golang",
    "memory": "2.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1102",
     "title": "Check If a Number Is Majority Element in a Sorted Array",
     "titleSlug": "check-if-a-number-is-majority-element-in-a-sorted-array",
     "translatedTitle": "检查一个数是否在数组中占绝大多数"
    },
    "rawMemory": "2440000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/check-if-a-number-is-majority-element-in-a-sorted-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644207645,
    "totalTestCaseCnt": 39
   }
  },
  "check-if-it-is-a-straight-line": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool checkStraightLine(vector\u003cvector\u003cint\u003e\u003e\u0026 coordinates) {\n        // (y-y1)/(x-x1) = (y-y2)/(x-x2)\n        // (y-y1)*(x-x2) = (y-y2)*(x-x1)\n        int x = coordinates[0][0];\n        int y = coordinates[0][1];\n        for (int i = 1; i \u003c coordinates.size(); i++) {\n            int f1 = (y - coordinates[i-1][1]) * (x - coordinates[i][0]);\n            int f2 = (y - coordinates[i][1]) * (x - coordinates[i-1][0]);\n            if (f1 != f2) return false;\n        }\n        return true;\n    }\n};",
    "id": "263277253",
    "lang": "cpp",
    "memory": "9.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 79,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1349",
     "title": "Check If It Is a Straight Line",
     "titleSlug": "check-if-it-is-a-straight-line",
     "translatedTitle": "缀点成线"
    },
    "rawMemory": "9932000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/check-if-it-is-a-straight-line/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "数学公式\n(y - y1) / (x - x1) = (y - y2)  / (x - x2)",
     "flagType": "RED"
    },
    "timestamp": 1643374047,
    "totalTestCaseCnt": 79
   }
  },
  "climbing-stairs": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if (n \u003c 3) return n;\n        vector\u003cint\u003e dp(n+1);\n        dp[1] = 1, dp[2] = 2;\n        for (int i = 3; i \u003c= n; i++) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n};",
    "id": "266414569",
    "lang": "cpp",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 45,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "70",
     "title": "Climbing Stairs",
     "titleSlug": "climbing-stairs",
     "translatedTitle": "爬楼梯"
    },
    "rawMemory": "6168000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/climbing-stairs/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644418110,
    "totalTestCaseCnt": 45
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func climbStairs(n int) int {\r\n\tt := make([]int, n+2)\r\n\tt[1] = 1\r\n\tt[2] = 2\r\n\r\n\tfor i := 3; i \u003c= n; i++ {\r\n\t\tt[i] = t[i-1] + t[i-2]\r\n\t}\r\n\treturn t[n]\r\n}\r\n",
    "id": "193129451",
    "lang": "golang",
    "memory": "1.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 45,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "70",
     "title": "Climbing Stairs",
     "titleSlug": "climbing-stairs",
     "translatedTitle": "爬楼梯"
    },
    "rawMemory": "1988000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/climbing-stairs/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1625625969,
    "totalTestCaseCnt": 45
   }
  },
  "clone-n-ary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector\u003cNode*\u003e children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector\u003cNode*\u003e _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* cloneTree(Node* root) {\n        if (root == nullptr) {\n            return nullptr;\n        }\n        Node* newRoot = new Node(root-\u003eval);\n        for (auto child : root-\u003echildren) {\n            newRoot-\u003echildren.push_back(cloneTree(child));\n        }\n\n        return newRoot;\n    }\n};",
    "id": "275548678",
    "lang": "cpp",
    "memory": "171.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1634",
     "title": "Clone N-ary Tree",
     "titleSlug": "clone-n-ary-tree",
     "translatedTitle": "克隆 N 叉树"
    },
    "rawMemory": "175264000",
    "runtime": "44 ms",
    "sourceUrl": "/problems/clone-n-ary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646142037,
    "totalTestCaseCnt": 38
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Children []*Node\n * }\n */\n\nfunc cloneTree(root *Node) *Node {\n\tif root == nil {\n        return nil\n    }\n    newRoot := new(Node)\n    newRoot.Val = root.Val\n    for _, ch := range root.Children {\n        newRoot.Children = append(newRoot.Children, cloneTree(ch))\n    }\n\n    return newRoot\n}",
    "id": "275551582",
    "lang": "golang",
    "memory": "6.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1634",
     "title": "Clone N-ary Tree",
     "titleSlug": "clone-n-ary-tree",
     "translatedTitle": "克隆 N 叉树"
    },
    "rawMemory": "6496000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/clone-n-ary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646142260,
    "totalTestCaseCnt": 38
   }
  },
  "closest-binary-search-tree-value": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int closestValue(TreeNode* root, double target) {\n        int closest = INT_MAX;\n        auto getClose = [](int a, int b, double target) -\u003eint {\n            double d1 = static_cast\u003cdouble\u003e(a) - target;\n            double d2 = static_cast\u003cdouble\u003e(b) - target;\n            if (std::abs(d1) \u003e std::abs(d2)) {\n                return b;\n            }\n            return a;\n        };\n\n        std::function\u003cvoid(TreeNode*)\u003e search = [\u0026](TreeNode* node) {\n            if (node == nullptr) return;\n            closest = getClose(closest, node-\u003eval, target);\n            if (node-\u003eleft == nullptr) {\n                return search(node-\u003eright);\n            } else if (node-\u003eright == nullptr) {\n                return search(node-\u003eleft);\n            }\n            search(node-\u003eleft);\n            search(node-\u003eright);\n        };\n        search(root);\n        return closest;\n    }\n};",
    "id": "262933537",
    "lang": "cpp",
    "memory": "20.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 63,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "270",
     "title": "Closest Binary Search Tree Value",
     "titleSlug": "closest-binary-search-tree-value",
     "translatedTitle": "最接近的二叉搜索树值"
    },
    "rawMemory": "20820000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/closest-binary-search-tree-value/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643281011,
    "totalTestCaseCnt": 63
   }
  },
  "combination-sum": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\nprivate:\n    void combinationSum(vector\u003cint\u003e\u0026 candidates, int index, int target, vector\u003cint\u003e\u0026 one, vector\u003cvector\u003cint\u003e\u003e\u0026 res) {\n        for (int i = index; i \u003c candidates.size(); i++) {\n            if (target \u003c candidates[i]) {\n                break;\n            } else if (target == candidates[i]) {\n                one.push_back(candidates[i]);\n                res.push_back(one);\n                one.pop_back();\n            } else {\n                one.push_back(candidates[i]);\n                //target 为i，\\U0001f431\n                combinationSum(candidates, i, target - candidates[i], one, res);\n                one.pop_back();\n            }\n        }\n    }\n\npublic:\n    vector\u003cvector\u003cint\u003e\u003e combinationSum(vector\u003cint\u003e\u0026 candidates, int target) {\n        vector\u003cvector\u003cint\u003e\u003e res;\n        vector\u003cint\u003e one;\n        sort(candidates.begin(), candidates.end());\n        combinationSum(candidates, 0, target, one, res);\n        return res;\n    }\n};\n",
    "id": "10559635",
    "lang": "cpp",
    "memory": "1.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 168,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "39",
     "title": "Combination Sum",
     "titleSlug": "combination-sum",
     "translatedTitle": "组合总和"
    },
    "rawMemory": "1540096",
    "runtime": "12 ms",
    "sourceUrl": "/problems/combination-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545040170,
    "totalTestCaseCnt": 170
   }
  },
  "combinations": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e combine(int n, int k) {\n        vector\u003cvector\u003cint\u003e\u003e res;\n        vector\u003cint\u003e tmp;\n        backtrack(res, 1, tmp, n, k);\n        return res;\n    }\n\n    void backtrack(vector\u003cvector\u003cint\u003e\u003e\u0026 res, int index, vector\u003cint\u003e \u0026tmp, int n, int k) {\n        if (tmp.size() == k) {\n            res.push_back(tmp);\n        }\n        for (int i = index; i \u003c= n; i++) {\n            tmp.push_back(i);\n            backtrack(res, i+1, tmp, n, k);\n            tmp.pop_back();\n        }\n    }\n};",
    "id": "278614928",
    "lang": "cpp",
    "memory": "8.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 27,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "77",
     "title": "Combinations",
     "titleSlug": "combinations",
     "translatedTitle": "组合"
    },
    "rawMemory": "8940000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/combinations/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646618321,
    "totalTestCaseCnt": 27
   }
  },
  "cong-wei-dao-tou-da-yin-lian-biao-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\nprivate:\n    void recursion(ListNode*head, vector\u003cint\u003e\u0026 res){\n        if (head==NULL) return;\n\n        recursion(head-\u003enext, res);\n        res.push_back(head-\u003eval);\n    }\npublic:\n    vector\u003cint\u003e reversePrint(ListNode* head) {\n        vector\u003cint\u003e res;\n        recursion(head, res);\n        return res;\n    }\n};",
    "id": "199446487",
    "lang": "cpp",
    "memory": "8.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100282",
     "title": "从尾到头打印链表 LCOF",
     "titleSlug": "cong-wei-dao-tou-da-yin-lian-biao-lcof",
     "translatedTitle": "从尾到头打印链表"
    },
    "rawMemory": "9016000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1627143890,
    "totalTestCaseCnt": 24
   }
  },
  "construct-string-from-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string tree2str(TreeNode* root) {\n        string res;\n        std::function\u003cvoid(TreeNode*)\u003e preorder = [\u0026](TreeNode* node) {\n            if (node == nullptr) return;\n            res += std::to_string(node-\u003eval);\n            if (node-\u003eleft != nullptr || node-\u003eright != nullptr) {\n                res += \"(\";\n                preorder(node-\u003eleft);\n                res += \")\";\n            }\n            if (node-\u003eright != nullptr ) {\n                res += \"(\";\n                preorder(node-\u003eright);\n                res += \")\";\n            }\n        };\n\n        preorder(root);\n        return res;\n    }\n};",
    "id": "263175224",
    "lang": "cpp",
    "memory": "23.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 160,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "606",
     "title": "Construct String from Binary Tree",
     "titleSlug": "construct-string-from-binary-tree",
     "translatedTitle": "根据二叉树创建字符串"
    },
    "rawMemory": "23692000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/construct-string-from-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "递归实现",
     "flagType": "RED"
    },
    "timestamp": 1643354670,
    "totalTestCaseCnt": 160
   }
  },
  "container-with-most-water": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maxArea(vector\u003cint\u003e\u0026 height) {\n        int j = 0, k = height.size() - 1;\n        int max_area = 0;\n        while (j \u003c k) {\n            int min_height = std::min(height[k], height[j]);\n            int area = (k - j) * min_height;\n            max_area = std::max(max_area, area);\n            if (min_height == height[k]) {\n                k--;\n            } else {\n                j++;\n            }\n        }\n        return max_area;\n    }\n};",
    "id": "263020016",
    "lang": "cpp",
    "memory": "57.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "11",
     "title": "Container With Most Water",
     "titleSlug": "container-with-most-water",
     "translatedTitle": "盛最多水的容器"
    },
    "rawMemory": "58992000",
    "runtime": "60 ms",
    "sourceUrl": "/problems/container-with-most-water/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "贪心算法？\n因为下一次使用较小的那个高度来计算面积的话，面积只能是越来越小。\n所以高度最小的那个点，就废弃了。",
     "flagType": "RED"
    },
    "timestamp": 1643299730,
    "totalTestCaseCnt": 60
   }
  },
  "contains-duplicate": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool containsDuplicate(vector\u003cint\u003e\u0026 nums) {\n        unordered_set\u003cint\u003e s;\n\n        for (int i = 0; i \u003c nums.size(); i++) {\n            if (s.find(nums[i]) != s.end()) {\n                return true;\n            }\n            s.insert(nums[i]);\n        }\n        return false;\n    }\n};",
    "id": "10125582",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 18,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "217",
     "title": "Contains Duplicate",
     "titleSlug": "contains-duplicate",
     "translatedTitle": "存在重复元素"
    },
    "rawMemory": "N/A",
    "runtime": "28 ms",
    "sourceUrl": "/problems/contains-duplicate/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543993617,
    "totalTestCaseCnt": 69
   }
  },
  "contains-duplicate-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool containsNearbyDuplicate(vector\u003cint\u003e \u0026nums, int k) {\n        unordered_map\u003cint, int\u003e m;\n\n        for (int i = 0; i \u003c nums.size(); i++) {\n            int c = nums[i];\n            if (m.count(c) \u003e 0) {\n                if (i - m[c] \u003c= k ) return true;\n            }\n            m[c] = i;\n        }\n        return false;\n    }\n};\n",
    "id": "10128008",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 23,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "219",
     "title": "Contains Duplicate II",
     "titleSlug": "contains-duplicate-ii",
     "translatedTitle": "存在重复元素 II"
    },
    "rawMemory": "N/A",
    "runtime": "20 ms",
    "sourceUrl": "/problems/contains-duplicate-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543995404,
    "totalTestCaseCnt": 51
   }
  },
  "continuous-subarray-sum": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool checkSubarraySum(vector\u003cint\u003e\u0026 nums, int k) {\n        unordered_map\u003cint, int\u003e m{{0,-1}};\n        int n = nums.size(), sum = 0;\n        for (int i = 0; i \u003c n; ++i) {\n            sum += nums[i];\n            int t = sum % k;\n            auto it = m.find(t);\n            if (it != m.end()) {\n                if (i - it-\u003esecond \u003e 1) return true;\n            } else{\n                m[t] = i;\n            }\n        }\n        return false;\n    }\n};",
    "id": "268345481",
    "lang": "cpp",
    "memory": "93.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 95,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "523",
     "title": "Continuous Subarray Sum",
     "titleSlug": "continuous-subarray-sum",
     "translatedTitle": "连续的子数组和"
    },
    "rawMemory": "96044000",
    "runtime": "128 ms",
    "sourceUrl": "/problems/continuous-subarray-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "TODO",
     "flagType": "BLUE"
    },
    "timestamp": 1644844782,
    "totalTestCaseCnt": 95
   }
  },
  "convert-binary-number-in-a-linked-list-to-integer": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nint getDecimalValue(struct ListNode* head){\n    int res = 0;\n    while (head) {\n        res = (res \u003c\u003c 1) + head-\u003eval;\n        head = head-\u003enext;\n    }\n    return res;\n}",
    "id": "264826728",
    "lang": "c",
    "memory": "5.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 102,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1411",
     "title": "Convert Binary Number in a Linked List to Integer",
     "titleSlug": "convert-binary-number-in-a-linked-list-to-integer",
     "translatedTitle": "二进制链表转整数"
    },
    "rawMemory": "5792000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/convert-binary-number-in-a-linked-list-to-integer/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这个才对啊。",
     "flagType": "ORANGE"
    },
    "timestamp": 1644004960,
    "totalTestCaseCnt": 102
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        if (head == nullptr) return 0;\n        ListNode *prev = nullptr, *next = nullptr;        \n        while (head) {\n            next = head-\u003enext;\n            head-\u003enext = prev;\n            prev = head;\n            head = next;\n        }\n        int res = 0;\n        for (int i = 0; prev; prev = prev-\u003enext, i++) {\n            res += prev-\u003eval \u003c\u003c i;\n        }\n        return res;\n    }\n};",
    "id": "264826651",
    "lang": "cpp",
    "memory": "8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 102,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1411",
     "title": "Convert Binary Number in a Linked List to Integer",
     "titleSlug": "convert-binary-number-in-a-linked-list-to-integer",
     "translatedTitle": "二进制链表转整数"
    },
    "rawMemory": "8168000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/convert-binary-number-in-a-linked-list-to-integer/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "方法不对啊",
     "flagType": "BLUE"
    },
    "timestamp": 1644004725,
    "totalTestCaseCnt": 102
   }
  },
  "convert-binary-search-tree-to-sorted-doubly-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n        left = NULL;\n        right = NULL;\n    }\n\n    Node(int _val, Node* _left, Node* _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* treeToDoublyList(Node* root) {\n        if (root == nullptr) return nullptr;\n        std::stack\u003cNode*\u003e st;\n        Node dummy;\n        Node* prev = \u0026dummy;\n        while (root || !st.empty()) {\n            while (root) {\n                st.push(root);\n                root = root-\u003eleft;\n            }\n            auto node = st.top(); st.pop();\n            prev-\u003eright = node;\n            node-\u003eleft = prev;\n            prev = node;\n            root = node-\u003eright;\n        }\n        dummy.right-\u003eleft = prev;\n        prev-\u003eright = dummy.right;\n        return dummy.right;\n    }\n};",
    "id": "264673291",
    "lang": "cpp",
    "memory": "7.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 50,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "758",
     "title": "Convert Binary Search Tree to Sorted Doubly Linked List",
     "titleSlug": "convert-binary-search-tree-to-sorted-doubly-linked-list",
     "translatedTitle": "将二叉搜索树转化为排序的双向链表"
    },
    "rawMemory": "7720000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643952510,
    "totalTestCaseCnt": 50
   }
  },
  "convert-bst-to-greater-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* convertBST(TreeNode* root) {\n        if (root == nullptr) return nullptr;\n        root-\u003eval += addTree(root-\u003eright, 0);\n        convertBST(root-\u003eleft);\n        convertBST(root-\u003eright);\n        addLeft(root-\u003eleft, root-\u003eval);\n        return root;\n    }\n\n    void addLeft(TreeNode* root, int val) {\n        if (root == nullptr) return;\n        root-\u003eval += val;\n        addLeft(root-\u003eleft, val);\n        addLeft(root-\u003eright, val);\n    }\n\n    int addTree(TreeNode *root, int rootVal) {\n        if (root == nullptr) return 0;\n        return addTree(root-\u003eleft, 0) + addTree(root-\u003eright, 0) + root-\u003eval + rootVal;\n    }\n\n\n};",
    "id": "268317507",
    "lang": "cpp",
    "memory": "32.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 215,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "538",
     "title": "Convert BST to Greater Tree",
     "titleSlug": "convert-bst-to-greater-tree",
     "translatedTitle": "把二叉搜索树转换为累加树"
    },
    "rawMemory": "33468000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/convert-bst-to-greater-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644841505,
    "totalTestCaseCnt": 215
   }
  },
  "convert-sorted-array-to-binary-search-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector\u003cint\u003e\u0026 nums) {\n        return dfs(nums, 0, nums.size()-1);\n    }\n\n    TreeNode* dfs(vector\u003cint\u003e\u0026 nums, int l, int r) {\n        if (l \u003e r) return nullptr;\n        int m = (l+r)/2;\n        auto node = new TreeNode(nums[m]);\n        node-\u003eright = dfs(nums, m+1, r);\n        node-\u003eleft = dfs(nums, l, m-1);\n        return node;\n    }\n};",
    "id": "264130388",
    "lang": "cpp",
    "memory": "20.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "108",
     "title": "Convert Sorted Array to Binary Search Tree",
     "titleSlug": "convert-sorted-array-to-binary-search-tree",
     "translatedTitle": "将有序数组转换为二叉搜索树"
    },
    "rawMemory": "21356000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/convert-sorted-array-to-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643724039,
    "totalTestCaseCnt": 31
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -\u003e TreeNode:\n        def build(nums:List[int], l:int, r:int) -\u003e TreeNode:\n            if l \u003e r:\n                return None\n            m = (l+r)\u003e\u003e1\n            return TreeNode(nums[m], build(nums, l, m-1), build(nums, m+1, r))\n        \n        return build(nums, 0, len(nums)-1)",
    "id": "264140890",
    "lang": "python3",
    "memory": "16.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "108",
     "title": "Convert Sorted Array to Binary Search Tree",
     "titleSlug": "convert-sorted-array-to-binary-search-tree",
     "translatedTitle": "将有序数组转换为二叉搜索树"
    },
    "rawMemory": "16804000",
    "runtime": "44 ms",
    "sourceUrl": "/problems/convert-sorted-array-to-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "",
     "flagType": "ORANGE"
    },
    "timestamp": 1643727075,
    "totalTestCaseCnt": 31
   }
  },
  "convert-sorted-list-to-binary-search-tree": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* sortedListToBST(struct ListNode* head){\n    if (head == NULL) return NULL;\n    struct ListNode *fast = head, *slow = head;\n    struct ListNode** preSlow = \u0026head;\n    \n    while (fast \u0026\u0026 fast-\u003enext) {\n        fast = fast-\u003enext-\u003enext;\n        preSlow = \u0026(slow-\u003enext);\n        slow = slow-\u003enext;\n    }\n\n    struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    node-\u003eval = slow-\u003eval;\n    *preSlow = NULL;\n    node-\u003eleft = sortedListToBST(head);\n    node-\u003eright = sortedListToBST(slow-\u003enext);\n    return  node;\n}",
    "id": "264369044",
    "lang": "c",
    "memory": "20.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 32,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "109",
     "title": "Convert Sorted List to Binary Search Tree",
     "titleSlug": "convert-sorted-list-to-binary-search-tree",
     "translatedTitle": "有序链表转换二叉搜索树"
    },
    "rawMemory": "20784000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/convert-sorted-list-to-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643820475,
    "totalTestCaseCnt": 32
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortListToBST(head, nullptr);\n    }   \n\n    TreeNode* sortListToBST(ListNode* head, ListNode* tail) {\n        if (head == tail) {\n            return nullptr;\n        }\n        ListNode* mid = head;\n        ListNode* fast = head;\n        while (fast != tail \u0026\u0026 fast-\u003enext != tail) {\n            fast = fast-\u003enext-\u003enext;\n            mid = mid-\u003enext;\n        }\n        TreeNode* node = new TreeNode(mid-\u003eval);\n        node-\u003eleft = sortListToBST(head, mid);\n        node-\u003eright = sortListToBST(mid-\u003enext, tail);\n        return node;\n    }\n};\n\n\n\n\n\n",
    "id": "264364645",
    "lang": "cpp",
    "memory": "27.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 32,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "109",
     "title": "Convert Sorted List to Binary Search Tree",
     "titleSlug": "convert-sorted-list-to-binary-search-tree",
     "translatedTitle": "有序链表转换二叉搜索树"
    },
    "rawMemory": "28236000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/convert-sorted-list-to-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "左闭右开。注意右节点构建时的起始节点。",
     "flagType": "GREEN"
    },
    "timestamp": 1643818283,
    "totalTestCaseCnt": 32
   }
  },
  "copy-list-with-random-pointer": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        unordered_map\u003cNode*, Node*\u003e node_map;\n        for (auto curr = head; curr; curr = curr-\u003enext) {\n            node_map[curr] = new Node(curr-\u003eval);\n        }\n        for (auto curr = head; curr; curr = curr-\u003enext) {\n            auto new_node = node_map[curr];\n            new_node-\u003erandom = node_map[curr-\u003erandom];\n            new_node-\u003enext = node_map[curr-\u003enext];\n        }        \n        return node_map[head];\n    }\n};",
    "id": "265011520",
    "lang": "cpp",
    "memory": "11 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 19,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "138",
     "title": "Copy List with Random Pointer",
     "titleSlug": "copy-list-with-random-pointer",
     "translatedTitle": "复制带随机指针的链表"
    },
    "rawMemory": "11240000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/copy-list-with-random-pointer/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "c++",
     "flagType": "GREEN"
    },
    "timestamp": 1644069653,
    "totalTestCaseCnt": 19
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Next *Node\n *     Random *Node\n * }\n */\n\nfunc copyRandomList(head *Node) *Node {\n    node_map := make(map[*Node]*Node)\n    for curr := head; curr != nil; curr = curr.Next {\n        node_map[curr] = \u0026Node{Val:curr.Val}\n    }\n\n    for curr := head; curr != nil; curr = curr.Next {\n        node := node_map[curr]\n        if curr.Next != nil {\n            node.Next = node_map[curr.Next]\n        }\n        if curr.Random != nil {\n            node.Random = node_map[curr.Random]\n        }\n    }\n    return node_map[head]\n}",
    "id": "265008856",
    "lang": "golang",
    "memory": "3.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 19,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "138",
     "title": "Copy List with Random Pointer",
     "titleSlug": "copy-list-with-random-pointer",
     "translatedTitle": "复制带随机指针的链表"
    },
    "rawMemory": "3444000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/copy-list-with-random-pointer/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644069083,
    "totalTestCaseCnt": 19
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -\u003e 'Optional[Node]':\n        curr = head\n        node_map = dict()\n        while curr:\n            node_map[curr] = Node(curr.val)\n            curr = curr.next\n        curr = head\n        \n        while curr:\n            node = node_map[curr]\n            if curr.next:\n                node.next = node_map[curr.next]\n            if curr.random:\n                node.random = node_map[curr.random]\n            curr = curr.next\n        if head == None:\n            return None\n        return node_map[head]\n",
    "id": "265005855",
    "lang": "python3",
    "memory": "15.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 19,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "138",
     "title": "Copy List with Random Pointer",
     "titleSlug": "copy-list-with-random-pointer",
     "translatedTitle": "复制带随机指针的链表"
    },
    "rawMemory": "16216000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/copy-list-with-random-pointer/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644068408,
    "totalTestCaseCnt": 19
   }
  },
  "count-and-say": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string countAndSay(int n) {\n        string say = \"1\", s = \"\";\n        for (int j = 2 ; j \u003c= n; j++) {\n            for (int i = 1, cnt = 1; i \u003c= say.size(); i++) {\n                if (say[i - 1] != say[i]) {\n                    s.push_back(cnt + '0');\n                    s.push_back(say[i-1]);\n                    cnt = 1;\n                } else {\n                    cnt++;\n                }\n            }\n            say = s;\n            s = \"\";\n        }\n        return say;\n    }\n};",
    "id": "10195377",
    "lang": "cpp",
    "memory": "938 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 18,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "38",
     "title": "Count and Say",
     "titleSlug": "count-and-say",
     "translatedTitle": "外观数列"
    },
    "rawMemory": "937984",
    "runtime": "0 ms",
    "sourceUrl": "/problems/count-and-say/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544109214,
    "totalTestCaseCnt": 30
   }
  },
  "count-binary-substrings": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int countBinarySubstrings(string s) {\n        int pre_cnt = 0, curr_cnt = 1;\n        int res = 0;\n\n        for (int i = 1; i \u003c s.size(); i++) {\n            if (s[i - 1] == s[i]) {\n                curr_cnt++;\n            } else {\n                pre_cnt = curr_cnt;\n                curr_cnt = 1;\n            }\n            if (pre_cnt \u003e= curr_cnt) {\n                res++;\n            }\n        }\n\n        return res;\n    }\n};",
    "id": "264376388",
    "lang": "cpp",
    "memory": "10.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 91,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "696",
     "title": "Count Binary Substrings",
     "titleSlug": "count-binary-substrings",
     "translatedTitle": "计数二进制子串"
    },
    "rawMemory": "10508000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/count-binary-substrings/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643828852,
    "totalTestCaseCnt": 91
   }
  },
  "count-elements-with-strictly-smaller-and-greater-elements": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int countElements(vector\u003cint\u003e\u0026 nums) {\n        if (nums.size() \u003c 3) {\n            return 0;\n        }\n\n        std::sort(nums.begin(), nums.end());\n        // the range is  [i, j)\n        int i = 0, j = nums.size();\n\n        while (i+2 \u003c j \u0026\u0026 nums[i] == nums[i+1]) i++;\n        while (j \u003e i+2 \u0026\u0026 nums[j-1] == nums[j-2]) j--;\n        \n        return j - i - 2;\n    }\n};",
    "id": "261962995",
    "lang": "cpp",
    "memory": "8.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 127,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "2269",
     "title": "Count Elements With Strictly Smaller and Greater Elements ",
     "titleSlug": "count-elements-with-strictly-smaller-and-greater-elements",
     "translatedTitle": "元素计数"
    },
    "rawMemory": "9156000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/count-elements-with-strictly-smaller-and-greater-elements/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643025757,
    "totalTestCaseCnt": 127
   }
  },
  "count-primes": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int countPrimes(int n) {\n        vector\u003cint\u003e isPrimeVec(n, 1);\n        int count = 0;\n        for (int i = 2; i \u003c n; i++) {\n            if (isPrimeVec[i]) {\n                count++;\n                for (int j = 2 * i; j \u003c n; j += i) {\n                    isPrimeVec[j] = 0;\n                }\n            }\n        }\n        return count;\n    }\n};",
    "id": "265551773",
    "lang": "cpp",
    "memory": "127.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 66,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "204",
     "title": "Count Primes",
     "titleSlug": "count-primes",
     "translatedTitle": "计数质数"
    },
    "rawMemory": "130528000",
    "runtime": "364 ms",
    "sourceUrl": "/problems/count-primes/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "埃氏筛",
     "flagType": "BLUE"
    },
    "timestamp": 1644227443,
    "totalTestCaseCnt": 66
   }
  },
  "counting-bits": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e countBits(int n) {\n        vector\u003cint\u003e bits(n + 1);\n        for (int i = 1; i \u003c= n; i++) {\n            bits[i] = bits[i \u0026 (i - 1)] + 1;\n        }\n        return bits;\n    }\n};",
    "id": "196887389",
    "lang": "cpp",
    "memory": "7.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 15,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "338",
     "title": "Counting Bits",
     "titleSlug": "counting-bits",
     "translatedTitle": "比特位计数"
    },
    "rawMemory": "7864000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/counting-bits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626536637,
    "totalTestCaseCnt": 15
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func countBits(n int) []int {\n    res := []int{}\n    for i := 0; i \u003c n+1 ; i++ {\n        res = append(res, bitCount(i))\n    }\n    return res\n}\n\nfunc bitCount(n int) int {\n    cnt := 0\n    for n \u003e 0 {\n        n \u0026= (n - 1)\n        cnt++\n    }\n    return cnt\n}",
    "id": "196883566",
    "lang": "golang",
    "memory": "6.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 15,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "338",
     "title": "Counting Bits",
     "titleSlug": "counting-bits",
     "translatedTitle": "比特位计数"
    },
    "rawMemory": "6508000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/counting-bits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626535702,
    "totalTestCaseCnt": 15
   }
  },
  "daily-temperatures": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint *dailyTemperatures(int *T, int TSize, int *returnSize)\n{\n    int monoStack[TSize];\n    memset(monoStack, 0, sizeof(int) * TSize);\n    int stackTop = -1;\n    int tIter = 0;\n\n    int *res = (int *)malloc(sizeof(int) * TSize);\n    memset(res, 0, sizeof(int) * TSize);\n\n    while (tIter \u003c TSize) {\n        /* monoStack[stackTop]是栈顶元素在T中的下标，T[monoStack[stackTop]] 才是真正的栈顶温度 */\n        while (stackTop != -1 \u0026\u0026 T[monoStack[stackTop]] \u003c T[tIter]) {\n            int r = monoStack[stackTop];\n            stackTop--;\n            \n            res[r] = tIter - r;\n        }\n        monoStack[++stackTop] = tIter++;        \n    }\n    *returnSize = TSize;\n    return res;\n}\n",
    "id": "232688537",
    "lang": "c",
    "memory": "51.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "739",
     "title": "Daily Temperatures",
     "titleSlug": "daily-temperatures",
     "translatedTitle": "每日温度"
    },
    "rawMemory": "53044000",
    "runtime": "440 ms",
    "sourceUrl": "/problems/daily-temperatures/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635263931,
    "totalTestCaseCnt": 47
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e dailyTemperatures(vector\u003cint\u003e\u0026 temperatures) {\n        // 单调栈，保存位置\n        int len = temperatures.size();\n        vector\u003cint\u003e res(len, 0);\n        vector\u003cint\u003e st(len, 0);\n\n        int stLen = 0;\n\n        for (int i = 0; i \u003c len; i++) {\n            while (stLen \u003e 0 \u0026\u0026 temperatures[i] \u003e temperatures[st[stLen-1]]) {\n                res[st[stLen-1]] = i - st[stLen-1];\n                stLen--;\n            }\n            st[stLen++] = i;\n        }\n\n        return res;\n    }\n};",
    "id": "233532421",
    "lang": "cpp",
    "memory": "86.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "739",
     "title": "Daily Temperatures",
     "titleSlug": "daily-temperatures",
     "translatedTitle": "每日温度"
    },
    "rawMemory": "88116000",
    "runtime": "100 ms",
    "sourceUrl": "/problems/daily-temperatures/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635497503,
    "totalTestCaseCnt": 47
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func dailyTemperatures(temperatures []int) []int {\n    res := make([]int, len(temperatures))\n    stack := []int{}\n\n    for i, t := range temperatures {\n        for len(stack) \u003e 0 {\n            top := stack[len(stack)-1]\n            if t \u003e temperatures[top] {\n                res[top] = i - top\n                stack = stack[:len(stack)-1]\n            } else {\n                break;\n            }\n        }\n        stack = append(stack, i)\n    }\n\n    for _, leftIndex := range stack {\n        res[leftIndex] = 0\n    }\n\n    return res\n}",
    "id": "262143211",
    "lang": "golang",
    "memory": "9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "739",
     "title": "Daily Temperatures",
     "titleSlug": "daily-temperatures",
     "translatedTitle": "每日温度"
    },
    "rawMemory": "9172000",
    "runtime": "108 ms",
    "sourceUrl": "/problems/daily-temperatures/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "单调栈",
     "flagType": "RED"
    },
    "timestamp": 1643083051,
    "totalTestCaseCnt": 47
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int[] res = new int[T.length];\n        for (int i = 0; i \u003c T.length; i++) {\n            for (int j =  i + 1; j \u003c T.length; j++) {\n                if (T[j] \u003e T[i]) {\n                    res[i] = j - i;\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}",
    "id": "232689010",
    "lang": "java",
    "memory": "48.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "739",
     "title": "Daily Temperatures",
     "titleSlug": "daily-temperatures",
     "translatedTitle": "每日温度"
    },
    "rawMemory": "49736000",
    "runtime": "1187 ms",
    "sourceUrl": "/problems/daily-temperatures/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635264057,
    "totalTestCaseCnt": 47
   }
  },
  "decode-string": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int end;\n        return dfs(s, 0, end);\n    }\n\nprivate:\n    //s = \"3[a]2[bc]\", 返回 \"aaabcbc\".\n    //s = \"3[a2[c]]\", 返回 \"accaccacc\".\n    //s = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\".\n    //\\U0001f44c？,\n    //\\U0001f431啊\n    string dfs(string s, int start, int\u0026 end) {\n        string res = \"\";\n        for (int i = start, b = 0; i \u003c s.size();) {\n            if (isdigit(s[i])) {\n                int e, n;\n                for (b = i; isdigit(s[i]); i++);\n                n = stoi(s.substr(b, i - b));\n                string sub = dfs(s, i, e);\n                //cout \u003c\u003c \"sub = \" \u003c\u003c sub \u003c\u003c endl;\n                while (n--) res += sub;\n                i = e;\n            } else if (isalpha(s[i])) {\n                res += s[i++];\n            } else if (s[i] == ']') {\n                i++;\n                end = i;\n                return res;\n            } else {\n                i++;\n            }\n        }\n        return res;\n    }\n   \n};",
    "id": "10550629",
    "lang": "cpp",
    "memory": "958.5 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 29,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "394",
     "title": "Decode String",
     "titleSlug": "decode-string",
     "translatedTitle": "字符串解码"
    },
    "rawMemory": "958464",
    "runtime": "0 ms",
    "sourceUrl": "/problems/decode-string/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545030728,
    "totalTestCaseCnt": 34
   }
  },
  "decompress-run-length-encoded-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e decompressRLElist(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cint\u003e res;\n        for (int i = 0; i \u003c nums.size(); i += 2) {\n            int freq = nums[i];\n            for (int j = 0; j \u003c freq; j++) {\n                res.push_back(nums[i+1]);\n            }\n        }\n        return res;\n    }\n};",
    "id": "263275277",
    "lang": "cpp",
    "memory": "9.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 53,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1241",
     "title": "Decompress Run-Length Encoded List",
     "titleSlug": "decompress-run-length-encoded-list",
     "translatedTitle": "解压缩编码列表"
    },
    "rawMemory": "9960000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/decompress-run-length-encoded-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643373603,
    "totalTestCaseCnt": 53
   }
  },
  "delete-node-in-a-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node-\u003eval = node-\u003enext-\u003eval;\n        node-\u003enext = node-\u003enext-\u003enext;\n    }\n};",
    "id": "193005226",
    "lang": "cpp",
    "memory": "7.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 41,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "237",
     "title": "Delete Node in a Linked List",
     "titleSlug": "delete-node-in-a-linked-list",
     "translatedTitle": "删除链表中的节点"
    },
    "rawMemory": "7772000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/delete-node-in-a-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "",
     "flagType": "RED"
    },
    "timestamp": 1625581681,
    "totalTestCaseCnt": 41
   }
  },
  "delete-operation-for-two-strings": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        // dp[i][j]\n        vector\u003cvector\u003cint\u003e\u003e dp(word1.size()+1, vector\u003cint\u003e(word2.size()+1));\n        for (int i = 0; i \u003c= word1.size(); i++) dp[i][0] = i;\n        for (int i = 0; i \u003c= word2.size(); i++) dp[0][i] = i;\n\n        for (int i = 1; i \u003c= word1.size(); i++) {\n            for (int j = 1; j \u003c= word2.size(); j++) {\n                if (word1[i-1] == word2[j-1]) {\n                    dp[i][j] = dp[i-1][j-1];\n                } else {\n                    int del1 = 1 + dp[i-1][j];\n                    int del2 = 1 + dp[i][j-1];\n                    dp[i][j] = std::min(del1, del2);\n                }\n            }\n        }\n        return dp[word1.size()][word2.size()];\n    }\n};",
    "id": "261738392",
    "lang": "cpp",
    "memory": "11.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1306,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "583",
     "title": "Delete Operation for Two Strings",
     "titleSlug": "delete-operation-for-two-strings",
     "translatedTitle": "两个字符串的删除操作"
    },
    "rawMemory": "12220000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/delete-operation-for-two-strings/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "DP",
     "flagType": "RED"
    },
    "timestamp": 1642962998,
    "totalTestCaseCnt": 1306
   }
  },
  "delete-the-middle-node-of-a-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteMiddle(ListNode* head) {\n        if (head == nullptr || head-\u003enext == nullptr) {\n            return nullptr;\n        }\n        ListNode *fast = head-\u003enext, *slow = head;\n        while (fast-\u003enext \u0026\u0026 fast-\u003enext-\u003enext) {\n            fast = fast-\u003enext-\u003enext;\n            slow = slow-\u003enext;\n        }\n        slow-\u003enext = slow-\u003enext-\u003enext;\n\n        return head;\n    }\n};",
    "id": "264587707",
    "lang": "cpp",
    "memory": "287.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "2216",
     "title": "Delete the Middle Node of a Linked List",
     "titleSlug": "delete-the-middle-node-of-a-linked-list",
     "translatedTitle": "删除链表的中间节点"
    },
    "rawMemory": "294728000",
    "runtime": "784 ms",
    "sourceUrl": "/problems/delete-the-middle-node-of-a-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "牛逼。",
     "flagType": "RED"
    },
    "timestamp": 1643905986,
    "totalTestCaseCnt": 70
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\n\nclass Solution {\n    public ListNode deleteMiddle(ListNode head) {\n        //快慢指针\n        ListNode slow = head,fast = head.next;\n        if(fast == null) return null;\n        while(fast.next != null \u0026\u0026 fast.next.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}",
    "id": "264587482",
    "lang": "java",
    "memory": "62.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "2216",
     "title": "Delete the Middle Node of a Linked List",
     "titleSlug": "delete-the-middle-node-of-a-linked-list",
     "translatedTitle": "删除链表的中间节点"
    },
    "rawMemory": "63572000",
    "runtime": "3 ms",
    "sourceUrl": "/problems/delete-the-middle-node-of-a-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643905896,
    "totalTestCaseCnt": 70
   }
  },
  "design-add-and-search-words-data-structure": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class WordDictionary {\nprivate:\n    struct Node {\n        int ref;\n        std::map\u003cchar, Node*\u003e next;\n\n        Node* FindChild(char c) {\n            auto it = next.find(c);\n            if (it == next.end()) {\n                return nullptr;\n            }\n            return it-\u003esecond; \n        }\n\n        void SetChild(char c, Node* node) {\n            next[c] = node;\n        }\n\n        Node(): ref(0) {};\n    };\n\npublic:\n    WordDictionary() {\n\n    }\n    \n    void addWord(string word) {\n        Node* node = \u0026root;\n        for (auto c : word) {\n            auto curr = node-\u003eFindChild(c);\n            if (curr == nullptr) {\n                curr = new Node();\n                node-\u003eSetChild(c, curr);\n            }\n            node = curr;\n        }\n        node-\u003eref++;\n    }\n    \n    bool search(string word) {\n        return search_(\u0026root, word);\n    }\n\n    bool search_(Node* node, string word) {\n        if (node == nullptr)\n            return false;\n\n        if (word.empty())\n            return node-\u003eref \u003e 0;\n        \n        for (int i = 0; i \u003c word.size(); i++) {\n            if (word[i] == '.') {\n                // how to iterator\n                for (auto it = node-\u003enext.begin(); it != node-\u003enext.end(); it++) {\n                    if (search_(it-\u003esecond, word.substr(i+1))) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                return search_(node-\u003eFindChild(word[i]), word.substr(i+1));\n            }\n\n        }\n        return false;\n    }\n\nprivate:\n    Node root;\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj-\u003eaddWord(word);\n * bool param_2 = obj-\u003esearch(word);\n */",
    "id": "261091326",
    "lang": "cpp",
    "memory": "68.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 13,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "211",
     "title": "Design Add and Search Words Data Structure",
     "titleSlug": "design-add-and-search-words-data-structure",
     "translatedTitle": "添加与搜索单词 - 数据结构设计"
    },
    "rawMemory": "70196000",
    "runtime": "132 ms",
    "sourceUrl": "/problems/design-add-and-search-words-data-structure/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642801852,
    "totalTestCaseCnt": 29
   }
  },
  "design-bounded-blocking-queue": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class BoundedBlockingQueue {\npublic:\n    BoundedBlockingQueue(int capacity) {\n        cap_ = capacity;\n    }\n    \n    void enqueue(int element) {\n        std::unique_lock\u003cstd::mutex\u003e lock(mutex_);\n        \n        cv_.wait(lock, [this](){ return queue_.size() \u003c cap_; });\n        queue_.push(element);\n        lock.unlock();\n\n        cv_.notify_all();\n    }\n    \n    int dequeue() {\n        std::unique_lock\u003cstd::mutex\u003e lock(mutex_);\n        cv_.wait(lock, [this](){ return !queue_.empty(); });\n\n        auto head = queue_.front();\n        queue_.pop();\n        lock.unlock();\n\n        cv_.notify_all();\n        return head;\n    }\n    \n    int size() {\n        std::unique_lock\u003cstd::mutex\u003e lock(mutex_);\n        auto size = queue_.size();\n        lock.unlock();\n        return size;\n    }\nprivate:\n    int cap_;\n    std::queue\u003cint\u003e queue_;\n    std::mutex mutex_;\n    std::condition_variable cv_;\n};",
    "id": "266649457",
    "lang": "cpp",
    "memory": "8.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 18,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1209",
     "title": "Design Bounded Blocking Queue",
     "titleSlug": "design-bounded-blocking-queue",
     "translatedTitle": "设计有限阻塞队列"
    },
    "rawMemory": "8804000",
    "runtime": "132 ms",
    "sourceUrl": "/problems/design-bounded-blocking-queue/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644478946,
    "totalTestCaseCnt": 18
   }
  },
  "design-circular-queue": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class MyCircularQueue {\npublic:\n    MyCircularQueue(int k) {\n        cap_ = k;\n        read_index_ = 0;\n        write_index_ = 0;\n        data_.resize(cap_);\n    }\n    \n    bool enQueue(int value) {\n        if (isFull()) return false;\n        int index = write_index_++ % cap_;\n        data_[index] = value;\n        return true;\n    }\n    \n    bool deQueue() {\n        if (isEmpty()) return false;\n        read_index_++;\n        return true;\n    }\n    \n    int Front() {\n        if (isEmpty()) return -1;\n        int index = read_index_ % cap_;\n        return data_[index];\n    }\n    \n    int Rear() {\n        if (isEmpty()) return -1;\n        int index = (write_index_ - 1) % cap_;\n        return data_[index];\n    }\n    \n    bool isEmpty() {\n        return read_index_ == write_index_;\n    }\n    \n    bool isFull() {\n        return write_index_ - read_index_ == cap_;\n    }\nprivate:\n    int cap_;\n    int read_index_;\n    int write_index_;\n    vector\u003cint\u003e data_;\n};\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * MyCircularQueue* obj = new MyCircularQueue(k);\n * bool param_1 = obj-\u003eenQueue(value);\n * bool param_2 = obj-\u003edeQueue();\n * int param_3 = obj-\u003eFront();\n * int param_4 = obj-\u003eRear();\n * bool param_5 = obj-\u003eisEmpty();\n * bool param_6 = obj-\u003eisFull();\n */",
    "id": "261297866",
    "lang": "cpp",
    "memory": "16.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 58,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "860",
     "title": "Design Circular Queue",
     "titleSlug": "design-circular-queue",
     "translatedTitle": "设计循环队列"
    },
    "rawMemory": "16892000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/design-circular-queue/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "",
     "flagType": "RED"
    },
    "timestamp": 1642854287,
    "totalTestCaseCnt": 58
   }
  },
  "design-compressed-string-iterator": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class StringIterator {\npublic:\n    StringIterator(string compressedString) {\n        str_ = list\u003cint\u003e(compressedString.begin(), compressedString.end());\n        last_ = 0;\n        last_cnt_ = 0;\n    }\n    \n    char next() {\n        if (!hasNext()) {\n            return 0x20;\n        }\n\n        if (last_cnt_) {\n            --last_cnt_;\n            return last_;\n        }\n\n        if (!isdigit(str_.front())) {\n            last_ = str_.front();\n            str_.erase(str_.begin());\n            return last_;\n        }\n\n        auto it = str_.begin();\n        for (; it != str_.end() \u0026\u0026 isdigit(*it); it++) {\n            last_cnt_ = last_cnt_ *10 + (*it - '0');\n        }\n        --last_cnt_;\n        str_.erase(str_.begin(), it);\n        if (last_cnt_ == 0) {\n            return next();\n        } else {\n            --last_cnt_;\n        }\n\n        return last_;\n    }\n    \n    bool hasNext() {\n       return str_.size() != 0 || last_cnt_ \u003e 0;\n    }\nprivate:\n    char last_;\n    char last_cnt_;\n    std::list\u003cint\u003e str_;\n};\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator* obj = new StringIterator(compressedString);\n * char param_1 = obj-\u003enext();\n * bool param_2 = obj-\u003ehasNext();\n */",
    "id": "269275105",
    "lang": "cpp",
    "memory": "14.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 165,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "604",
     "title": "Design Compressed String Iterator",
     "titleSlug": "design-compressed-string-iterator",
     "translatedTitle": "迭代压缩字符串"
    },
    "rawMemory": "14572000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/design-compressed-string-iterator/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1645033544,
    "totalTestCaseCnt": 165
   }
  },
  "design-hashmap": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class MyHashMap {\npublic:\n    struct Node {\n        int key;\n        int value;\n        Node* next;\n        \n        Node(int k, int v) : key(k), value(v), next(nullptr) {}\n    };\n\nprivate:\n    const size_t kCap = 5120;\n    int hash(int key) {\n        return (key) % kCap;\n    }\n\npublic:\n    MyHashMap() : v_(kCap, nullptr) {\n    }\n        \n    void put(int key, int value) {\n        Node** node = \u0026v_[hash(key)];\n        if (*node == nullptr) {\n            *node = new Node(key, value);\n            return;\n        }\n\n        Node* curr = *node;\n        while (curr) {\n            if (curr-\u003ekey == key) {\n                curr-\u003evalue = value;\n                return;\n            }\n            curr = curr-\u003enext;\n        }\n        // 插入到头节点, curr 是当前的头指针。容易写错\n        curr = (*node);\n        *node = new Node(key, value);\n        (*node)-\u003enext = curr;\n    }\n    \n    int get(int key) {\n        Node* node = v_[hash(key)];\n        while (node) {\n            if (node-\u003ekey == key) \n                return node-\u003evalue;\n            node = node-\u003enext;\n        }\n        return -1;\n    }\n    \n    void remove(int key) {\n        Node** node = \u0026v_[hash(key)];\n        while (*node) {\n            if ((*node)-\u003ekey == key) {\n                // 删除注意，这块容易写错\n                Node* next = (*node)-\u003enext;\n                delete (*node);\n                *node = next;\n                return;\n            }\n            node = \u0026((*node)-\u003enext);\n        }\n    }\n\nprivate:\n    std::vector\u003cNode*\u003e v_;\n};\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj-\u003eput(key,value);\n * int param_2 = obj-\u003eget(key);\n * obj-\u003eremove(key);\n */",
    "id": "261286907",
    "lang": "cpp",
    "memory": "51.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "817",
     "title": "Design HashMap",
     "titleSlug": "design-hashmap",
     "translatedTitle": "设计哈希映射"
    },
    "rawMemory": "52988000",
    "runtime": "100 ms",
    "sourceUrl": "/problems/design-hashmap/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "代码比较简化了",
     "flagType": "RED"
    },
    "timestamp": 1642851964,
    "totalTestCaseCnt": 36
   }
  },
  "design-hashset": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class MyHashSet {\npublic:\n    const size_t Kcap = 4096;\n\n    int hash(int key) {\n        return key % Kcap;\n    }\n\npublic:\n    MyHashSet() {\n        v_.resize(Kcap);\n    }\n    \n    void add(int key) {\n        int index = hash(key);\n        auto\u0026 list = v_[index];\n        for (auto it = list.begin(); it != list.end(); it++) {\n            if (*it == key) {\n                return;\n            }\n        }\n        list.push_front(key);\n    }\n    \n    void remove(int key) {\n        int index = hash(key);\n        auto\u0026 list = v_[index];\n        for (auto it = list.begin(); it != list.end(); it++) {\n            if (*it == key) {\n                list.erase(it);\n                break;\n            }\n        }\n        // 可以用 erase 删除 iterator\n        //list.remove(key);\n    }\n    \n    bool contains(int key) {\n        int index = hash(key);\n        auto\u0026 list = v_[index];\n        for (auto it = list.begin(); it != list.end(); it++) {\n            if (*it == key) {\n                return true;\n            }\n        }\n        return false;\n    }\nprivate:\n    std::vector\u003cstd::list\u003cint\u003e\u003e v_;\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj = new MyHashSet();\n * obj-\u003eadd(key);\n * obj-\u003eremove(key);\n * bool param_3 = obj-\u003econtains(key);\n */",
    "id": "261257928",
    "lang": "cpp",
    "memory": "43.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 32,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "816",
     "title": "Design HashSet",
     "titleSlug": "design-hashset",
     "translatedTitle": "设计哈希集合"
    },
    "rawMemory": "44688000",
    "runtime": "88 ms",
    "sourceUrl": "/problems/design-hashset/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "",
     "flagType": "PURPLE"
    },
    "timestamp": 1642845224,
    "totalTestCaseCnt": 32
   }
  },
  "design-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class MyLinkedList {\npublic:\n    MyLinkedList() {\n        root_ = new ListNode(-999);\n        root_-\u003eprev = root_;\n        root_-\u003enext = root_;\n    }\n    \n    int get(int index) {\n        if (index \u003c 0) return -1;\n        ListNode* tmp = root_-\u003enext;\n        for (int i = 0; tmp != root_ ; i++) {\n            if (i == index) return tmp-\u003eval;\n            tmp = tmp-\u003enext;\n        }\n        return -1;\n    }\n    \n    void addAtHead(int val) {\n        ListNode* node = new ListNode(val, root_, root_-\u003enext);\n        root_-\u003enext-\u003eprev = node;\n        root_-\u003enext = node; \n    }\n    \n    void addAtTail(int val) {\n        ListNode* node = new ListNode(val, root_-\u003eprev, root_);\n        root_-\u003eprev-\u003enext = node;\n        root_-\u003eprev = node;\n    }\n    \n    void addAtIndex(int index, int val) {\n        if (index \u003c= 0) {\n            return addAtHead(val);\n        } else if (index \u003e 0 \u0026\u0026 isEmpty()) {\n            return;\n        }\n        ListNode* tmp = root_-\u003enext;\n        for (int i = 0; i \u003c= index; i++, tmp = tmp-\u003enext) {\n            if (tmp == root_ \u0026\u0026 i \u003c index) {\n                break;\n            }\n            if (i == index) {\n                ListNode* node = new ListNode(val, tmp-\u003eprev, tmp);\n                tmp-\u003eprev-\u003enext = node;\n                tmp-\u003eprev = node;\n                break;\n            }\n        }\n    }\n    \n    void deleteAtIndex(int index) {\n        ListNode* tmp = root_-\u003enext;\n        for (int i = 0; tmp != root_ \u0026\u0026 i \u003c= index; tmp = tmp-\u003enext, i++) {\n            if (i == index) {\n                tmp-\u003eprev-\u003enext = tmp-\u003enext;\n                tmp-\u003enext-\u003eprev = tmp-\u003eprev;\n                delete tmp;\n                break;\n            }\n        }\n    }\n    bool isEmpty() {\n        return root_-\u003enext == root_;\n    }\npublic:\n    template\u003ctypename T\u003e\n    struct Node {\n        Node\u003cT\u003e* prev;\n        Node\u003cT\u003e* next;\n        T val;\n\n        Node(T v) : val(v) {};\n        Node(T v, Node\u003cT\u003e* p, Node\u003cT\u003e* n) : prev(p), next(n), val(v) {};\n    };\n    using ListNode = Node\u003cint\u003e;\nprivate:\n    ListNode* root_;\n};\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList* obj = new MyLinkedList();\n * int param_1 = obj-\u003eget(index);\n * obj-\u003eaddAtHead(val);\n * obj-\u003eaddAtTail(val);\n * obj-\u003eaddAtIndex(index,val);\n * obj-\u003edeleteAtIndex(index);\n */",
    "id": "264665180",
    "lang": "cpp",
    "memory": "19.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 64,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "838",
     "title": "Design Linked List",
     "titleSlug": "design-linked-list",
     "translatedTitle": "设计链表"
    },
    "rawMemory": "19936000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/design-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "并不好。",
     "flagType": "GREEN"
    },
    "timestamp": 1643949947,
    "totalTestCaseCnt": 64
   }
  },
  "design-skiplist": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "#define kMaxLevel 16\n#define N 999\n\nstruct Node {\n  int key;\n  vector\u003cNode*\u003e next;\n\n  Node* Next(int level) {\n      return next[level];\n  }\n\n  void SetNext(int level, Node* node) {\n      next[level] = node;\n  }\n\n  int NextSize() {\n      return next.size();\n  }\n\n  Node(int val, int maxlevel) : key(val), next(maxlevel, nullptr) {};\n};\n\nclass Skiplist {\n private:\n  int max_height_;\n  Node* head_;\n\n public:\n  Skiplist() : max_height_(1) {\n    head_ = new Node(0, kMaxLevel);\n    srand(0);\n  }\n\n  Node* findGreaterOrEqual(const int key, Node* prev[] = nullptr) {  // for insert\n    Node* ptr = head_;\n    int level = max_height_ - 1;\n    while (true) {\n      Node* next = ptr-\u003eNext(level);\n      if (next != nullptr \u0026\u0026 next-\u003ekey \u003c key) {\n        // same level\n        ptr = next; \n      } else {\n        if (prev != nullptr) prev[level] = ptr;\n        if (level == 0) {\n          return next;\n        } else {\n          level--;\n        }\n      }\n    }\n  }\n\n  int getRandLevel(float factor = 0.5) {\n    int level = 1;\n    while ((rand() % N) / N \u003e factor \u0026\u0026 level \u003c kMaxLevel) {\n      level++;\n    }\n    return level;\n  }\n\n  bool search(int target) {\n    Node* temp = findGreaterOrEqual(target);\n    if (temp \u0026\u0026 temp-\u003ekey == target) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  void add(int num) {\n    Node* prev[kMaxLevel];\n    findGreaterOrEqual(num, prev);\n    int randlevel = getRandLevel();\n    if (randlevel \u003e max_height_) {\n      for (int i = max_height_ - 1; i \u003c randlevel; i++) {\n        prev[i] = head_;\n      }\n      max_height_ = randlevel;\n    }\n    Node* newNode = new Node(num, randlevel);\n    for (int i = 0; i \u003c max_height_; i++) {\n      newNode-\u003eSetNext(i, prev[i]-\u003eNext(i));\n      prev[i]-\u003eSetNext(i, newNode);\n    }\n  }\n\n  bool erase(int num) {\n    Node* prev[kMaxLevel];\n    Node* temp = findGreaterOrEqual(num, prev);\n    if (temp == nullptr || temp-\u003ekey != num) {\n      return false;\n    }\n\n    for (int i = 0; i \u003c temp-\u003eNextSize(); i++) {\n      prev[i]-\u003eSetNext(i, temp-\u003eNext(i));\n    }\n    delete temp;\n    while (max_height_ \u003e 1 \u0026\u0026 head_-\u003eNext(max_height_ - 1) == nullptr) {\n        max_height_--; \n    }\n    return true;\n  }\n};\n",
    "id": "282815317",
    "lang": "cpp",
    "memory": "29 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 20,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1337",
     "title": "Design Skiplist",
     "titleSlug": "design-skiplist",
     "translatedTitle": "设计跳表"
    },
    "rawMemory": "29712000",
    "runtime": "1252 ms",
    "sourceUrl": "/problems/design-skiplist/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "leveldb",
     "flagType": "BLUE"
    },
    "timestamp": 1647230602,
    "totalTestCaseCnt": 20
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Skiplist {\n        /**\n         * 最大层数\n         */\n        private static int DEFAULT_MAX_LEVEL = 32;\n        /**\n         * 随机层数概率，也就是随机出的层数，在 第1层以上(不包括第一层)的概率，层数不超过maxLevel，层数的起始号为1\n         */\n        private static double DEFAULT_P_FACTOR = 0.25;\n\n        Node head = new Node(null,DEFAULT_MAX_LEVEL); //头节点\n\n        int currentLevel = 1; //表示当前nodes的实际层数，它从1开始\n\n\n        public Skiplist() {\n        }\n\n        public boolean search(int target) {\n            Node searchNode = head;\n            for (int i = currentLevel-1; i \u003e=0; i--) {\n                searchNode = findClosest(searchNode, i, target);\n                if (searchNode.next[i]!=null \u0026\u0026 searchNode.next[i].value == target){\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         *\n         * @param num\n         */\n        public void add(int num) {\n            int level = randomLevel();\n            Node updateNode = head;\n            Node newNode = new Node(num,level);\n            // 计算出当前num 索引的实际层数，从该层开始添加索引\n            for (int i = currentLevel-1; i\u003e=0; i--) {\n                //找到本层最近离num最近的list\n                updateNode = findClosest(updateNode,i,num);\n                if (i\u003clevel){\n                    if (updateNode.next[i]==null){\n                        updateNode.next[i] = newNode;\n                    }else{\n                        Node temp = updateNode.next[i];\n                        updateNode.next[i] = newNode;\n                        newNode.next[i] = temp;\n                    }\n                }\n            }\n            if (level \u003e currentLevel){ //如果随机出来的层数比当前的层数还大，那么超过currentLevel的head 直接指向newNode\n                for (int i = currentLevel; i \u003c level; i++) {\n                    head.next[i] = newNode;\n                }\n                currentLevel = level;\n            }\n\n        }\n\n        public boolean erase(int num) {\n            boolean flag = false;\n            Node searchNode = head;\n            for (int i = currentLevel-1; i \u003e=0; i--) {\n                searchNode = findClosest(searchNode, i, num);\n                if (searchNode.next[i]!=null \u0026\u0026 searchNode.next[i].value == num){\n                    //找到该层中该节点\n                    searchNode.next[i] = searchNode.next[i].next[i];\n                    flag = true;\n                    continue;\n                }\n            }\n            return flag;\n        }\n\n        /**\n         * 找到level层 value 大于node 的节点\n         * @param node\n         * @param levelIndex\n         * @param value\n         * @return\n         */\n        private Node findClosest(Node node,int levelIndex,int value){\n            while ((node.next[levelIndex])!=null \u0026\u0026 value \u003enode.next[levelIndex].value){\n                node = node.next[levelIndex];\n            }\n            return node;\n        }\n\n\n        /**\n         * 随机一个层数\n         */\n        private static int randomLevel(){\n            int level = 1;\n            while (Math.random()\u003cDEFAULT_P_FACTOR \u0026\u0026 level\u003cDEFAULT_MAX_LEVEL){\n                level ++ ;\n            }\n            return level;\n        }\n\n\n        class Node{\n            Integer value;\n            Node[] next;\n\n            public Node(Integer value,int size) {\n                this.value = value;\n                this.next = new Node[size];\n            }\n\n            @Override\n            public String toString() {\n                return String.valueOf(value);\n            }\n        }\n\n    }\n\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * Skiplist obj = new Skiplist();\n * boolean param_1 = obj.search(target);\n * obj.add(num);\n * boolean param_3 = obj.erase(num);\n */",
    "id": "260830356",
    "lang": "java",
    "memory": "44.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 20,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1337",
     "title": "Design Skiplist",
     "titleSlug": "design-skiplist",
     "translatedTitle": "设计跳表"
    },
    "rawMemory": "45652000",
    "runtime": "17 ms",
    "sourceUrl": "/problems/design-skiplist/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642736955,
    "totalTestCaseCnt": 20
   }
  },
  "design-twitter": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Twitter {\npublic:\n    struct Tweet {\n        int time;\n        int tweet_id;\n        Tweet() : time(0), tweet_id(-1) {}\n        Tweet(int tw, int t) : tweet_id(tw), time(t) {}\n    };\n\n    class User {\n    public:\n        User(int id) : id_(id) {}\n\n        bool Follow(int user_id) {\n            if (user_id != id_) {\n                if (follows_.count(user_id)) {\n                    return true;\n                }\n                follows_.insert(user_id);\n                return true;\n            }\n            return false;\n        }\n\n        void UnFollow(int user_id) {\n            follows_.erase(user_id);\n        }\n\n        void Tweet(int tweetId, int time) {\n            Twitter::Tweet *twee = new Twitter::Tweet(tweetId, time);\n            tweets_.push_front(twee);\n        }\n\n        std::set\u003cint\u003e\u0026 Followees() {\n            return follows_;\n        }\n\n        std::list\u003cTwitter::Tweet*\u003e\u0026 Tweets() {\n            return tweets_;\n        }\n\n    private:\n        int id_;\n        std::set\u003cint\u003e follows_;\n        std::list\u003cTwitter::Tweet*\u003e tweets_;\n    };\n\npublic:\n    Twitter() : time_(0) {\n\n    }\n    \n    void postTweet(int userId, int tweetId) {\n        User* user = nullptr;\n        auto it = users_.find(userId);\n        if (it == users_.end()) {\n            user = new User(userId);\n            users_.insert({userId, user});\n        } else {\n            user = it-\u003esecond;\n        }\n        user-\u003eTweet(tweetId, ++time_);\n    }\n    \n    vector\u003cint\u003e getNewsFeed(int userId) {\n        std::vector\u003cint\u003e news;\n        if (users_.count(userId) == 0) {\n            return news;\n        }\n\n        std::vector\u003cUser*\u003e users;\n        auto self = users_[userId];\n        users.push_back(self);\n        for (int id : self-\u003eFollowees()) {\n            if (users_.count(id)) {\n                users.push_back(users_[id]);\n            }\n        }\n\n        using TweetIterator = std::list\u003cTweet*\u003e::iterator;\n        struct UserTweetIter {\n            TweetIterator curr;\n            TweetIterator end;\n        };\n        struct cmp {\n            bool operator()(const UserTweetIter a, const UserTweetIter b) {\n                return (*a.curr)-\u003etime \u003c (*b.curr)-\u003etime;\n            }\n        };\n\n        std::priority_queue\u003cUserTweetIter, std::vector\u003cUserTweetIter\u003e, cmp\u003e pq;\n        for (auto user : users) {\n            if (user-\u003eTweets().size() \u003e 0) {\n                pq.push(UserTweetIter{.curr = user-\u003eTweets().begin(), .end = user-\u003eTweets().end()});\n            }\n        }\n\n        while (!pq.empty() \u0026\u0026 news.size() \u003c 10) {\n            UserTweetIter userIter = pq.top();\n            pq.pop();\n            news.push_back((*(userIter.curr))-\u003etweet_id);\n            if (++userIter.curr != userIter.end) {\n                pq.push(userIter);\n            }\n        }\n        return news;\n    }\n    \n    void follow(int followerId, int followeeId) {\n        auto it = users_.find(followerId);\n        if (it == users_.end()) {\n            auto follower = new User(followerId);\n            users_[followerId] = follower;\n            follower-\u003eFollow(followeeId); \n        } else {\n            it-\u003esecond-\u003eFollow(followeeId);\n        }\n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        auto it = users_.find(followerId);\n        if (it != users_.end()) {\n            it-\u003esecond-\u003eUnFollow(followeeId);\n        }\n    }\nprivate:\n    int time_;\n    unordered_map\u003cint, User*\u003e users_;\n};\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter* obj = new Twitter();\n * obj-\u003epostTweet(userId,tweetId);\n * vector\u003cint\u003e param_2 = obj-\u003egetNewsFeed(userId);\n * obj-\u003efollow(followerId,followeeId);\n * obj-\u003eunfollow(followerId,followeeId);\n */",
    "id": "264805438",
    "lang": "cpp",
    "memory": "6.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 16,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "355",
     "title": "Design Twitter",
     "titleSlug": "design-twitter",
     "translatedTitle": "设计推特"
    },
    "rawMemory": "7044000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/design-twitter/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "费劲啊。",
     "flagType": "PURPLE"
    },
    "timestamp": 1643988484,
    "totalTestCaseCnt": 16
   }
  },
  "detect-capital": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool detectCapitalUse(string word) {\n        bool all_lower = false, all_upper = false, first_upper = false;\n        if (isupper(word[0])) {\n            all_upper = true;\n            first_upper = true;\n        } else if (islower(word[0])) {\n            all_lower = true;\n        }\n\n        for (int i = 1; i \u003c word.size(); i++) {\n            int c = word[i];\n            if (isupper(c)) {\n                all_upper = all_upper \u0026 true;\n                all_lower = all_lower \u0026 false;\n                first_upper = first_upper \u0026 false;\n            } else if (islower(c)) {\n                all_upper = all_upper \u0026 false;\n                all_lower = all_lower \u0026 true;\n                first_upper = first_upper \u0026 true;\n            } else {\n                all_upper = all_upper \u0026 false;\n                all_lower = all_lower \u0026 false;\n                first_upper = first_upper \u0026 false;\n            }\n        }\n\n        return all_lower || all_upper || first_upper;\n    }\n};",
    "id": "9828180",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 550,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "520",
     "title": "Detect Capital",
     "titleSlug": "detect-capital",
     "translatedTitle": "检测大写字母"
    },
    "rawMemory": "N/A",
    "runtime": "12 ms",
    "sourceUrl": "/problems/detect-capital/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543316336,
    "totalTestCaseCnt": 550
   }
  },
  "diameter-of-binary-tree": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nint max(int a, int b) {\n    return a \u003e b ? a : b;\n}\n\nint depthOfBinaryTree(struct TreeNode* root, int *diameter) {\n    if (root == NULL) return 0;\n    int dleft = depthOfBinaryTree(root-\u003eleft, diameter);\n    int dright = depthOfBinaryTree(root-\u003eright, diameter);\n    *diameter = max(*diameter, dleft + dright);\n    return max(dleft, dright) + 1;\n}\n\nint diameterOfBinaryTree(struct TreeNode* root){\n    int diameter = 0;\n    depthOfBinaryTree(root, \u0026diameter);\n    return diameter;\n}",
    "id": "265180429",
    "lang": "c",
    "memory": "8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 104,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "543",
     "title": "Diameter of Binary Tree",
     "titleSlug": "diameter-of-binary-tree",
     "translatedTitle": "二叉树的直径"
    },
    "rawMemory": "8232000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/diameter-of-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644130314,
    "totalTestCaseCnt": 104
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int diameterOfBinaryTree(TreeNode* root) {\n        int res = 0;\n        depth(root, res);\n        return res;\n    }\n\n    int depth(TreeNode* root, int\u0026 res) {\n        if (root == nullptr) return 0;\n        int d1 = depth(root-\u003eleft, res);\n        int d2 = depth(root-\u003eright, res);\n        res = std::max(res, d1 + d2);\n        return std::max(d1, d2) + 1;\n    }\n};",
    "id": "265184271",
    "lang": "cpp",
    "memory": "19.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 104,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "543",
     "title": "Diameter of Binary Tree",
     "titleSlug": "diameter-of-binary-tree",
     "translatedTitle": "二叉树的直径"
    },
    "rawMemory": "20252000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/diameter-of-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644131149,
    "totalTestCaseCnt": 104
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc diameterOfBinaryTree(root *TreeNode) int {\n    diameter := 0\n    depth(root, \u0026diameter)\n    return diameter\n}\n\nfunc depth(root *TreeNode, diameter *int) int {\n    if root == nil {\n        return 0\n    }\n    le := depth(root.Left, diameter)\n    ri := depth(root.Right, diameter)\n    *diameter = max(*diameter, le + ri)\n    return max(le, ri) + 1\n}\n\nfunc max(a, b int) int {\n    if a \u003e b {\n        return a\n    }\n    return b\n}\n\n",
    "id": "275418874",
    "lang": "golang",
    "memory": "4.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 104,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "543",
     "title": "Diameter of Binary Tree",
     "titleSlug": "diameter-of-binary-tree",
     "translatedTitle": "二叉树的直径"
    },
    "rawMemory": "4292000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/diameter-of-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646130072,
    "totalTestCaseCnt": 104
   }
  },
  "diameter-of-n-ary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector\u003cNode*\u003e children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector\u003cNode*\u003e _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int diameter(Node* root) {\n        int diameter = 0;\n        height(root, \u0026diameter);\n        return diameter;\n    }\n\n    int height(Node* root, int *diameter) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int max_height = 0, second_height = 0;\n        for (auto \u0026child : root-\u003echildren) {\n            int h = height(child, diameter);\n            if (h \u003e max_height) {\n                second_height = max_height;\n                max_height = h;\n            } else if (h \u003e second_height) {\n                second_height = h;\n            }\n        }\n        *diameter = std::max(*diameter, max_height + second_height);\n        return max_height + 1;\n    }\n};",
    "id": "275528559",
    "lang": "cpp",
    "memory": "10.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1665",
     "title": "Diameter of N-Ary Tree",
     "titleSlug": "diameter-of-n-ary-tree",
     "translatedTitle": "N 叉树的直径"
    },
    "rawMemory": "10844000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/diameter-of-n-ary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646140526,
    "totalTestCaseCnt": 38
   }
  },
  "distribute-candies": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int distributeCandies(vector\u003cint\u003e\u0026 candyType) {\n        unordered_set\u003cint\u003e set(candyType.begin(), candyType.end());\n        return std::min(set.size(), candyType.size()/2);    \n    }\n};",
    "id": "264827357",
    "lang": "cpp",
    "memory": "107.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 206,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "575",
     "title": "Distribute Candies",
     "titleSlug": "distribute-candies",
     "translatedTitle": "分糖果"
    },
    "rawMemory": "110192000",
    "runtime": "208 ms",
    "sourceUrl": "/problems/distribute-candies/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644005836,
    "totalTestCaseCnt": 206
   }
  },
  "divide-two-integers": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if (dividend == INT_MIN \u0026\u0026 divisor == -1) return INT_MAX;\n        return dividend / divisor;\n    }\n};",
    "id": "265556032",
    "lang": "cpp",
    "memory": "5.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 992,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "29",
     "title": "Divide Two Integers",
     "titleSlug": "divide-two-integers",
     "translatedTitle": "两数相除"
    },
    "rawMemory": "5844000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/divide-two-integers/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644228123,
    "totalTestCaseCnt": 992
   }
  },
  "edit-distance": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        vector\u003cvector\u003cint\u003e\u003e memo(word1.size(), vector\u003cint\u003e(word2.size())); \n        return edit(word1, 0, word2, 0, memo); \n    }\n\n    int edit(string\u0026 w1, int i, string\u0026 w2, int j, vector\u003cvector\u003cint\u003e\u003e\u0026 memo) {\n        if (i == w1.size()) \n            return w2.size() - j;\n        if (j == w2.size()) \n            return w1.size() - i;\n        \n        // 如果当前相等，没有错误，就编辑下个字符\n        if (w1[i] == w2[j]) {\n            return edit(w1, i+1, w2, j+1, memo);\n        }\n\n        // 如果有记忆就算了\n        if (memo[i][j] \u003e 0) {\n            return memo[i][j];\n        }\n\n        int ins = edit(w1, i, w2, j+1, memo);   // 插入 w2[j] -\u003e w1[i]\n        int del = edit(w1, i+1, w2, j, memo);   // 删除 wi[i]\n        int sub = edit(w1, i+1, w2, j+1, memo); // 替换 wi[i] \u003c-\u003e w2[j]\n        memo[i][j] = std::min({ins, del, sub}) + 1;  // 错误增加\n        return memo[i][j];\n    }\n};",
    "id": "279955382",
    "lang": "cpp",
    "memory": "9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1146,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "72",
     "title": "Edit Distance",
     "titleSlug": "edit-distance",
     "translatedTitle": "编辑距离"
    },
    "rawMemory": "9208000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/edit-distance/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646796650,
    "totalTestCaseCnt": 1146
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func minDistance(word1 string, word2 string) int {\n    memo := make([][]int, len(word1) + 1)\n    for i := 0; i \u003c len(memo); i++ {\n        memo[i] = make([]int, len(word2) + 1)\n    }\n    return edit(word1, word2, memo)\n}\n\n// 编辑剩下的字符串\n// 增加记忆化\nfunc edit(w1 string, w2 string, memo [][]int) int {\n    if len(w1) == 0 || len(w2) == 0 {\n        return len(w2) + len(w1)\n    }\n\n    if w1[0] == w2[0] {\n        return edit(w1[1:], w2[1:], memo)\n    } \n\n    if memo[len(w1)][len(w2)] != 0 {\n        return memo[len(w1)][len(w2)]\n    }\n\n    del := 1 + edit(w1[1:], w2[:], memo)\n    add := 1 + edit(w1[:], w2[1:], memo)\n    sub := 1 + edit(w1[1:], w2[1:], memo)\n    memo[len(w1)][len(w2)] = min(del, add, sub)\n    return memo[len(w1)][len(w2)]\n}\n\nfunc min(a, b, c int) int {\n    if a \u003c b {\n        if a \u003c c {\n            return a\n        } else {\n            return c\n        }\n    } else if (b \u003c c) {\n        return b\n    } \n    return c\n} ",
    "id": "261729667",
    "lang": "golang",
    "memory": "6.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1146,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "72",
     "title": "Edit Distance",
     "titleSlug": "edit-distance",
     "translatedTitle": "编辑距离"
    },
    "rawMemory": "6204000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/edit-distance/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "思路好理解\n\nedit 意思是编辑当前剩下的词。",
     "flagType": "RED"
    },
    "timestamp": 1642955619,
    "totalTestCaseCnt": 1146
   }
  },
  "encode-and-decode-tinyurl": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n\n    // Encodes a URL to a shortened URL.\n    string encode(string longUrl) {\n        url.push_back(longUrl);\n        return \"http://tinyurl.com/\" + to_string(url.size() - 1);\n    }\n\n    // Decodes a shortened URL to its original URL.\n    string decode(string shortUrl) {\n        auto pos = shortUrl.find_last_of(\"/\");\n        return url[stoi(shortUrl.substr(pos + 1))];\n    }\n    \nprivate:\n    vector\u003cstring\u003e url;\n};\n\n// Your Solution object will be instantiated and called as such:\n// Solution solution;\n// solution.decode(solution.encode(url));",
    "id": "10119450",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 739,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "535",
     "title": "Encode and Decode TinyURL",
     "titleSlug": "encode-and-decode-tinyurl",
     "translatedTitle": "TinyURL 的加密与解密"
    },
    "rawMemory": "N/A",
    "runtime": "8 ms",
    "sourceUrl": "/problems/encode-and-decode-tinyurl/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543984883,
    "totalTestCaseCnt": 739
   }
  },
  "er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int kthLargest(TreeNode* root, int k) {\n        int res, cnt = 0;\n        TreeNode* curr = root;\n        stack\u003cTreeNode*\u003e stk;\n\n\n        while (curr || !stk.empty()) {\n            while (curr) {\n                stk.push(curr);\n                curr = curr-\u003eright;\n            }\n            curr = stk.top();\n            if (++cnt == k) {\n                res = curr-\u003eval;\n                break;\n            }\n            stk.pop();\n            curr = curr-\u003eleft;\n        }\n        \n        return res;\n    }\n};",
    "id": "268747147",
    "lang": "cpp",
    "memory": "23.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 91,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100333",
     "title": "二叉搜索树的第k大节点  LCOF",
     "titleSlug": "er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof",
     "translatedTitle": "二叉搜索树的第k大节点"
    },
    "rawMemory": "24084000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644928079,
    "totalTestCaseCnt": 91
   }
  },
  "er-jin-zhi-zhong-1de-ge-shu-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int sum  = 0;\n        while (n != 0) {\n            sum++;\n            n = n \u0026 (n -1);\n        }\n        return sum;\n    }\n};",
    "id": "193745334",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 601,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100292",
     "title": "二进制中1的个数 LCOF",
     "titleSlug": "er-jin-zhi-zhong-1de-ge-shu-lcof",
     "translatedTitle": "二进制中1的个数"
    },
    "rawMemory": "5920000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1625756461,
    "totalTestCaseCnt": 601
   }
  },
  "evaluate-reverse-polish-notation": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int evalRPN(vector\u003cstring\u003e\u0026 tokens) {\n        stack\u003cint\u003e st;\n        std::function\u003cvoid(std::function\u003cint(int,int)\u003e)\u003e eval = [\u0026st]( std::function\u003cint(int,int)\u003e func) {\n            int var1 = 0, var2 = 0;\n            var1 = st.top(), st.pop();\n            var2 = st.top(), st.pop();\n            st.push(func(var2, var1));\n        };\n\n        for (auto \u0026token : tokens) {\n            switch (token[0]) {\n                case '+':\n                    eval([](int a, int b) {return a + b;});\n                    break;\n                case '-':\n                    if (token.size() \u003e 1) st.push(stoi(token));\n                    else eval([](int a, int b) {return a - b;}); \n                    break;\n                case '*':\n                    eval([](int a, int b) {return a * b;}); \n                    break;\n                case '/':\n                    eval([](int a, int b) {return a / b;}); \n                    break;\n                default:\n                    st.push(stoi(token));\n            }\n        }\n        return st.top();\n    }\n};",
    "id": "265061445",
    "lang": "cpp",
    "memory": "11.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 20,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "150",
     "title": "Evaluate Reverse Polish Notation",
     "titleSlug": "evaluate-reverse-polish-notation",
     "translatedTitle": "逆波兰表达式求值"
    },
    "rawMemory": "11836000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/evaluate-reverse-polish-notation/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "不好啊",
     "flagType": "BLUE"
    },
    "timestamp": 1644080321,
    "totalTestCaseCnt": 20
   }
  },
  "excel-sheet-column-number": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int titleToNumber(string columnTitle) {\n        int sum = 0;\n        for (auto c : columnTitle) {\n            if (sum \u003e= (INT_MAX - (c-'A'+1)) / 26) {\n                return INT_MAX;\n            }\n            sum = ('Z'-'A' + 1) * sum + c - 'A' + 1;\n        }\n        return sum;\n    }\n};",
    "id": "265675449",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1002,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "171",
     "title": "Excel Sheet Column Number",
     "titleSlug": "excel-sheet-column-number",
     "translatedTitle": "Excel 表列序号"
    },
    "rawMemory": "5912000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/excel-sheet-column-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644250048,
    "totalTestCaseCnt": 1002
   }
  },
  "factor-combinations": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e getFactors(int n) {\n\n        function\u003cvector\u003cvector\u003cint\u003e\u003e(int, int)\u003e dfs = [\u0026](int n, int start) {\n            vector\u003cvector\u003cint\u003e\u003e res;\n            for (int i = start; i*i \u003c= n; i++) {\n                if (n % i == 0) {\n                    res.push_back({i, n / i});\n                    for (auto \u0026v : dfs(n / i, i)) {\n                        v.push_back(i);\n                        res.push_back(v);\n                    }\n                }\n            }\n            return res;\n        };\n\n        return dfs(n, 2);\n    }\n};",
    "id": "266460418",
    "lang": "cpp",
    "memory": "18.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "254",
     "title": "Factor Combinations",
     "titleSlug": "factor-combinations",
     "translatedTitle": "因子的组合"
    },
    "rawMemory": "18520000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/factor-combinations/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644431017,
    "totalTestCaseCnt": 68
   }
  },
  "fan-zhuan-lian-biao-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* newNode = NULL;\n        while (head != NULL) {\n            ListNode* next = head-\u003enext;\n            head-\u003enext = newNode;\n            newNode = head;\n            head = next;\n        }\n        return newNode;\n    }\n};",
    "id": "193753826",
    "lang": "cpp",
    "memory": "8.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 27,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100298",
     "title": "反转链表 LCOF",
     "titleSlug": "fan-zhuan-lian-biao-lcof",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "8320000",
    "runtime": "4 ms",
    "sourceUrl": "/leetbook/read/illustration-of-algorithm/9pdjbm/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1625758030,
    "totalTestCaseCnt": 27
   }
  },
  "fei-bo-na-qi-shu-lie-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int fib(int n) {\n        int MOD = 1000000007;\n        vector\u003cint\u003e fibs(n+2);\n        fibs[1] = 1;\n\n        std::function\u003cint(int)\u003e fib_iter = [\u0026](int n) {\n            if (fibs[n] \u003e 0 || n == 0) {\n                return fibs[n];\n            }\n            int a = fib_iter(n-2) % MOD;\n            int b = fib_iter(n-1) % MOD;\n            fibs[n] = (a + b) % MOD;\n            return fibs[n];\n        };\n        return fib_iter(n);\n    }\n};",
    "id": "262303708",
    "lang": "cpp",
    "memory": "6.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 51,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100274",
     "title": "斐波那契数列  LCOF",
     "titleSlug": "fei-bo-na-qi-shu-lie-lcof",
     "translatedTitle": "斐波那契数列"
    },
    "rawMemory": "6344000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/fei-bo-na-qi-shu-lie-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "递归",
     "flagType": "RED"
    },
    "timestamp": 1643112127,
    "totalTestCaseCnt": 51
   }
  },
  "fibonacci-number": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int fib(int n) {\n    int fibs[2] = {0, 1, };\n    while (n \u003e 1) {\n        fibs[0] = fibs[0] + fibs[1];\n        fibs[1] = fibs[0] + fibs[1];\n        n -= 2;\n    }\n    return fibs[n]; \n}",
    "id": "266421920",
    "lang": "c",
    "memory": "5.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1013",
     "title": "Fibonacci Number",
     "titleSlug": "fibonacci-number",
     "translatedTitle": "斐波那契数"
    },
    "rawMemory": "5524000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/fibonacci-number/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "滚动数组。",
     "flagType": "BLUE"
    },
    "timestamp": 1644419168,
    "totalTestCaseCnt": 31
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int fib(int n) {\n        int fb[3] = {0, 1};\n        for (int i = 1; i \u003c= n; i++) {\n            fb[0] = fb[1];\n            fb[1] = fb[2];\n            fb[2] = fb[0] + fb[1];\n        }\n        return fb[2];\n    }\n};",
    "id": "266424626",
    "lang": "cpp",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1013",
     "title": "Fibonacci Number",
     "titleSlug": "fibonacci-number",
     "translatedTitle": "斐波那契数"
    },
    "rawMemory": "6120000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/fibonacci-number/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "优化。",
     "flagType": "BLUE"
    },
    "timestamp": 1644419584,
    "totalTestCaseCnt": 31
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func fib(n int) int {\n    if n \u003c 2 {\n        return n\n    }\n    return fib(n-1) + fib(n-2)\n}",
    "id": "264823807",
    "lang": "golang",
    "memory": "1.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1013",
     "title": "Fibonacci Number",
     "titleSlug": "fibonacci-number",
     "translatedTitle": "斐波那契数"
    },
    "rawMemory": "1920000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/fibonacci-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643999331,
    "totalTestCaseCnt": 31
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def fib(self, n: int) -\u003e int:\n        return int((5**0.5)*0.2*( ((1+5**0.5)/2)**n-((1-5**0.5)/2)**n))",
    "id": "264824256",
    "lang": "python3",
    "memory": "15 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1013",
     "title": "Fibonacci Number",
     "titleSlug": "fibonacci-number",
     "translatedTitle": "斐波那契数"
    },
    "rawMemory": "15340000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/fibonacci-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644000277,
    "totalTestCaseCnt": 31
   }
  },
  "find-all-numbers-disappeared-in-an-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e findDisappearedNumbers(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cint\u003e res;\n        int len = nums.size();\n        for (int i = 0; i \u003c len; i++) {\n            int index = (nums[i] - 1) % len;\n            nums[index] += len;\n        }\n        for (int i = 0; i \u003c len; i++) {\n            if (nums[i] \u003c= len) {\n                res.push_back(i+1);\n            }\n        }\n        return res;\n    }\n};",
    "id": "263475047",
    "lang": "cpp",
    "memory": "32.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 33,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "448",
     "title": "Find All Numbers Disappeared in an Array",
     "titleSlug": "find-all-numbers-disappeared-in-an-array",
     "translatedTitle": "找到所有数组中消失的数字"
    },
    "rawMemory": "33632000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/find-all-numbers-disappeared-in-an-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643445364,
    "totalTestCaseCnt": 33
   }
  },
  "find-first-and-last-position-of-element-in-sorted-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) {\n        auto lower_bound = [\u0026]() -\u003eint {\n            int j = 0, k = nums.size();\n            while (j \u003c k) {\n                int m = j + (k -j)/2;\n                if (nums[m] \u003c target) {\n                    j = m + 1;\n                } else {\n                    k = m;\n                }\n            }\n            return j;\n        };\n\n        auto upper_bound = [\u0026]() -\u003e int {\n            int j = 0, k = nums.size();\n            while (j \u003c k) {\n                int m = j + (k-j)/2;\n                if (nums[m] \u003c= target) {\n                    j = m + 1;\n                } else {\n                    k = m;\n                }\n            }\n            return j;\n        };\n\n        int j = lower_bound(), \n            k = upper_bound();\n        if (j == k) {\n            return {-1, -1};\n        }\n\n        return {j, k-1};\n    }\n};",
    "id": "262570309",
    "lang": "cpp",
    "memory": "13.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 88,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "34",
     "title": "Find First and Last Position of Element in Sorted Array",
     "titleSlug": "find-first-and-last-position-of-element-in-sorted-array",
     "translatedTitle": "在排序数组中查找元素的第一个和最后一个位置"
    },
    "rawMemory": "13772000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/find-first-and-last-position-of-element-in-sorted-array/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "lower_bound 和 upper_bound 的实现。\n一致性啊，等号来判断是不是找到。",
     "flagType": "RED"
    },
    "timestamp": 1643187595,
    "totalTestCaseCnt": 88
   }
  },
  "find-numbers-with-even-number-of-digits": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "inline int isEven(int n) {\n    int cnt = 1;\n    while (n /= 10) {\n        cnt++;\n    }\n    return cnt % 2 == 0 ? 1 : 0;\n}\n\nint findNumbers(int* nums, int numsSize){\n    int res = 0;\n    for (int i = 0; i \u003c numsSize; i++) {\n        res += isEven(nums[i]);\n    }\n    return res;\n}",
    "id": "232921360",
    "lang": "c",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 104,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1421",
     "title": "Find Numbers with Even Number of Digits",
     "titleSlug": "find-numbers-with-even-number-of-digits",
     "translatedTitle": "统计位数为偶数的数字"
    },
    "rawMemory": "6084000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/find-numbers-with-even-number-of-digits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635332863,
    "totalTestCaseCnt": 104
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int findNumbers(vector\u003cint\u003e\u0026 nums) {\n        return accumulate(nums.begin(), nums.end(), 0, [](int a, int b){\n            int c = (int)(log10(b) + 1) % 2 == 0;\n            return a + c;\n        });\n    }\n};",
    "id": "232928755",
    "lang": "cpp",
    "memory": "9.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 104,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1421",
     "title": "Find Numbers with Even Number of Digits",
     "titleSlug": "find-numbers-with-even-number-of-digits",
     "translatedTitle": "统计位数为偶数的数字"
    },
    "rawMemory": "10100000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/find-numbers-with-even-number-of-digits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635334404,
    "totalTestCaseCnt": 104
   }
  },
  "find-peak-element": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int findPeakElement(vector\u003cint\u003e\u0026 nums) {\n        int lo = 0, hi = nums.size() - 1;\n        while (lo \u003c hi) {\n            int mid = (lo + hi) \u003e\u003e 1;\n            if (nums[mid] \u003c nums[mid+1]) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return hi;\n    }\n};",
    "id": "277941391",
    "lang": "cpp",
    "memory": "8.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 63,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "162",
     "title": "Find Peak Element",
     "titleSlug": "find-peak-element",
     "translatedTitle": "寻找峰值"
    },
    "rawMemory": "8664000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/find-peak-element/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "ok",
     "flagType": "GREEN"
    },
    "timestamp": 1646494206,
    "totalTestCaseCnt": 63
   }
  },
  "find-pivot-index": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "// sum + nums[i] + sum = total\n// 2sum = total = num[i]\nint pivotIndex(int* nums, int numsSize){\n    int total = 0, sum = 0;\n    for (int i = 0; i \u003c numsSize; i++) {\n        total += nums[i];\n    }\n    for (int i = 0; i \u003c numsSize; i++) {\n        if (sum + sum + nums[i] == total) {\n            return i;\n        }\n        sum += nums[i];\n    }\n\n    return -1;\n}",
    "id": "268289285",
    "lang": "c",
    "memory": "6.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 743,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "724",
     "title": "Find Pivot Index",
     "titleSlug": "find-pivot-index",
     "translatedTitle": "寻找数组的中心下标"
    },
    "rawMemory": "6600000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/find-pivot-index/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "公式啊。",
     "flagType": "BLUE"
    },
    "timestamp": 1644836711,
    "totalTestCaseCnt": 745
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int pivotIndex(vector\u003cint\u003e\u0026 nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        int lo = 0, l_sum = 0;\n        while (lo \u003c nums.size()) {\n            if (l_sum == sum - nums[lo]) {\n                return lo;\n            } else {\n                l_sum += nums[lo];\n                sum -= nums[lo];\n                lo++;\n            }\n        }\n        return -1;\n    }\n};",
    "id": "268287851",
    "lang": "cpp",
    "memory": "30.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 743,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "724",
     "title": "Find Pivot Index",
     "titleSlug": "find-pivot-index",
     "translatedTitle": "寻找数组的中心下标"
    },
    "rawMemory": "30980000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/find-pivot-index/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这个算法不行啊。",
     "flagType": "BLUE"
    },
    "timestamp": 1644836400,
    "totalTestCaseCnt": 745
   }
  },
  "find-smallest-letter-greater-than-target": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    char nextGreatestLetter(vector\u003cchar\u003e\u0026 letters, char target) {\n        int lo = 0, hi = letters.size();\n        while (lo \u003c hi) {\n            int m = (lo + hi) \u003e\u003e 1;\n            if (letters[m] \u003c= target) {\n                lo = m + 1;\n            } else {\n                hi = m;\n            }\n        }\n        if (hi == letters.size()) hi = 0;\n        return letters[hi];\n    }\n};",
    "id": "265692754",
    "lang": "cpp",
    "memory": "15.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 165,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "745",
     "title": "Find Smallest Letter Greater Than Target",
     "titleSlug": "find-smallest-letter-greater-than-target",
     "translatedTitle": "寻找比目标字母大的最小字母"
    },
    "rawMemory": "15904000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/find-smallest-letter-greater-than-target/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644264844,
    "totalTestCaseCnt": 165
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func nextGreatestLetter(letters []byte, target byte) byte {\n    lo, hi := 0, len(letters)\n    for lo \u003c hi {\n        m := (lo + hi) \u003e\u003e 1\n        if letters[m] \u003c= target {\n            lo = m + 1\n        } else {\n            hi = m\n        }\n    }\n    if lo == len(letters) {\n        lo = 0\n    }\n    return letters[lo]\n}",
    "id": "265670098",
    "lang": "golang",
    "memory": "2.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 165,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "745",
     "title": "Find Smallest Letter Greater Than Target",
     "titleSlug": "find-smallest-letter-greater-than-target",
     "translatedTitle": "寻找比目标字母大的最小字母"
    },
    "rawMemory": "2604000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/find-smallest-letter-greater-than-target/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "防止 lo 超过边界啊。",
     "flagType": "PURPLE"
    },
    "timestamp": 1644248796,
    "totalTestCaseCnt": 165
   }
  },
  "find-the-difference": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    char findTheDifference(string s, string t) {\n        char c = 0;\n        // or s + t\n        for (int i = 0; i \u003c s.size(); i++) {\n            c ^= s[i] ^ t[i]; \n        }\n        return t.back() ^ c;\n    }\n};",
    "id": "262609870",
    "lang": "cpp",
    "memory": "6.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 54,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "389",
     "title": "Find the Difference",
     "titleSlug": "find-the-difference",
     "translatedTitle": "找不同"
    },
    "rawMemory": "6732000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/find-the-difference/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643195528,
    "totalTestCaseCnt": 54
   }
  },
  "find-the-distance-value-between-two-arrays": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int findTheDistanceValue(vector\u003cint\u003e\u0026 arr1, vector\u003cint\u003e\u0026 arr2, int d) {\n        int len1 = arr1.size(), len2 = arr2.size();\n        int res = 0;\n        for (int i = 0; i \u003c len1; i++) {\n            int cnt = 0;\n            for (int j = 0; j \u003c len2; j++) {\n                if (abs(arr1[i] - arr2[j]) \u003e d) {\n                    cnt++;\n                }\n            }\n            res += cnt == len2;\n        }\n        return res;\n    }\n};",
    "id": "265648120",
    "lang": "cpp",
    "memory": "12.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 103,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1486",
     "title": "Find the Distance Value Between Two Arrays",
     "titleSlug": "find-the-distance-value-between-two-arrays",
     "translatedTitle": "两个数组间的距离值"
    },
    "rawMemory": "13100000",
    "runtime": "44 ms",
    "sourceUrl": "/problems/find-the-distance-value-between-two-arrays/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644244565,
    "totalTestCaseCnt": 103
   }
  },
  "first-bad-version": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int j = 0, k = n;\n        while (j \u003c k) {\n            int m = j + (k-j)/2;\n            if (!isBadVersion(m)) {\n                j = m + 1;\n            } else {\n                k = m;\n            }\n        }\n        return k;\n    }\n};",
    "id": "265692108",
    "lang": "cpp",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 22,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "278",
     "title": "First Bad Version",
     "titleSlug": "first-bad-version",
     "translatedTitle": "第一个错误的版本"
    },
    "rawMemory": "6036000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/first-bad-version/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这个是对的。",
     "flagType": "PURPLE"
    },
    "timestamp": 1644262839,
    "totalTestCaseCnt": 22
   }
  },
  "first-unique-character-in-a-string": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int firstUniqChar(string s) {\n        int cnt[256] = {0};\n        for (auto \u0026c : s) {\n            cnt[c] += 1;\n        }\n        for (int i = 0; i \u003c s.size(); i++) {\n            if (cnt[s[i]] == 1) return i;\n        }\n        return -1;\n    }\n};",
    "id": "10491355",
    "lang": "cpp",
    "memory": "1.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 104,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "387",
     "title": "First Unique Character in a String",
     "titleSlug": "first-unique-character-in-a-string",
     "translatedTitle": "字符串中的第一个唯一字符"
    },
    "rawMemory": "1400832",
    "runtime": "32 ms",
    "sourceUrl": "/problems/first-unique-character-in-a-string/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544854148,
    "totalTestCaseCnt": 104
   }
  },
  "fixed-point": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution \n{\npublic:\n    int fixedPoint(vector\u003cint\u003e\u0026 arr) {\n        int lo = 0,  hi = arr.size();\n        while (lo \u003c hi) {\n            int mid = (lo + hi) \u003e\u003e 1;\n            if (arr[mid] \u003c mid) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        if (hi == arr.size()) return -1;\n        return hi == arr[hi] ? hi : -1;\n    }\n};",
    "id": "265693008",
    "lang": "cpp",
    "memory": "10.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 51,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1066",
     "title": "Fixed Point",
     "titleSlug": "fixed-point",
     "translatedTitle": "不动点"
    },
    "rawMemory": "10552000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/fixed-point/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "Ok now",
     "flagType": "BLUE"
    },
    "timestamp": 1644265678,
    "totalTestCaseCnt": 51
   }
  },
  "fizz-buzz": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cstring\u003e fizzBuzz(int n) {\n        vector\u003cstring\u003e result;\n        //c++ std::to_string\n        for (int i = 1; i \u003c= n; i++){\n            if (i%15 == 0) result.push_back(\"FizzBuzz\");\n            else if (i%3 == 0) result.push_back(\"Fizz\");\n            else if (i%5 == 0) result.push_back(\"Buzz\");\n            else result.push_back(to_string(i));\n        }\n        \n        return result;\n    }\n};",
    "id": "8314647",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 8,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "412",
     "title": "Fizz Buzz",
     "titleSlug": "fizz-buzz",
     "translatedTitle": "Fizz Buzz"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/fizz-buzz/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539668194,
    "totalTestCaseCnt": 8
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def fizzBuzz(self, n: int) -\u003e List[str]:\n        res = []\n        i = 1\n        while i \u003c= n:\n            if i % 15 == 0:\n                res.append(\"FizzBuzz\")\n            elif i % 5 == 0:\n                res.append(\"Buzz\")\n            elif i % 3 == 0:\n                res.append(\"Fizz\")\n            else:\n                res.append(str(i))\n            i += 1\n        return res\n",
    "id": "294782720",
    "lang": "python3",
    "memory": "15.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 8,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "412",
     "title": "Fizz Buzz",
     "titleSlug": "fizz-buzz",
     "translatedTitle": "Fizz Buzz"
    },
    "rawMemory": "15996000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/fizz-buzz/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1649076956,
    "totalTestCaseCnt": 8
   },
   "rust": {
    "__typename": "GeneralSubmissionNode",
    "code": "impl Solution {\n    pub fn fizz_buzz(n: i32) -\u003e Vec\u003cString\u003e {\n        let mut i = 1;\n        let mut res = Vec::new();\n\n        while i \u003c= n {\n            if i % 15 == 0 {\n                res.push(\"FizzBuzz\".to_string());\n            } else if (i % 5 == 0) {\n                res.push(\"Buzz\".to_string());\n            } else if (i % 3 == 0) {\n                res.push(\"Fizz\".to_string());\n            } else {\n                res.push(i.to_string());\n            }\n            i += 1;\n        }\n        return res;\n    }\n}",
    "id": "294789183",
    "lang": "rust",
    "memory": "2.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 8,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "412",
     "title": "Fizz Buzz",
     "titleSlug": "fizz-buzz",
     "translatedTitle": "Fizz Buzz"
    },
    "rawMemory": "2692000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/fizz-buzz/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1649077575,
    "totalTestCaseCnt": 8
   }
  },
  "fizz-buzz-multithreaded": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "typedef struct {\n    int n;\n    pthread_barrier_t barrier;\n} FizzBuzz;\n\nFizzBuzz* fizzBuzzCreate(int n) {\n    FizzBuzz* obj = (FizzBuzz*) malloc(sizeof(FizzBuzz));\n    obj-\u003en = n;\n    pthread_barrier_init(\u0026obj-\u003ebarrier, NULL, 4);\n    return obj;\n}\n\n// printFizz() outputs \"fizz\".\nvoid fizz(FizzBuzz* obj) {\n    for (int i = 1; i \u003c= obj-\u003en; i++) {\n      if (i%3 == 0 \u0026\u0026 i%5 != 0) {\n        printFizz();\n      }\n      pthread_barrier_wait(\u0026obj-\u003ebarrier);\n    }\n}\n\n// printBuzz() outputs \"buzz\".\nvoid buzz(FizzBuzz* obj) {\n    for (int i = 1; i \u003c= obj-\u003en; i++) {\n      if (i%3 != 0 \u0026\u0026 i%5 == 0) {\n        printBuzz();\n      }\n      pthread_barrier_wait(\u0026obj-\u003ebarrier);\n    }\n}\n\n// printFizzBuzz() outputs \"fizzbuzz\".\nvoid fizzbuzz(FizzBuzz* obj) {\n    for (int i = 1; i \u003c= obj-\u003en; i++) {\n      if (i%15 == 0) {\n        printFizzBuzz();\n      }\n      pthread_barrier_wait(\u0026obj-\u003ebarrier);\n    }\n}\n\n// You may call global function `void printNumber(int x)`\n// to output \"x\", where x is an integer.\nvoid number(FizzBuzz* obj) {\n    for (int i = 1; i \u003c= obj-\u003en; i++) {\n      if (i%3 != 0 \u0026\u0026 i%5 != 0) {\n        printNumber(i);\n      }\n      pthread_barrier_wait(\u0026obj-\u003ebarrier);\n    }\n}\n\nvoid fizzBuzzFree(FizzBuzz* obj) {\n  if (obj) {\n    pthread_barrier_destroy(\u0026obj-\u003ebarrier);\n    free(obj);\n  }   \n}",
    "id": "266881233",
    "lang": "c",
    "memory": "5.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 9,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1316",
     "title": "Fizz Buzz Multithreaded",
     "titleSlug": "fizz-buzz-multithreaded",
     "translatedTitle": "交替打印字符串"
    },
    "rawMemory": "5884000",
    "runtime": "72 ms",
    "sourceUrl": "/problems/fizz-buzz-multithreaded/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "pthread_barrier",
     "flagType": "GREEN"
    },
    "timestamp": 1644512817,
    "totalTestCaseCnt": 9
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class FizzBuzz {\nprivate:\n    int n;\n    int status;\n    int index;\n    std::mutex m1;\n    std::condition_variable cv1;\npublic:\n    FizzBuzz(int n) {\n        this-\u003en = n;\n        this-\u003eindex = 1;\n        this-\u003estatus = 0;\n    }\n\n    int NextStatus() {\n        int curr = ++index;\n        if (curr \u003e n) return -1;\n        else if (curr % 15 == 0) return 15;\n        else if (curr % 5 == 0) return 5;\n        else if (curr % 3 == 0) return 3;\n        else return 0;\n    }\n\n    void Loop(function\u003cvoid()\u003e print, function\u003cbool()\u003e cmp) {\n        for (;;) {\n            std::unique_lock\u003cstd::mutex\u003e lk(m1);\n            cv1.wait(lk, [\u0026] {\n                return cmp() || (index \u003e n);\n            });\n            if (index \u003e n) {\n                cv1.notify_all();\n                break;\n            }\n            print();\n\n            status = NextStatus();\n            lk.unlock();\n            cv1.notify_all();\n        }\n    }\n\n    // printFizz() outputs \"fizz\".\n    void fizz(function\u003cvoid()\u003e printFizz) {\n        Loop(printFizz, [this]{ \n            return status == 3;\n        });\n    }\n\n    // printBuzz() outputs \"buzz\".\n    void buzz(function\u003cvoid()\u003e printBuzz) {\n        Loop(printBuzz, [this]{ \n            return status == 5;\n        });\n    }\n\n    // printFizzBuzz() outputs \"fizzbuzz\".\n\tvoid fizzbuzz(function\u003cvoid()\u003e printFizzBuzz) {\n        Loop(printFizzBuzz, [this]{ \n            return status == 15;\n        });\n    }\n\n    // printNumber(x) outputs \"x\", where x is an integer.\n    void number(function\u003cvoid(int)\u003e printNumber) {\n        Loop([\u0026]{\n            printNumber(index);\n        }, [this]{ \n            return status != 5 \u0026\u0026 status != 3 \u0026\u0026 status != 15;\n        });\n    }\n};",
    "id": "266882277",
    "lang": "cpp",
    "memory": "6.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 9,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1316",
     "title": "Fizz Buzz Multithreaded",
     "titleSlug": "fizz-buzz-multithreaded",
     "translatedTitle": "交替打印字符串"
    },
    "rawMemory": "6968000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/fizz-buzz-multithreaded/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OK。要熟悉 C++ 的多线程相关类",
     "flagType": "PURPLE"
    },
    "timestamp": 1644513404,
    "totalTestCaseCnt": 9
   }
  },
  "flatten-2d-vector": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Vector2D {\npublic:\n    Vector2D(vector\u003cvector\u003cint\u003e\u003e\u0026 vec) : i_(0), j_(0), vec_(\u0026vec) {\n        // 调整索引, \n        while (!vec_-\u003eempty() \u0026\u0026 vec_-\u003eat(i_).empty() \u0026\u0026 ++i_ \u003c vec_-\u003esize()); \n    }\n\n    int next() {\n        if (!hasNext()) {\n            throw std::out_of_range(\"vector2d out of range!\"); \n            return -1;\n        }\n        int n = vec_-\u003eat(i_).at(j_);\n        if (vec_-\u003eat(i_).size() == j_ + 1) {\n            // 调整索引\n            while (++i_ \u003c vec_-\u003esize() \u0026\u0026 vec_-\u003eat(i_).empty());\n            j_ = 0;\n        } else {\n            j_++;\n        }\n        return n;\n    }\n    \n    bool hasNext() {\n        if (i_ == vec_-\u003esize())\n            return false;\n        return true;\n    }\nprivate:\n    size_t i_;\n    size_t j_;\n    vector\u003cvector\u003cint\u003e\u003e* vec_;\n};\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D* obj = new Vector2D(vec);\n * int param_1 = obj-\u003enext();\n * bool param_2 = obj-\u003ehasNext();\n */",
    "id": "263318822",
    "lang": "cpp",
    "memory": "18.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 18,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "251",
     "title": "Flatten 2D Vector",
     "titleSlug": "flatten-2d-vector",
     "translatedTitle": "展开二维向量"
    },
    "rawMemory": "19356000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/flatten-2d-vector/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OKK",
     "flagType": "RED"
    },
    "timestamp": 1643382865,
    "totalTestCaseCnt": 18
   }
  },
  "flatten-a-multilevel-doubly-linked-list": {
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Prev *Node\n *     Next *Node\n *     Child *Node\n * }\n */\n\nfunc flatten(root *Node) *Node {\n    var last *Node = nil\n    var flat func(*Node)\n\n    flat = func(node *Node) {\n        if node == nil {\n            return\n        }\n        next := node.Next\n        if last != nil {\n            node.Prev = last\n            last.Next = node\n            last.Child = nil\n        }\n        last = node\n        flat(node.Child)\n        flat(next)\n    }\n    \n    flat(root)\n    return root\n}",
    "id": "264563247",
    "lang": "golang",
    "memory": "2.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 26,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "766",
     "title": "Flatten a Multilevel Doubly Linked List",
     "titleSlug": "flatten-a-multilevel-doubly-linked-list",
     "translatedTitle": "扁平化多级双向链表"
    },
    "rawMemory": "2760000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/flatten-a-multilevel-doubly-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "前序遍历。\n注意 next 指针。",
     "flagType": "GREEN"
    },
    "timestamp": 1643898666,
    "totalTestCaseCnt": 26
   }
  },
  "flatten-binary-tree-to-linked-list": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nvoid flatten_recur(struct TreeNode* root, struct TreeNode** last) {\n    if (root == NULL) {\n        return;\n    }\n    flatten_recur(root-\u003eright, last);\n    flatten_recur(root-\u003eleft, last);\n    root-\u003eright = *last;\n    root-\u003eleft = NULL;\n    *last = root;\n}\n\nvoid flatten(struct TreeNode* root){\n    struct TreeNode* last = NULL;\n    flatten_recur(root, \u0026last);\n}",
    "id": "263806820",
    "lang": "c",
    "memory": "6.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 225,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "114",
     "title": "Flatten Binary Tree to Linked List",
     "titleSlug": "flatten-binary-tree-to-linked-list",
     "translatedTitle": "二叉树展开为链表"
    },
    "rawMemory": "6824000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/flatten-binary-tree-to-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "牛逼啊",
     "flagType": "RED"
    },
    "timestamp": 1643549888,
    "totalTestCaseCnt": 225
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        std::vector\u003cTreeNode*\u003e vec;\n        std::function\u003cvoid(TreeNode*)\u003e f1 = [\u0026](TreeNode* node) {\n            if (node == nullptr) {\n                return;\n            }\n            vec.push_back(node);\n            f1(node-\u003eleft);\n            f1(node-\u003eright);\n        };\n        f1(root);\n\n        for (int i = 1; i \u003c vec.size(); i++) {\n            vec[i]-\u003eleft = nullptr;\n            vec[i]-\u003eright = nullptr;\n            vec[i-1]-\u003eleft = nullptr;\n            vec[i-1]-\u003eright = vec[i];\n        }\n    }\n};",
    "id": "263798817",
    "lang": "cpp",
    "memory": "12.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 225,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "114",
     "title": "Flatten Binary Tree to Linked List",
     "titleSlug": "flatten-binary-tree-to-linked-list",
     "translatedTitle": "二叉树展开为链表"
    },
    "rawMemory": "13032000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/flatten-binary-tree-to-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "先保存到 vec",
     "flagType": "RED"
    },
    "timestamp": 1643547813,
    "totalTestCaseCnt": 225
   }
  },
  "flipping-an-image": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e flipAndInvertImage(vector\u003cvector\u003cint\u003e\u003e\u0026 A) {            \n        for (auto \u0026row : A) {\n            int row_len = row.size();\n            for (int i = 0; i \u003c row_len / 2; i++) {\n                int t = 1 - row[i];\n                row[i] = 1 - row[row_len -1 - i];\n                row[row_len -1 - i] = t;\n            }\n            if (row_len \u0026 1) {\n                row[row_len / 2] = 1 -  row[row_len / 2];\n            }\n        }\n        return A;\n    }\n    \n    \n};",
    "id": "8282420",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 82,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "861",
     "title": "Flipping an Image",
     "titleSlug": "flipping-an-image",
     "translatedTitle": "翻转图像"
    },
    "rawMemory": "N/A",
    "runtime": "12 ms",
    "sourceUrl": "/problems/flipping-an-image/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539595507,
    "totalTestCaseCnt": 82
   }
  },
  "game-of-life": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void gameOfLife(vector\u003cvector\u003cint\u003e\u003e \u0026board) {\n        int step[][2] = {{1,-1},{1,1},{1,0},{-1,0},{-1,-1},{-1,1},{0,1},{0,-1}};\n        int m = board.size();\n        int n = m ? board[0].size() : 0;\n        for (int i = 0; i \u003c m; i++) {\n            for (int j = 0; j \u003c n; j++) {\n                int live_cnt = 0;\n                for (int k = 0; k \u003c sizeof(step)/ sizeof(step[0]); k++) {\n                    int new_i = i + step[k][0];\n                    int new_j = j + step[k][1];\n                    if (new_i \u003e= 0 \u0026\u0026 new_i \u003c m \u0026\u0026 new_j \u003e=0 \u0026\u0026 new_j \u003c n) {\n                        int around_p = board[new_i][new_j];\n                        if (around_p == 1 || around_p == 2) live_cnt++;\n                    }\n                }\n                if (board[i][j]) {\n                    if (live_cnt \u003c 2 || live_cnt \u003e 3) board[i][j] = 2;\n                } else {\n                    if (live_cnt == 3) board[i][j] = 3;\n                }\n            }\n        }\n        for (int i = 0; i \u003c m; i++) {\n            for (int j = 0; j \u003c n; j++) {\n                if (board[i][j] \u003e 1)\n                    board[i][j] -= 2;\n            }\n        }\n    }\n};",
    "id": "10383581",
    "lang": "cpp",
    "memory": "946.2 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 23,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "289",
     "title": "Game of Life",
     "titleSlug": "game-of-life",
     "translatedTitle": "生命游戏"
    },
    "rawMemory": "946176",
    "runtime": "0 ms",
    "sourceUrl": "/problems/game-of-life/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544587858,
    "totalTestCaseCnt": 22
   }
  },
  "generate-parentheses": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\nprivate:\n    unordered_set\u003cstring\u003e gen_set;\npublic:\n    void generateParenthesisDFS(int left, int right, string s, vector\u003cstring\u003e\u0026 res) {\n        if (left \u003e right) return;\n        if (left == 0 \u0026\u0026 right == 0) {\n            res.push_back(s);\n        } else {\n            if (left)\n                generateParenthesisDFS(left - 1, right, s + \"(\", res);\n            if (right)\n                generateParenthesisDFS(left, right - 1, s + \")\", res);\n        }\n    }\n\n    vector\u003cstring\u003e generateParenthesis(int n) {\n        vector\u003cstring\u003e res;\n        if (n \u003c 1) return res;\n        generateParenthesisDFS(n, n, \"\", res);\n        return res;\n    }\n};",
    "id": "10536620",
    "lang": "cpp",
    "memory": "1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 8,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "22",
     "title": "Generate Parentheses",
     "titleSlug": "generate-parentheses",
     "translatedTitle": "括号生成"
    },
    "rawMemory": "1040384",
    "runtime": "0 ms",
    "sourceUrl": "/problems/generate-parentheses/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545008497,
    "totalTestCaseCnt": 8
   }
  },
  "gray-code": {
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def grayCode(self, n: int) -\u003e List[int]: \n        return [i^(i \u003e\u003e 1) for i in range(1 \u003c\u003c n)]",
    "id": "264247759",
    "lang": "python3",
    "memory": "18.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 16,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "89",
     "title": "Gray Code",
     "titleSlug": "gray-code",
     "translatedTitle": "格雷编码"
    },
    "rawMemory": "18884000",
    "runtime": "60 ms",
    "sourceUrl": "/problems/gray-code/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);\n",
     "flagType": "RED"
    },
    "timestamp": 1643785903,
    "totalTestCaseCnt": 16
   }
  },
  "group-anagrams": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cstring\u003e\u003e groupAnagrams(vector\u003cstring\u003e\u0026 strs) {\n        unordered_map\u003cstring, vector\u003cstring\u003e\u003e smap;\n        vector\u003cvector\u003cstring\u003e\u003e res;\n        for (auto \u0026s : strs) {\n            string tmp(s);\n            sort(tmp.begin(), tmp.end());\n            smap[tmp].push_back(s);\n        }\n        for (auto \u0026m : smap) {\n            res.emplace_back(m.second);\n        }\n\n        return res;        \n    }\n};",
    "id": "263624136",
    "lang": "cpp",
    "memory": "19 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 115,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "49",
     "title": "Group Anagrams",
     "titleSlug": "group-anagrams",
     "translatedTitle": "字母异位词分组"
    },
    "rawMemory": "19460000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/group-anagrams/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643509315,
    "totalTestCaseCnt": 115
   }
  },
  "group-shifted-strings": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cstring\u003e\u003e groupStrings(vector\u003cstring\u003e\u0026 strings) {\n        vector\u003cvector\u003cstring\u003e\u003e res;\n        unordered_map\u003cstring, vector\u003cstring\u003e\u003e smap;\n        for (auto\u0026 s : strings) {\n            string tmp(s);\n            std::transform(tmp.begin(), tmp.end(), tmp.begin(), [\u0026s](char c) {\n                return (c - (s[0]-'a') + 26)%26;\n            });\n            smap[tmp].push_back(s); \n        }\n\n        for (auto \u0026p : smap) {\n            res.emplace_back(p.second);\n        }\n        return res;\n    }\n};",
    "id": "263738345",
    "lang": "cpp",
    "memory": "7.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 23,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "249",
     "title": "Group Shifted Strings",
     "titleSlug": "group-shifted-strings",
     "translatedTitle": "移位字符串分组"
    },
    "rawMemory": "7796000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/group-shifted-strings/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643530637,
    "totalTestCaseCnt": 23
   }
  },
  "guess-number-higher-or-lower": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is lower than the guess number\n *\t\t\t      1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */\n\nint guessNumber(int n){\n    int lo = 0, hi = n;\n    while (lo \u003c= hi) {\n        int m = lo + (hi - lo) / 2;\n        int ret = guess(m);\n        if (ret == 1) {\n            lo = m + 1;\n        } else if (ret == -1) {\n            hi = m - 1;\n        } else {\n            return m;\n        }\n    }\n    return -1;\n}",
    "id": "265692630",
    "lang": "c",
    "memory": "5.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 25,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "374",
     "title": "Guess Number Higher or Lower",
     "titleSlug": "guess-number-higher-or-lower",
     "translatedTitle": "猜数字大小"
    },
    "rawMemory": "5604000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/guess-number-higher-or-lower/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644264445,
    "totalTestCaseCnt": 25
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is lower than the guess number\n *\t\t\t      1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */\n\nclass Solution {\npublic:\n    int guessNumber(int n) {\n        int j = 1, k = n;\n        while (j \u003c= n) {\n            int m = j + (k - j)/2;\n            int ret = guess(m);\n            if (ret == 0) {\n                return m;\n            } else if (ret == 1) {\n                j = m + 1;\n            } else if (ret == -1) {\n                k = m - 1;\n            } else {\n                break;\n            }\n        } \n        return -1;\n    }\n};",
    "id": "262524468",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 25,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "374",
     "title": "Guess Number Higher or Lower",
     "titleSlug": "guess-number-higher-or-lower",
     "translatedTitle": "猜数字大小"
    },
    "rawMemory": "5936000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/guess-number-higher-or-lower/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "target 是在这个区间的。",
     "flagType": "RED"
    },
    "timestamp": 1643181300,
    "totalTestCaseCnt": 25
   }
  },
  "guess-numbers": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int game(vector\u003cint\u003e\u0026 guess, vector\u003cint\u003e\u0026 answer) {\n        if (guess.size() != answer.size())\n            return 0;\n        int cnt = 0;\n        for (int i = 0; i \u003c guess.size(); i++) {\n            if (guess[i] == answer[i]) {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n};",
    "id": "31915946",
    "lang": "cpp",
    "memory": "8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 4,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100107",
     "title": "Guess Numbers",
     "titleSlug": "guess-numbers",
     "translatedTitle": "猜数字"
    },
    "rawMemory": "8156000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/guess-numbers/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1570076529,
    "totalTestCaseCnt": 4
   }
  },
  "hamming-distance": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int hammingDistance(int x, int y) {\n    int z = x ^ y;\n    int distance = 0;\n    while (z \u003e 0) {\n        distance += z \u0026 1;\n        z = z \u003e\u003e 1;\n    }\n    return distance;\n}",
    "id": "8288619",
    "lang": "c",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 149,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "461",
     "title": "Hamming Distance",
     "titleSlug": "hamming-distance",
     "translatedTitle": "汉明距离"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/hamming-distance/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539605395,
    "totalTestCaseCnt": 149
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int distance = 0;\n        int z = x ^ y;\n        while (z) {\n            distance += (z \u0026 0x01);\n            z \u003e\u003e= 1;\n        }\n        return distance;              \n    }\n};",
    "id": "293374711",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 149,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "461",
     "title": "Hamming Distance",
     "titleSlug": "hamming-distance",
     "translatedTitle": "汉明距离"
    },
    "rawMemory": "5912000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/hamming-distance/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "先异或，再右移，计算第一位是不是 0",
     "flagType": "RED"
    },
    "timestamp": 1648822254,
    "totalTestCaseCnt": 149
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func hammingDistance(x int, y int) int {\n\tres := 0\n\tz := x ^ y\n\tfor z != 0 {\n\t\tif z\u00261 == 1 {\n\t\t\tres++\n\t\t}\n\t\tz \u003e\u003e= 1\n\t}\n\treturn res\n}\n",
    "id": "179516704",
    "lang": "golang",
    "memory": "1.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 149,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "461",
     "title": "Hamming Distance",
     "titleSlug": "hamming-distance",
     "translatedTitle": "汉明距离"
    },
    "rawMemory": "1996000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/hamming-distance/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621572188,
    "totalTestCaseCnt": 149
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        xor = x ^ y\n        d = 0\n        while xor \u003e 0:\n            d += xor \u0026 1\n            xor \u003e\u003e= 1\n        return d\n        ",
    "id": "8289187",
    "lang": "python3",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 149,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "461",
     "title": "Hamming Distance",
     "titleSlug": "hamming-distance",
     "translatedTitle": "汉明距离"
    },
    "rawMemory": "N/A",
    "runtime": "44 ms",
    "sourceUrl": "/problems/hamming-distance/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539606018,
    "totalTestCaseCnt": 149
   }
  },
  "happy-number": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isHappy(int n) {\n        int next = n;\n        unordered_set\u003cint\u003e seen;\n        \n        while (next != 1) {\n            next = cal(next);\n            if (seen.find(next) != seen.end()) {\n                return false;\n            }\n            seen.insert(next);\n        }\n        return true;\n    }\n                                        \nprivate:                                        \n    int cal(int n) {\n        int res = 0;\n        while (n \u003e 0) {\n            int nn = n % 10;\n            res += nn * nn;                                                                    \n            n = n / 10;\n        }\n        return res;\n    }                                   \n};",
    "id": "196717493",
    "lang": "cpp",
    "memory": "6.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 402,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "202",
     "title": "Happy Number",
     "titleSlug": "happy-number",
     "translatedTitle": "快乐数"
    },
    "rawMemory": "6304000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/happy-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626505600,
    "totalTestCaseCnt": 404
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func isHappy(n int) bool {\n    slow, fast := n, calc(n)\n    // 快慢指针， 如果成环快的一定能追的上慢的\n    for slow != 1 \u0026\u0026 slow != fast {\n        slow = calc(slow) \n        fast = calc(calc(fast))                                    \n    } \n    return fast == 1\n}\n\nfunc calc(n int) int {\n    res := 0\n    for n \u003e 0 {\n        res += (n%10) * (n%10)\n        n = n / 10                                    \n    }\n    return res\n}",
    "id": "196724519",
    "lang": "golang",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 402,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "202",
     "title": "Happy Number",
     "titleSlug": "happy-number",
     "translatedTitle": "快乐数"
    },
    "rawMemory": "2024000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/happy-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626506702,
    "totalTestCaseCnt": 404
   }
  },
  "he-bing-liang-ge-pai-xu-de-lian-biao-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* l3 = \u0026dummy;\n        while (l1 \u0026\u0026 l2) {\n            if (l1-\u003eval \u003e l2-\u003eval) {\n                l3-\u003enext = l2;\n                l2 = l2-\u003enext;\n            } else {\n                l3-\u003enext = l1;\n                l1 = l1-\u003enext;\n            }\n            l3 = l3-\u003enext;\n        }\n        if (l1) {\n            l3-\u003enext = l1;\n        } else if (l2) {\n            l3-\u003enext = l2;\n        }\n        return dummy.next;\n    }\n};",
    "id": "264676020",
    "lang": "cpp",
    "memory": "18.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 218,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100286",
     "title": "合并两个排序的链表  LCOF",
     "titleSlug": "he-bing-liang-ge-pai-xu-de-lian-biao-lcof",
     "translatedTitle": "合并两个排序的链表"
    },
    "rawMemory": "19056000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643953449,
    "totalTestCaseCnt": 218
   }
  },
  "house-robber": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int rob(vector\u003cint\u003e\u0026 nums) {\n        int cnt = nums.size();\n        vector\u003cint\u003e r(cnt, 0);\n\n        if (cnt == 1) return nums[0];\n\n        r[0] = nums[0];\n        r[1] = max(nums[0], nums[1]);\n\n        for (int i = 2; i \u003c cnt; i++) {\n            r[i] = max(r[i-1], r[i-2]+nums[i]);\n        }\n\n        return r[cnt - 1];\n    }\n};",
    "id": "255585211",
    "lang": "cpp",
    "memory": "7.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "198",
     "title": "House Robber",
     "titleSlug": "house-robber",
     "translatedTitle": "打家劫舍"
    },
    "rawMemory": "7760000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/house-robber/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1641453818,
    "totalTestCaseCnt": 68
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func rob(nums []int) int {\n    pre := 0\n    curr := 0\n    for _, n := range nums {\n        tmp := max(curr, pre + n)\n        pre, curr = curr, tmp\n    }\n    return curr\n}\n\nfunc max(a, b int) int {\n    if a \u003e b {\n        return a\n    }\n    return b\n}",
    "id": "255591002",
    "lang": "golang",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "198",
     "title": "House Robber",
     "titleSlug": "house-robber",
     "translatedTitle": "打家劫舍"
    },
    "rawMemory": "2028000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/house-robber/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1641454579,
    "totalTestCaseCnt": 68
   }
  },
  "house-robber-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    //  在不偷窃第一个房子的情况下\n    //  在不偷窃最后一个房子的情况下\n    int rob(vector\u003cint\u003e\u0026 nums) {\n        auto cnt = nums.size();\n        if (cnt == 0) {\n            return 0;\n        } else if (cnt == 1) {\n            return nums[0]; \n        }\n        return max(robRange(nums, 0, cnt - 1), robRange(nums, 1, cnt));\n    }\n\n    int robRange(vector\u003cint\u003e\u0026 nums, int start, int end) {\n        int curr = 0;\n        int pre = 0;\n        for (int i = start; i \u003c end; i++) {\n            auto tmp = max(curr, pre + nums[i]);\n            pre = curr;\n            curr = tmp;\n        }\n        return curr;\n    }\n};",
    "id": "255600153",
    "lang": "cpp",
    "memory": "7.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 75,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "213",
     "title": "House Robber II",
     "titleSlug": "house-robber-ii",
     "translatedTitle": "打家劫舍 II"
    },
    "rawMemory": "7740000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/house-robber-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1641455759,
    "totalTestCaseCnt": 75
   }
  },
  "house-robber-iii": {
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rob(self, root: TreeNode) -\u003e int:\n        def rob_(root):\n            if root == None:\n                return 0, 0\n            ls, ln = rob_(root.left)\n            rs, rn = rob_(root.right)\n            return root.val + ln + rn, max(ls, ln) + max(rs, rn)\n\n        return max(rob_(root))    \n",
    "id": "255632837",
    "lang": "python3",
    "memory": "17 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 124,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "337",
     "title": "House Robber III",
     "titleSlug": "house-robber-iii",
     "translatedTitle": "打家劫舍 III"
    },
    "rawMemory": "17408000",
    "runtime": "44 ms",
    "sourceUrl": "/problems/house-robber-iii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1641459659,
    "totalTestCaseCnt": 124
   }
  },
  "iIQa4I": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e dailyTemperatures(vector\u003cint\u003e\u0026 temperatures) {\n        vector\u003cint\u003e res(temperatures.size());\n        \n        stack\u003cint\u003e st;\n        for (int i = 0; i \u003c temperatures.size(); i++) {\n            while (!st.empty() \u0026\u0026 temperatures[st.top()] \u003c temperatures[i]) {\n                res[st.top()] = i - st.top();\n                st.pop();\n            }\n            st.push(i);\n        }\n\n        return res;\n    }\n};",
    "id": "265959793",
    "lang": "cpp",
    "memory": "86.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000282",
     "title": "每日温度",
     "titleSlug": "iIQa4I",
     "translatedTitle": "每日温度"
    },
    "rawMemory": "88904000",
    "runtime": "132 ms",
    "sourceUrl": "/problems/iIQa4I/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644323827,
    "totalTestCaseCnt": 47
   }
  },
  "image-smoother": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e imageSmoother(vector\u003cvector\u003cint\u003e\u003e\u0026 M) {\n        if(M.empty()) return vector\u003cvector\u003cint\u003e\u003e();\n        vector\u003cvector\u003cint\u003e\u003e result(M.size(), vector\u003cint\u003e(M[0].size(),0));\n        vector\u003cpair\u003cint,int\u003e\u003e dir({{-1,-1}, {0,-1}, {1,-1}, {-1,0}, {0,0}, {1,0}, {-1,1}, {0,1}, {1,1}});\n        for(int i=0; i\u003cM.size(); i++) {\n            for(int j=0; j\u003cM[0].size(); j++) {\n                int nume = 0, deno = 0;\n                for(const auto\u0026 d:dir) {\n                    int ii = i+d.first, jj = j+d.second;\n                    if(ii\u003e=0 \u0026\u0026 ii\u003cM.size() \u0026\u0026 jj\u003e=0 \u0026\u0026 jj\u003cM[0].size()) {\n                        deno++;\n                        nume+=M[ii][jj];\n                    }\n                }\n                result[i][j]=nume/deno;\n            }\n        }\n        return result;\n    }\n};",
    "id": "8384145",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 202,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "661",
     "title": "Image Smoother",
     "titleSlug": "image-smoother",
     "translatedTitle": "图片平滑器"
    },
    "rawMemory": "N/A",
    "runtime": "140 ms",
    "sourceUrl": "/problems/image-smoother/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539787672,
    "totalTestCaseCnt": 203
   }
  },
  "implement-queue-using-stacks": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        rswapStack();\n        if (s2.empty()) {\n           throw \"empty queue\";\n        }\n        int head = s2.top();\n        s2.pop();\n        return head;\n    }\n    \n    int peek() {\n        rswapStack();\n        if (s2.empty()) {\n           throw \"empty queue\";\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() \u0026\u0026 s2.empty();\n    }\nprivate:\n    std::stack\u003cint\u003e s1;\n    std::stack\u003cint\u003e s2;\n\n    inline void rswapStack() {\n        if (!s2.empty()) return;\n        while (!s1.empty()) {\n            s2.push(s1.top());\n            s1.pop();\n        }\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj-\u003epush(x);\n * int param_2 = obj-\u003epop();\n * int param_3 = obj-\u003epeek();\n * bool param_4 = obj-\u003eempty();\n */",
    "id": "257031087",
    "lang": "cpp",
    "memory": "6.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "232",
     "title": "Implement Queue using Stacks",
     "titleSlug": "implement-queue-using-stacks",
     "translatedTitle": "用栈实现队列"
    },
    "rawMemory": "7012000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/implement-queue-using-stacks/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1641816765,
    "totalTestCaseCnt": 21
   }
  },
  "implement-stack-using-queues": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class MyStack {\npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n\n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        list_.push_back(x);\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int top = list_.back();\n        list_.pop_back();\n        return top;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        return list_.back();\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return list_.empty();\n    }\nprivate:\n    list\u003cint\u003e list_;\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj-\u003epush(x);\n * int param_2 = obj-\u003epop();\n * int param_3 = obj-\u003etop();\n * bool param_4 = obj-\u003eempty();\n */",
    "id": "205644542",
    "lang": "cpp",
    "memory": "6.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 16,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "225",
     "title": "Implement Stack using Queues",
     "titleSlug": "implement-stack-using-queues",
     "translatedTitle": "用队列实现栈"
    },
    "rawMemory": "6812000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/implement-stack-using-queues/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1628651695,
    "totalTestCaseCnt": 16
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "type MyStack struct {\n    Stack []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyStack {\n    return MyStack{\n        Stack: make([]int, 0, 100),\n    }\n}\n\n\n/** Push element x onto stack. */\nfunc (this *MyStack) Push(x int)  {\n    this.Stack = append(this.Stack, x)\n}\n\n\n/** Removes the element on top of the stack and returns that element. */\nfunc (this *MyStack) Pop() int {\n    top := this.Top()\n    this.Stack = this.Stack[:len(this.Stack) - 1]\n    return top\n}\n\n\n/** Get the top element. */\nfunc (this *MyStack) Top() int {\n    return this.Stack[len(this.Stack) - 1]\n}\n\n\n/** Returns whether the stack is empty. */\nfunc (this *MyStack) Empty() bool {\n    return len(this.Stack) == 0\n}\n\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.Empty();\n */",
    "id": "205647873",
    "lang": "golang",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 16,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "225",
     "title": "Implement Stack using Queues",
     "titleSlug": "implement-stack-using-queues",
     "translatedTitle": "用队列实现栈"
    },
    "rawMemory": "2004000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/implement-stack-using-queues/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1628652067,
    "totalTestCaseCnt": 16
   }
  },
  "implement-strstr": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle.size() \u003e haystack.size())\n            return -1;\n\n        for(int i = 0 ; i \u003c= haystack.size() - needle.size() ; i ++){\n            int j = 0;\n            for(j = 0 ; j \u003c needle.size() ; j ++)\n                if(needle[j] != haystack[j + i])\n                    break;\n            if(j == needle.size())\n                return i;\n        }\n        return -1;\n    }\n};",
    "id": "9634808",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 74,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "28",
     "title": "Implement strStr()",
     "titleSlug": "implement-strstr",
     "translatedTitle": "实现 strStr()"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/implement-strstr/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1542817847,
    "totalTestCaseCnt": 75
   }
  },
  "implement-trie-prefix-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Trie {\nprivate:\n    struct TrieNode {\n        uint32_t chr;\n        bool end;\n        map\u003cuint32_t, TrieNode*\u003e children;\n\n        TrieNode(uint32_t c) {\n            chr = c;\n            end = false;\n        }\n        \n        TrieNode* findChild(uint32_t c) {\n            auto it = children.find(c);\n            if (it == children.end()) {\n                return nullptr;\n            }\n            return it-\u003esecond; \n        }\n\n        void insertChild(uint32_t c, TrieNode* node) {\n            children[c] = node;\n        }\n    };\n\npublic:\n    Trie() : root_(-1){\n\n    }\n    \n    void insert(string word) {\n        TrieNode* node = \u0026root_;\n        for (auto c: word) {\n            auto curr = node-\u003efindChild(c);\n            if (curr == nullptr) {\n                curr = new TrieNode(c);\n                node-\u003einsertChild(c, curr);           \n            }\n            node = curr;  \n        }\n        node-\u003eend = true;\n    }\n    \n    bool search(string word) {\n        TrieNode* node = \u0026root_;\n        for (auto c : word) {\n            node = node-\u003efindChild(c);\n            if (node == nullptr) {\n                return false;\n            }\n        }\n        return node-\u003eend;\n    }\n    \n    bool startsWith(string prefix) {\n        TrieNode* node = \u0026root_;\n        for (auto c : prefix) {\n            node = node-\u003efindChild(c);\n            if (node == nullptr) {\n                return false;\n            }\n        }\n        return true;\n    }\nprivate:\n    TrieNode root_;\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj-\u003einsert(word);\n * bool param_2 = obj-\u003esearch(word);\n * bool param_3 = obj-\u003estartsWith(prefix);\n */",
    "id": "261085911",
    "lang": "cpp",
    "memory": "33.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 15,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "208",
     "title": "Implement Trie (Prefix Tree)",
     "titleSlug": "implement-trie-prefix-tree",
     "translatedTitle": "实现 Trie (前缀树)"
    },
    "rawMemory": "33964000",
    "runtime": "56 ms",
    "sourceUrl": "/problems/implement-trie-prefix-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642794678,
    "totalTestCaseCnt": 15
   }
  },
  "insert-into-a-sorted-circular-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n        next = NULL;\n    }\n\n    Node(int _val, Node* _next) {\n        val = _val;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* insert(Node* head, int insertVal) {\n        if (head == nullptr) {\n            head = new Node(insertVal);\n            head-\u003enext = head;\n            return head;\n        }\n        Node* curr = head;\n        while (curr-\u003enext != head) {\n            if (curr-\u003eval \u003c= insertVal \u0026\u0026 insertVal \u003c= curr-\u003enext-\u003eval) {\n                break;\n            }\n            if (curr-\u003eval \u003e curr-\u003enext-\u003eval) {\n                if (curr-\u003eval \u003c= insertVal || curr-\u003enext-\u003eval \u003e= insertVal) {\n                    break;\n                }\n            }\n            curr = curr-\u003enext;\n        }\n        Node* node = new Node(insertVal, curr-\u003enext);\n        curr-\u003enext = node;\n        return head;\n    }\n};",
    "id": "265036047",
    "lang": "cpp",
    "memory": "8.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 108,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "850",
     "title": "Insert into a Sorted Circular Linked List",
     "titleSlug": "insert-into-a-sorted-circular-linked-list",
     "translatedTitle": "循环有序列表的插入"
    },
    "rawMemory": "8308000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/insert-into-a-sorted-circular-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644074114,
    "totalTestCaseCnt": 108
   }
  },
  "insertion-sort-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        if (head == nullptr) {\n            return head;\n        }\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead-\u003enext = head;\n        ListNode* lastSorted = head;\n        ListNode* curr = head-\u003enext;\n        while (curr != nullptr) {\n            if (lastSorted-\u003eval \u003c= curr-\u003eval) {\n                lastSorted = lastSorted-\u003enext;\n            } else {\n                ListNode *prev = dummyHead;\n                while (prev-\u003enext-\u003eval \u003c= curr-\u003eval) {\n                    prev = prev-\u003enext;\n                }\n                lastSorted-\u003enext = curr-\u003enext;\n                curr-\u003enext = prev-\u003enext;\n                prev-\u003enext = curr;\n            }\n            curr = lastSorted-\u003enext;\n        }\n        return dummyHead-\u003enext;\n    }\n};\n\n",
    "id": "264153166",
    "lang": "cpp",
    "memory": "9.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 19,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "147",
     "title": "Insertion Sort List",
     "titleSlug": "insertion-sort-list",
     "translatedTitle": "对链表进行插入排序"
    },
    "rawMemory": "9636000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/insertion-sort-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643730466,
    "totalTestCaseCnt": 19
   }
  },
  "integer-break": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        vector\u003cint\u003ememo(n + 1, 1);\n        for (int i = 3; i \u003c= n; i++) {\n            for (int j = 1; j \u003c i; j++) {\n                int max_tmp = max(j * (i - j), j * memo[i - j]);\n                memo[i] = max(memo[i], max_tmp);\n            }\n        }\n        return memo[n];\n    }\n};",
    "id": "10328622",
    "lang": "cpp",
    "memory": "831.5 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 50,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "343",
     "title": "Integer Break",
     "titleSlug": "integer-break",
     "translatedTitle": "整数拆分"
    },
    "rawMemory": "831488",
    "runtime": "0 ms",
    "sourceUrl": "/problems/integer-break/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544447742,
    "totalTestCaseCnt": 50
   }
  },
  "intersection-of-two-arrays": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e intersection(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) {\n        unordered_set\u003cint\u003e n1(nums1.begin(), nums1.end());\n        unordered_set\u003cint\u003e n2(nums2.begin(), nums2.end());\n        vector\u003cint\u003e ret;\n\n        for (auto c : n2) {\n            if (n1.find(c) != n1.end()) {\n                ret.push_back(c);\n            }\n        }\n        return ret;\n    }\n};",
    "id": "10122190",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "349",
     "title": "Intersection of Two Arrays",
     "titleSlug": "intersection-of-two-arrays",
     "translatedTitle": "两个数组的交集"
    },
    "rawMemory": "N/A",
    "runtime": "16 ms",
    "sourceUrl": "/problems/intersection-of-two-arrays/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543990572,
    "totalTestCaseCnt": 55
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func intersection(nums1 []int, nums2 []int) []int {\n\tnumMap1 := make(map[int]struct{})\n\tresMap := make(map[int]struct{})\n\tvar res []int\n\tfor _, n := range nums1 {\n\t\tnumMap1[n] = struct{}{}\n\t}\n\tfor _, n := range nums2 {\n\t\tif _, e := numMap1[n]; e {\n\t\t\tif _, e := resMap[n]; !e {\n\t\t\t\tres = append(res, n)\n\t\t\t\tresMap[n] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n",
    "id": "180113619",
    "lang": "golang",
    "memory": "3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 55,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "349",
     "title": "Intersection of Two Arrays",
     "titleSlug": "intersection-of-two-arrays",
     "translatedTitle": "两个数组的交集"
    },
    "rawMemory": "3120000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/intersection-of-two-arrays/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621759529,
    "totalTestCaseCnt": 55
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        a = set(nums1)\n        b = set(nums2)\n        c = a \u0026 b\n        return list(c)\n        ",
    "id": "10122224",
    "lang": "python3",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "349",
     "title": "Intersection of Two Arrays",
     "titleSlug": "intersection-of-two-arrays",
     "translatedTitle": "两个数组的交集"
    },
    "rawMemory": "N/A",
    "runtime": "60 ms",
    "sourceUrl": "/problems/intersection-of-two-arrays/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543990638,
    "totalTestCaseCnt": 55
   }
  },
  "intersection-of-two-arrays-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e intersect(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) {\n\n        multiset\u003cint\u003e record;\n        for(int num: nums1)\n            record.insert(num);\n\n        multiset\u003cint\u003e result;\n        for(int num: nums2){\n            multiset\u003cint\u003e::iterator iter = record.find(num);\n            if( iter != record.end()){\n                result.insert(num);\n                record.erase(iter);\n            }\n        }\n\n        return vector\u003cint\u003e(result.begin(), result.end());\n    }\n};",
    "id": "10129278",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "350",
     "title": "Intersection of Two Arrays II",
     "titleSlug": "intersection-of-two-arrays-ii",
     "translatedTitle": "两个数组的交集 II"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/intersection-of-two-arrays-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543996651,
    "totalTestCaseCnt": 56
   }
  },
  "intersection-of-two-linked-lists": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\n        ListNode* pA = headA;\n        ListNode* pB = headB;\n        while(pA || pB){\n\n            if(pA == pB)\n                return pA;\n\n            if(pA) pA = pA-\u003enext;\n            else pA = headB;\n\n            if(pB) pB = pB-\u003enext;\n            else pB = headA;\n        }\n\n        return NULL;\n    }\n};",
    "id": "10197839",
    "lang": "cpp",
    "memory": "2.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 42,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "160",
     "title": "Intersection of Two Linked Lists",
     "titleSlug": "intersection-of-two-linked-lists",
     "translatedTitle": "相交链表"
    },
    "rawMemory": "2412544",
    "runtime": "28 ms",
    "sourceUrl": "/problems/intersection-of-two-linked-lists/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544116938,
    "totalTestCaseCnt": 39
   }
  },
  "invert-binary-tree": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* invertTree(struct TreeNode* root){\n    if (root == NULL) return root;\n    invertTree(root-\u003eleft);\n    invertTree(root-\u003eright);\n    struct TreeNode* tmp;\n    tmp = root-\u003eleft;\n    root-\u003eleft = root-\u003eright;\n    root-\u003eright = tmp;\n    return root;\n}",
    "id": "265185444",
    "lang": "c",
    "memory": "5.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 77,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "226",
     "title": "Invert Binary Tree",
     "titleSlug": "invert-binary-tree",
     "translatedTitle": "翻转二叉树"
    },
    "rawMemory": "5832000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/invert-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644131415,
    "totalTestCaseCnt": 77
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == nullptr) return nullptr;\n        std::queue\u003cTreeNode*\u003e q;\n        q.push(root);\n        while (!q.empty()) {\n            auto node = q.front();\n            q.pop();\n            std::swap(node-\u003eright, node-\u003eleft);\n            if (node-\u003eright) q.push(node-\u003eright);\n            if (node-\u003eleft) q.push(node-\u003eleft);\n        }\n        return root;\n    }\n};",
    "id": "276894042",
    "lang": "cpp",
    "memory": "9.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 77,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "226",
     "title": "Invert Binary Tree",
     "titleSlug": "invert-binary-tree",
     "translatedTitle": "翻转二叉树"
    },
    "rawMemory": "9636000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/invert-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646323675,
    "totalTestCaseCnt": 77
   }
  },
  "is-subsequence": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "bool isSubsequence(char * s, char * t){\n    while (*s \u0026\u0026 *t) s += (*s == *t++);\n    return !*s;\n}",
    "id": "266311428",
    "lang": "c",
    "memory": "5.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 17,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "392",
     "title": "Is Subsequence",
     "titleSlug": "is-subsequence",
     "translatedTitle": "判断子序列"
    },
    "rawMemory": "5544000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/is-subsequence/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644401449,
    "totalTestCaseCnt": 17
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int index = 0;\n        for (auto c : t) {\n            if (index \u003c s.size() \u0026\u0026 c == s[index]) {\n                index++;\n            }\n        }\n        return index == s.size();\n    }\n};",
    "id": "266356892",
    "lang": "cpp",
    "memory": "6.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 17,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "392",
     "title": "Is Subsequence",
     "titleSlug": "is-subsequence",
     "translatedTitle": "判断子序列"
    },
    "rawMemory": "6400000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/is-subsequence/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644410011,
    "totalTestCaseCnt": 17
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func isSubsequence(s string, t string) bool {\n    m, n := len(s), len(t)\n    dp := make([][]int, m+1)\n    for i := 0; i \u003c= m; i++ {\n        dp[i] = make([]int, n+1)\n    }\n\n    for i := 1; i \u003c= m; i++ {\n        for j := 1; j \u003c= n; j++ {\n            if s[i-1] == t[j-1] {\n                dp[i][j] = dp[i-1][j-1] + 1\n            } else {\n                dp[i][j] = dp[i][j-1]\n            }\n        }\n    }\n    return dp[m][n] == len(s)\n}",
    "id": "261735158",
    "lang": "golang",
    "memory": "4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 17,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "392",
     "title": "Is Subsequence",
     "titleSlug": "is-subsequence",
     "translatedTitle": "判断子序列"
    },
    "rawMemory": "4048000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/is-subsequence/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "dp 算法",
     "flagType": "RED"
    },
    "timestamp": 1642958892,
    "totalTestCaseCnt": 17
   }
  },
  "is-unique-lcci": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isUnique(string astr) {\n        bool e[256] = {false,};\n        for (auto\u0026 c : astr) {\n            if (e[c]) {\n                return false;\n            }\n            e[c] = true;\n        }\n        return  true;\n    }\n};",
    "id": "262289924",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 17,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100158",
     "title": "Is Unique LCCI",
     "titleSlug": "is-unique-lcci",
     "translatedTitle": "判定字符是否唯一"
    },
    "rawMemory": "5896000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/is-unique-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643108946,
    "totalTestCaseCnt": 17
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func isUnique(astr string) bool {\n    var mask uint32\n    for i := range astr {\n        bitN := uint32(1 \u003c\u003c int(astr[i] - 'a'))\n        if bitN \u0026 mask \u003e 0 {\n            return false\n        }\n        mask |= bitN\n    }\n    return true\n}",
    "id": "197210820",
    "lang": "golang",
    "memory": "1.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 17,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100158",
     "title": "Is Unique LCCI",
     "titleSlug": "is-unique-lcci",
     "translatedTitle": "判定字符是否唯一"
    },
    "rawMemory": "1920000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/is-unique-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626623213,
    "totalTestCaseCnt": 17
   }
  },
  "isomorphic-strings": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        int c1[256] = {0};\n        int c2[256] = {0};\n        \n        if (s.size() != t.size()) {\n            return false;\n        }\n\n        for (int i = 0; i \u003c s.size(); i++) {\n            if (c1[s[i]] != c2[t[i]]) {\n                return false;\n            }\n            c1[s[i]] = i + 1;\n            c2[t[i]] = i + 1;\n        }\n\n        return true;\n    }\n};",
    "id": "196823644",
    "lang": "cpp",
    "memory": "6.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "205",
     "title": "Isomorphic Strings",
     "titleSlug": "isomorphic-strings",
     "translatedTitle": "同构字符串"
    },
    "rawMemory": "7040000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/isomorphic-strings/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626524614,
    "totalTestCaseCnt": 43
   }
  },
  "jBjn9C": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class KthLargest {\npublic:\n    KthLargest(int k, vector\u003cint\u003e\u0026 nums) {\n        k_ = k;\n        for (auto n : nums) {\n            add(n);\n        }\n    }\n    \n    int add(int val) {\n        if (pq_.size() \u003c k_) {\n            pq_.push(val);\n        } else {\n            if (pq_.top() \u003c val) {\n                pq_.pop();\n                pq_.push(val);\n            }\n        }\n        return pq_.top();\n    }\nprivate:\n    int k_;\n    std::priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e pq_;\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj-\u003eadd(val);\n */",
    "id": "277910368",
    "lang": "cpp",
    "memory": "19.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 10,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000323",
     "title": "数据流的第 K 大数值",
     "titleSlug": "jBjn9C",
     "translatedTitle": "数据流的第 K 大数值"
    },
    "rawMemory": "19692000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/jBjn9C/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "优先队列",
     "flagType": "BLUE"
    },
    "timestamp": 1646491422,
    "totalTestCaseCnt": 10
   }
  },
  "jump-game": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool canJump(vector\u003cint\u003e\u0026 nums) {\n        int far_most = 0;\n        for (int i = 0; i \u003c nums.size(); i++) {\n            if (far_most \u003c i) \n                return false;\n            if (nums[i] + i \u003e far_most) {\n                far_most = nums[i] + i;\n            }\n            if (far_most \u003e= nums.size() - 1)\n                return true;\n        }\n        return far_most \u003e= nums.size() - 1;\n    }\n};",
    "id": "268804350",
    "lang": "cpp",
    "memory": "47.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 169,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "55",
     "title": "Jump Game",
     "titleSlug": "jump-game",
     "translatedTitle": "跳跃游戏"
    },
    "rawMemory": "48416000",
    "runtime": "44 ms",
    "sourceUrl": "/problems/jump-game/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644935888,
    "totalTestCaseCnt": 170
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def canJump(self, nums: List[int]) -\u003e bool:\n        n, far_most = len(nums), 0\n        for i in range(n):\n            if i \u003c= far_most:\n                far_most = max(far_most, i + nums[i])\n                if far_most + 1 \u003e= len(nums):\n                    return True\n            else:\n                break\n        return False",
    "id": "263042520",
    "lang": "python3",
    "memory": "16.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 169,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "55",
     "title": "Jump Game",
     "titleSlug": "jump-game",
     "translatedTitle": "跳跃游戏"
    },
    "rawMemory": "16564000",
    "runtime": "96 ms",
    "sourceUrl": "/problems/jump-game/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643313696,
    "totalTestCaseCnt": 170
   }
  },
  "kill-process": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e killProcess(vector\u003cint\u003e\u0026 pid, vector\u003cint\u003e\u0026 ppid, int kill) {\n        vector\u003cint\u003e res;\n        unordered_map\u003cint, vector\u003cint\u003e\u003e children_map;\n        for (int i = 0; i \u003c pid.size(); i++) {\n            int _pid = pid[i];\n            int _ppid = ppid[i];\n            children_map[_ppid].push_back(_pid);\n        }\n\n        dfsKill(kill, children_map, res);\n        return res;\n    }\n\n    void dfsKill(int kill, unordered_map\u003cint, vector\u003cint\u003e\u003e\u0026 cmap, vector\u003cint\u003e\u0026 res) {\n        res.push_back(kill);\n        vector\u003cint\u003e\u0026 children_pid = cmap[kill];\n        for (auto\u0026 cpid : children_pid) {\n            dfsKill(cpid, cmap, res);\n        }\n    }\n};",
    "id": "265242592",
    "lang": "cpp",
    "memory": "65.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 166,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "582",
     "title": "Kill Process",
     "titleSlug": "kill-process",
     "translatedTitle": "杀掉进程"
    },
    "rawMemory": "67292000",
    "runtime": "108 ms",
    "sourceUrl": "/problems/kill-process/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "DFS",
     "flagType": "GREEN"
    },
    "timestamp": 1644143553,
    "totalTestCaseCnt": 166
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func killProcess(pid []int, ppid []int, kill int) []int {\n    cmap := make(map[int][]int)\n    for i, _pid := range pid {\n        _ppid := ppid[i]\n        cmap[_ppid] = append(cmap[_ppid], _pid)\n    }\n    res := []int{}\n    queue := []int{}\n    queue = append(queue, kill)\n\n    for len(queue) \u003e 0 {\n        headPid := queue[0]\n        queue = queue[1:]\n        res = append(res, headPid)\n        \n        _pids := cmap[headPid]\n        for j := 0; j \u003c len(_pids); j++ {\n            queue = append(queue, _pids[j])\n        }\n    }\n    return res;\n}",
    "id": "265249139",
    "lang": "golang",
    "memory": "7.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 166,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "582",
     "title": "Kill Process",
     "titleSlug": "kill-process",
     "translatedTitle": "杀掉进程"
    },
    "rawMemory": "8016000",
    "runtime": "52 ms",
    "sourceUrl": "/problems/kill-process/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "BFS。变量覆盖照成 BUG。。。。。",
     "flagType": "GREEN"
    },
    "timestamp": 1644145542,
    "totalTestCaseCnt": 166
   }
  },
  "kth-largest-element-in-a-stream": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class KthLargest {\npublic:\n    KthLargest(int k, vector\u003cint\u003e\u0026 nums) : k_(k) {\n        for (auto num : nums) {\n            add(num);\n        }\n    }\n    \n    int add(int val) {\n        pq_.push(val);\n        if (pq_.size() \u003e k_) {\n            pq_.pop();\n        }\n        // if (pq_.size() \u003c k_) {\n        //     pq_.push(val);\n        // } else {\n        //     if (val \u003e pq_.top()) {\n        //         pq_.pop();\n        //         pq_.push(val);\n        //     }\n        // }\n        return pq_.top();\n    }\nprivate:\n    int k_;\n    priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e pq_;\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj-\u003eadd(val);\n */",
    "id": "266510569",
    "lang": "cpp",
    "memory": "19.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 10,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "789",
     "title": "Kth Largest Element in a Stream",
     "titleSlug": "kth-largest-element-in-a-stream",
     "translatedTitle": "数据流中的第 K 大元素"
    },
    "rawMemory": "19808000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/kth-largest-element-in-a-stream/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OK",
     "flagType": "BLUE"
    },
    "timestamp": 1644460245,
    "totalTestCaseCnt": 10
   }
  },
  "kth-largest-element-in-an-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\nprivate:\n    int FindKthLargest_(vector\u003cint\u003e \u0026nums, int k,  int l, int r) {\n        if (l \u003e= r) {\n            return nums[l];\n        }\n\n        int p = Partition(nums, l, r);\n        if (p \u003c k) {\n            return FindKthLargest_(nums, k, p + 1, r);\n        } else if (p \u003e k) {\n            return FindKthLargest_(nums, k, l, p - 1);\n        } else {\n            return nums[p];\n        }\n    }\n    \n    int Partition(vector\u003cint\u003e \u0026nums, int l, int r) {\n        int ri = random() % (r - l) + l;\n        std::swap(nums[l], nums[ri]);\n\n        int pv = nums[l];\n        int p = l;\n\n        for (int i = l + 1; i \u003c= r; i++) {\n            if (nums[i] \u003e pv) {\n                std::swap(nums[++p], nums[i]);\n            }\n        }\n        std::swap(nums[p], nums[l]);\n        return p;\n    }\n    \npublic:\n    int findKthLargest(vector\u003cint\u003e \u0026nums, int k) {\n        int r = FindKthLargest_(nums, k - 1, 0, nums.size() - 1);\n        return r;\n    }\n};",
    "id": "265336347",
    "lang": "cpp",
    "memory": "9.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 32,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "215",
     "title": "Kth Largest Element in an Array",
     "titleSlug": "kth-largest-element-in-an-array",
     "translatedTitle": "数组中的第K个最大元素"
    },
    "rawMemory": "10076000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/kth-largest-element-in-an-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644169351,
    "totalTestCaseCnt": 32
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "// 降序\nfunc partioin(nums []int, l int,  r int) int {\n    ri := rand.Intn(r-l) % (r-l) + l\n    nums[ri], nums[l] = nums[l],nums[ri]\n    pv := nums[l]\n\n    i, j := l + 1, r\n    for {\n        for nums[i] \u003e pv \u0026\u0026 i \u003c r {\n            i++\n        }\n        for nums[j] \u003c pv \u0026\u0026 j \u003e l {\n            j--\n        }\n\n        if i \u003e= j {\n            break\n        }\n        \n        nums[i], nums[j] = nums[j], nums[i]\n        i++\n        j--\n    }\n    nums[l], nums[j] = nums[j], nums[l]\n    return j\n}\n\nfunc findKthLargest0(nums []int, k, l, r int) int {\n    if l == r {\n        return nums[k]\n    }\n\n    p := partioin(nums, l, r)\n    if (p \u003e k) {\n        return findKthLargest0(nums, k, l, p - 1)\n    } else if (p \u003c k) {\n        return findKthLargest0(nums, k, p + 1, r)\n    } else {\n        return nums[p]\n    }\n}\n\n\nfunc findKthLargest(nums []int, k int) int {\n    return findKthLargest0(nums, k-1, 0, len(nums) - 1)\n}",
    "id": "265336969",
    "lang": "golang",
    "memory": "3.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 32,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "215",
     "title": "Kth Largest Element in an Array",
     "titleSlug": "kth-largest-element-in-an-array",
     "translatedTitle": "数组中的第K个最大元素"
    },
    "rawMemory": "3416000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/kth-largest-element-in-an-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644170148,
    "totalTestCaseCnt": 32
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -\u003e int:\n        def partition(nums, l, r) -\u003e int:\n            xx = random.randint(l, r)\n            nums[xx], nums[l] = nums[l], nums[xx]\n \n            p = l + 1\n            for index in range(l+1, r+1):\n                # 降序排序，如果发现大的就交换\n                if nums[index] \u003e nums[l]:\n                    nums[p], nums[index] = nums[index], nums[p]\n                    p = p + 1\n            # 这块要注意啊，是 p - 1\n            nums[p - 1], nums[l] = nums[l], nums[p -1]\n            return p-1\n\n    \n        def findKth(nums, l, r, k) -\u003e int:\n            if l == r:\n                return nums[l]\n\n            p = partition(nums, l, r)                \n            if p \u003e k :\n                return findKth(nums, l, p-1, k)\n            elif p \u003c k :\n                return findKth(nums, p+1, r, k)\n            return nums[k]\n\n\n        return findKth(nums, 0, len(nums)-1, k -1)\n\n        \n\n    ",
    "id": "234883330",
    "lang": "python3",
    "memory": "15.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 32,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "215",
     "title": "Kth Largest Element in an Array",
     "titleSlug": "kth-largest-element-in-an-array",
     "translatedTitle": "数组中的第K个最大元素"
    },
    "rawMemory": "15700000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/kth-largest-element-in-an-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635868490,
    "totalTestCaseCnt": 32
   }
  },
  "kth-node-from-end-of-list-lcci": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int kthToLast(ListNode* head, int k) {\n        ListNode* n1 = head, *n2 = head;\n        int i = 0;\n        for (; i \u003c k \u0026\u0026 n1 != nullptr; i++) {\n            n1 = n1-\u003enext;\n        }\n        if (n1 == nullptr \u0026\u0026 i \u003c k) {\n            return -1;\n        }\n        while (n1) {\n            n1 = n1-\u003enext;\n            n2 = n2-\u003enext;\n        }\n        return n2-\u003eval;\n    }\n};",
    "id": "264680105",
    "lang": "cpp",
    "memory": "10.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000007",
     "title": "Kth Node From End of List LCCI",
     "titleSlug": "kth-node-from-end-of-list-lcci",
     "translatedTitle": "返回倒数第 k 个节点"
    },
    "rawMemory": "10440000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/kth-node-from-end-of-list-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643954845,
    "totalTestCaseCnt": 208
   },
   "python": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def kthToLast(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        node_list = []\n        while head:\n            node_list.append(head.val)\n            head = head.next\n        return node_list[-k]",
    "id": "264680644",
    "lang": "python",
    "memory": "13.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000007",
     "title": "Kth Node From End of List LCCI",
     "titleSlug": "kth-node-from-end-of-list-lcci",
     "translatedTitle": "返回倒数第 k 个节点"
    },
    "rawMemory": "13448000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/kth-node-from-end-of-list-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643955022,
    "totalTestCaseCnt": 208
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def kthToLast(self, head: ListNode, k: int) -\u003e int:\n        node_list = []\n        while head:\n            node_list.append(head.val)\n            head = head.next\n        return node_list[-k]",
    "id": "264680812",
    "lang": "python3",
    "memory": "14.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000007",
     "title": "Kth Node From End of List LCCI",
     "titleSlug": "kth-node-from-end-of-list-lcci",
     "translatedTitle": "返回倒数第 k 个节点"
    },
    "rawMemory": "15220000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/kth-node-from-end-of-list-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643955079,
    "totalTestCaseCnt": 208
   }
  },
  "kth-smallest-element-in-a-bst": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nint kthSmallest(struct TreeNode* root, int k){\n    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);\n    size_t stack_index = 0;\n    int val = 0;\n\n    struct TreeNode* node = root;\n    while (node != NULL || stack_index != 0) {\n        while (node != NULL) {\n            stack[stack_index++] = node;\n            node = node-\u003eleft;\n        }\n        // 是 --stack_index 不是 stack_index--\n        node = stack[--stack_index];\n        if (--k == 0) {\n            val = node-\u003eval;\n            break;\n        }\n        node = node-\u003eright;\n    }\n\n    free(stack);\n    return val;\n}",
    "id": "263790215",
    "lang": "c",
    "memory": "11.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "230",
     "title": "Kth Smallest Element in a BST",
     "titleSlug": "kth-smallest-element-in-a-bst",
     "translatedTitle": "二叉搜索树中第K小的元素"
    },
    "rawMemory": "12044000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/kth-smallest-element-in-a-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "--index 和 index--",
     "flagType": "RED"
    },
    "timestamp": 1643545361,
    "totalTestCaseCnt": 93
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        std::vector\u003cTreeNode*\u003e stack;\n        while (root || !stack.empty()) {\n            while (root) {\n                stack.push_back(root);\n                root = root-\u003eleft;\n            }\n            root = stack.back();\n            stack.pop_back();\n            if (--k == 0) {\n                return root-\u003eval;\n            }\n            root = root-\u003eright;\n        }\n        return -1;\n    }\n};",
    "id": "263790983",
    "lang": "cpp",
    "memory": "23.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "230",
     "title": "Kth Smallest Element in a BST",
     "titleSlug": "kth-smallest-element-in-a-bst",
     "translatedTitle": "二叉搜索树中第K小的元素"
    },
    "rawMemory": "24084000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/kth-smallest-element-in-a-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "简洁",
     "flagType": "RED"
    },
    "timestamp": 1643545592,
    "totalTestCaseCnt": 93
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc kthSmallest(root *TreeNode, k int) int {\n    stack := make([]*TreeNode, 0)\n    for root != nil || len(stack) \u003e 0 {\n        for root != nil {\n            stack = append(stack, root)\n            root = root.Left\n        }\n        root = stack[len(stack)-1]\n        stack = stack[0:len(stack)-1]\n        k--\n        if k == 0 {\n            return root.Val\n        }\n        root = root.Right\n    }\n    return 0\n}",
    "id": "263794730",
    "lang": "golang",
    "memory": "6.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "230",
     "title": "Kth Smallest Element in a BST",
     "titleSlug": "kth-smallest-element-in-a-bst",
     "translatedTitle": "二叉搜索树中第K小的元素"
    },
    "rawMemory": "6300000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/kth-smallest-element-in-a-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "还是不能一次通过！！！！",
     "flagType": "RED"
    },
    "timestamp": 1643546683,
    "totalTestCaseCnt": 93
   },
   "python": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def kthSmallest(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        stack = []\n        while root is not None or len(stack) \u003e 0:\n            while root is not None:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if k == 0:\n                return root.val\n            root = root.right\n        return -1",
    "id": "263795897",
    "lang": "python",
    "memory": "20.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "230",
     "title": "Kth Smallest Element in a BST",
     "titleSlug": "kth-smallest-element-in-a-bst",
     "translatedTitle": "二叉搜索树中第K小的元素"
    },
    "rawMemory": "21144000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/kth-smallest-element-in-a-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "ok!",
     "flagType": "RED"
    },
    "timestamp": 1643546985,
    "totalTestCaseCnt": 93
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.cnt = 0\n        self.val = 0\n\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -\u003e int:\n        def inorder(node: Optional[TreeNode]):\n            if node == None or self.cnt \u003e k:\n                return\n            inorder(node.left)\n            self.cnt += 1\n            if self.cnt == k:\n                self.val = node.val\n            inorder(node.right)\n\n        inorder(root)\n        return self.val",
    "id": "263782484",
    "lang": "python3",
    "memory": "19.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "230",
     "title": "Kth Smallest Element in a BST",
     "titleSlug": "kth-smallest-element-in-a-bst",
     "translatedTitle": "二叉搜索树中第K小的元素"
    },
    "rawMemory": "19636000",
    "runtime": "48 ms",
    "sourceUrl": "/problems/kth-smallest-element-in-a-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "__int__ 函数",
     "flagType": "RED"
    },
    "timestamp": 1643542916,
    "totalTestCaseCnt": 93
   }
  },
  "largest-number": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string largestNumber(vector\u003cint\u003e\u0026 nums) {\n        std::sort(nums.begin(), nums.end(), [](int a, int b) {\n            string sa = std::to_string(a), sb = std::to_string(b);\n            return sa + sb \u003e sb + sa;\n        });\n\n        if (nums[0] == 0) return \"0\";\n        \n        std::string res;\n        for (auto n : nums) {\n            res += std::to_string(n);\n        }\n        return res;\n    }\n};",
    "id": "265514980",
    "lang": "cpp",
    "memory": "10.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 230,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "179",
     "title": "Largest Number",
     "titleSlug": "largest-number",
     "translatedTitle": "最大数"
    },
    "rawMemory": "11132000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/largest-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644222566,
    "totalTestCaseCnt": 230
   }
  },
  "largest-rectangle-in-histogram": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int largestRectangleArea(vector\u003cint\u003e\u0026 heights) {\n        int res = 0;\n        stack\u003cint\u003e st;\n        heights.push_back(0);\n        for (int i = 0; i \u003c heights.size(); ++i) {\n            while (!st.empty() \u0026\u0026 heights[st.top()] \u003e= heights[i]) {\n                int cur = st.top(); st.pop();\n                int width = st.empty() ? i : (i - st.top() - 1);\n                res = max(res, heights[cur] * width);\n            }\n            st.push(i);\n        }\n        return res;\n    }\n};",
    "id": "263986089",
    "lang": "cpp",
    "memory": "60.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 96,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "84",
     "title": "Largest Rectangle in Histogram",
     "titleSlug": "largest-rectangle-in-histogram",
     "translatedTitle": "柱状图中最大的矩形"
    },
    "rawMemory": "61500000",
    "runtime": "108 ms",
    "sourceUrl": "/problems/largest-rectangle-in-histogram/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "不太懂",
     "flagType": "GREEN"
    },
    "timestamp": 1643641176,
    "totalTestCaseCnt": 96
   }
  },
  "lemonade-change": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool lemonadeChange(vector\u003cint\u003e\u0026 bills) {\n        int cnt5 = 0, cnt10 = 0;\n        for (auto\u0026 bill : bills) {\n            switch (bill) {\n                case 5:\n                    cnt5++;\n                    break;\n                case 10:\n                    cnt10++;\n                    if (cnt5 \u003e 0) cnt5--;\n                    else return false;\n                    break;\n                case 20:\n                    if (cnt10 \u003e 0) {\n                        cnt10--;\n                        if (cnt5 \u003e= 1) cnt5--;\n                        else return false;\n                    } else {\n                        if (cnt5 \u003e=3 ) cnt5 -= 3;\n                        else return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n        }\n        return true;\n    }\n};",
    "id": "263024783",
    "lang": "cpp",
    "memory": "81.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "890",
     "title": "Lemonade Change",
     "titleSlug": "lemonade-change",
     "translatedTitle": "柠檬水找零"
    },
    "rawMemory": "83288000",
    "runtime": "80 ms",
    "sourceUrl": "/leetbook/read/greedy/rvmuse/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643301524,
    "totalTestCaseCnt": 60
   }
  },
  "length-of-last-word": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        if (s.size() \u003c 1) return 0;\n        int cnt =0;\n        bool _space_end = true;\n        for (int i = s.size() - 1; i \u003e= 0; i--) {\n            if (s[i] != ' ') {\n                _space_end = false;\n                cnt++;\n            } else if (_space_end) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        return cnt;\n    }\n};",
    "id": "10192132",
    "lang": "cpp",
    "memory": "1.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 59,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "58",
     "title": "Length of Last Word",
     "titleSlug": "length-of-last-word",
     "translatedTitle": "最后一个单词的长度"
    },
    "rawMemory": "1122304",
    "runtime": "4 ms",
    "sourceUrl": "/problems/length-of-last-word/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544104610,
    "totalTestCaseCnt": 58
   }
  },
  "letter-case-permutation": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cstring\u003e letterCasePermutation(string S) {\n        vector\u003cstring\u003e res;\n        if (S.size() == 0) return {S};\n        FindLetterCasePermutation(S, 0, \"\", res);\n        return res;\n    }\n    void FindLetterCasePermutation(string S, int index, string t, vector\u003cstring\u003e\u0026 res) {\n        if (t.size() == S.size()) {\n            res.push_back(t);\n            return ;\n        }\n\n        if (isalpha(S[index])) {\n            char c = isupper(S[index]) ? tolower(S[index]) : toupper(S[index]);\n            FindLetterCasePermutation(S, index + 1, t + c, res);\n\n        }\n        FindLetterCasePermutation(S, index + 1, t + S[index], res);\n    }\n};",
    "id": "10669144",
    "lang": "cpp",
    "memory": "1.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 64,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "800",
     "title": "Letter Case Permutation",
     "titleSlug": "letter-case-permutation",
     "translatedTitle": "字母大小写全排列"
    },
    "rawMemory": "1478656",
    "runtime": "8 ms",
    "sourceUrl": "/problems/letter-case-permutation/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545274510,
    "totalTestCaseCnt": 63
   }
  },
  "letter-combinations-of-a-phone-number": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\nprivate:\n    string digitStr[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \n                        \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\npublic:\n    vector\u003cstring\u003e letterCombinations(string digits) {\n        vector\u003cstring\u003e res;\n        dfs(0, digits, \"\", res);\n        return res;\n    }\n\n    void dfs(int index, string\u0026 digits, const string\u0026 tmp, vector\u003cstring\u003e\u0026 res) {\n        if (digits.size() == 0) return;\n        if (index == digits.size()) {\n            res.emplace_back(tmp);\n            return;\n        }\n        int num = digits[index] - '0';\n        for (auto\u0026 ch : digitStr[num]) {\n            dfs(index + 1, digits, tmp + ch, res);\n        }\n    }\n};",
    "id": "265946557",
    "lang": "cpp",
    "memory": "6.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 25,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "17",
     "title": "Letter Combinations of a Phone Number",
     "titleSlug": "letter-combinations-of-a-phone-number",
     "translatedTitle": "电话号码的字母组合"
    },
    "rawMemory": "6252000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/letter-combinations-of-a-phone-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644321851,
    "totalTestCaseCnt": 25
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "var (\n\tletterMap = []string{\n\t\t\" \",    //0\n\t\t\"\",     //1\n\t\t\"abc\",  //2\n\t\t\"def\",  //3\n\t\t\"ghi\",  //4\n\t\t\"jkl\",  //5\n\t\t\"mno\",  //6\n\t\t\"pqrs\", //7\n\t\t\"tuv\",  //8\n\t\t\"wxyz\", //9\n\t}\n)\n\nfunc findCombinations(digits *string, index int, combine string, res *[]string) {\n\tif len(*digits) == index {\n\t\t*res = append(*res, combine)\n\t\treturn\n\t}\n\tdigit := (*digits)[index] - '0'\n\tdigitLetters := letterMap[digit]\n\n\tfor i := 0; i \u003c len(digitLetters); i++ {\n\t\tfindCombinations(digits, index+1, combine+string(digitLetters[i]), res)\n\t}\n}\n\nfunc letterCombinations(digits string) []string {\n\tvar res []string\n\tif len(digits) == 0 {\n\t\treturn res\n\t}\n\tfindCombinations(\u0026digits, 0, \"\", \u0026res)\n\treturn res\n}",
    "id": "180204894",
    "lang": "golang",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 25,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "17",
     "title": "Letter Combinations of a Phone Number",
     "titleSlug": "letter-combinations-of-a-phone-number",
     "translatedTitle": "电话号码的字母组合"
    },
    "rawMemory": "2060000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/letter-combinations-of-a-phone-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621780712,
    "totalTestCaseCnt": 25
   }
  },
  "lexicographical-numbers": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e lexicalOrder(int n) {\n        vector\u003cint\u003e res;\n        for (int i = 1; i \u003c= 9; i++) {\n            dfs(i, n, res);\n        }\n        return res;\n    }\n\n    void dfs(int curr, int n, vector\u003cint\u003e\u0026 res) {\n        if (curr \u003e n) return;\n        res.push_back(curr);\n        for (int i = 0; i \u003c= 9; i++) {\n            dfs(curr*10 + i, n, res);\n        }\n    }\n};",
    "id": "265583017",
    "lang": "cpp",
    "memory": "11.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 26,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "386",
     "title": "Lexicographical Numbers",
     "titleSlug": "lexicographical-numbers",
     "translatedTitle": "字典序排数"
    },
    "rawMemory": "11688000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/lexicographical-numbers/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "牛逼。\n10 叉树的先序遍历。",
     "flagType": "BLUE"
    },
    "timestamp": 1644234357,
    "totalTestCaseCnt": 26
   }
  },
  "lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* getKthFromEnd(ListNode* head, int k) {\n        ListNode *fast = head, *slow = head;\n        for (int i = 0; i \u003c k \u0026\u0026 fast; i++) {\n            fast = fast-\u003enext;\n        }\n        while (fast \u0026\u0026 slow) {\n            fast = fast-\u003enext;\n            slow = slow-\u003enext;\n        }\n\n        return slow;\n    }\n};",
    "id": "275087714",
    "lang": "cpp",
    "memory": "10.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100294",
     "title": "链表中倒数第k个节点 LCOF",
     "titleSlug": "lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof",
     "translatedTitle": "链表中倒数第k个节点"
    },
    "rawMemory": "10536000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646098536,
    "totalTestCaseCnt": 208
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getKthFromEnd(head *ListNode, k int) *ListNode {\n    fast := head\n    slow := head\n    for k \u003e 0 \u0026\u0026 fast != nil {\n        fast = fast.Next\n        k--\n    }\n\n    for fast != nil {\n        fast = fast.Next\n        slow = slow.Next\n    }\n\n    return slow\n}",
    "id": "197734770",
    "lang": "golang",
    "memory": "2.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100294",
     "title": "链表中倒数第k个节点 LCOF",
     "titleSlug": "lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof",
     "translatedTitle": "链表中倒数第k个节点"
    },
    "rawMemory": "2276000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626756131,
    "totalTestCaseCnt": 208
   }
  },
  "lian-xu-zi-shu-zu-de-zui-da-he-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maxSubArray(vector\u003cint\u003e\u0026 nums) {\n        int max_sum = nums[0], sum = 0;\n        for (auto num : nums) {\n            if (sum \u003c 0) {\n                sum = num;\n            } else {\n                sum += num;\n            }\n            max_sum = std::max(max_sum, sum);\n        }\n        return max_sum;\n    }\n};",
    "id": "268748163",
    "lang": "cpp",
    "memory": "22.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 202,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100304",
     "title": "连续子数组的最大和  LCOF",
     "titleSlug": "lian-xu-zi-shu-zu-de-zui-da-he-lcof",
     "translatedTitle": "连续子数组的最大和"
    },
    "rawMemory": "22860000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644928245,
    "totalTestCaseCnt": 202
   }
  },
  "linked-list-cycle": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nbool hasCycle(struct ListNode *head) {\n    struct ListNode* fast = head;\n    while (fast \u0026\u0026 fast-\u003enext) {\n        fast = fast-\u003enext-\u003enext;\n        head = head-\u003enext;\n        if (head == fast) {\n            return true;\n        }\n    } \n    return false;\n}",
    "id": "264586128",
    "lang": "c",
    "memory": "7.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "141",
     "title": "Linked List Cycle",
     "titleSlug": "linked-list-cycle",
     "translatedTitle": "环形链表"
    },
    "rawMemory": "8020000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/linked-list-cycle/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643905339,
    "totalTestCaseCnt": 21
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode* fast = head;\n        while (fast \u0026\u0026 head) {\n            head = head-\u003enext;\n            if (fast-\u003enext)\n                fast = fast-\u003enext-\u003enext;\n            else\n                break;\n            if (head == fast) return true;\n        }\n        return false;\n    }\n};",
    "id": "263999771",
    "lang": "cpp",
    "memory": "8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "141",
     "title": "Linked List Cycle",
     "titleSlug": "linked-list-cycle",
     "translatedTitle": "环形链表"
    },
    "rawMemory": "8228000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/linked-list-cycle/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643654412,
    "totalTestCaseCnt": 21
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc hasCycle(head *ListNode) bool {\n    fast := head\n    for fast != nil \u0026\u0026 fast.Next != nil {\n        head = head.Next\n        fast = fast.Next.Next\n        if fast == head {\n            return true\n        }\n    }\n    return false\n}",
    "id": "263999948",
    "lang": "golang",
    "memory": "4.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "141",
     "title": "Linked List Cycle",
     "titleSlug": "linked-list-cycle",
     "translatedTitle": "环形链表"
    },
    "rawMemory": "4268000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/linked-list-cycle/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "nice",
     "flagType": "RED"
    },
    "timestamp": 1643654943,
    "totalTestCaseCnt": 21
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode fast = head;\n        while (fast != null \u0026\u0026 fast.next != null) {\n            fast = fast.next.next;\n            head = head.next;\n            if (head == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
    "id": "264000134",
    "lang": "java",
    "memory": "42.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "141",
     "title": "Linked List Cycle",
     "titleSlug": "linked-list-cycle",
     "translatedTitle": "环形链表"
    },
    "rawMemory": "43576000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/linked-list-cycle/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "ok",
     "flagType": "RED"
    },
    "timestamp": 1643655518,
    "totalTestCaseCnt": 21
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -\u003e bool:\n        fast = head\n        while fast != None and fast.next != None:\n            fast = fast.next.next\n            head = head.next\n            if fast == head:\n                return True\n        return False",
    "id": "264000094",
    "lang": "python3",
    "memory": "18.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "141",
     "title": "Linked List Cycle",
     "titleSlug": "linked-list-cycle",
     "translatedTitle": "环形链表"
    },
    "rawMemory": "19176000",
    "runtime": "64 ms",
    "sourceUrl": "/problems/linked-list-cycle/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OK",
     "flagType": "RED"
    },
    "timestamp": 1643655418,
    "totalTestCaseCnt": 21
   },
   "typescript": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction hasCycle(head: ListNode | null): boolean {\n    let fast = head\n    while (fast != null \u0026\u0026 fast.next != null) {\n        fast = fast.next.next\n        head = head.next\n        if (head === fast) {\n            return true\n        }\n    }\n    return false\n};",
    "id": "264000246",
    "lang": "typescript",
    "memory": "44.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "141",
     "title": "Linked List Cycle",
     "titleSlug": "linked-list-cycle",
     "translatedTitle": "环形链表"
    },
    "rawMemory": "45472000",
    "runtime": "84 ms",
    "sourceUrl": "/problems/linked-list-cycle/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643655863,
    "totalTestCaseCnt": 21
   }
  },
  "linked-list-cycle-ii": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode *detectCycle(struct ListNode *head) {\n    while (head) {\n        if (head \u003e= head-\u003enext) {\n            return head-\u003enext;\n        }\n        head = head-\u003enext;\n    }\n    return NULL;\n}",
    "id": "266158932",
    "lang": "c",
    "memory": "6.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 16,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "142",
     "title": "Linked List Cycle II",
     "titleSlug": "linked-list-cycle-ii",
     "translatedTitle": "环形链表 II"
    },
    "rawMemory": "7044000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/linked-list-cycle-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644381207,
    "totalTestCaseCnt": 16
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *f = head, *s = head;\n        while (f \u0026\u0026 f-\u003enext) {\n            f = f-\u003enext-\u003enext;\n            s = s-\u003enext;\n            if (f == s) {\n                while (head != s) {\n                    head = head-\u003enext;\n                    s = s-\u003enext;\n                }\n                return head;\n            }\n        }\n        return nullptr;\n    }\n};",
    "id": "266156528",
    "lang": "cpp",
    "memory": "7.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 16,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "142",
     "title": "Linked List Cycle II",
     "titleSlug": "linked-list-cycle-ii",
     "translatedTitle": "环形链表 II"
    },
    "rawMemory": "7692000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/linked-list-cycle-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这种写法不错",
     "flagType": "BLUE"
    },
    "timestamp": 1644380599,
    "totalTestCaseCnt": 16
   }
  },
  "linked-list-cycle-lcci": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        set\u003cListNode*\u003e listSet;\n        while (head) {\n            if (listSet.count(head) != 0) {\n                return head;\n            }\n            listSet.insert(head);\n            head = head-\u003enext; \n        }\n        return nullptr;\n    }\n};",
    "id": "264591043",
    "lang": "cpp",
    "memory": "9.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 16,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100168",
     "title": "Linked List Cycle LCCI",
     "titleSlug": "linked-list-cycle-lcci",
     "translatedTitle": "环路检测"
    },
    "rawMemory": "9904000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/linked-list-cycle-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643907799,
    "totalTestCaseCnt": 16
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    nodeMap := make(map[*ListNode]struct{})\n    for head != nil {\n        if _, e := nodeMap[head]; e {\n            return head;\n        }\n        nodeMap[head] = struct{}{}\n        head = head.Next\n    }   \n    return nil\n}",
    "id": "264591205",
    "lang": "golang",
    "memory": "4.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 16,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100168",
     "title": "Linked List Cycle LCCI",
     "titleSlug": "linked-list-cycle-lcci",
     "translatedTitle": "环路检测"
    },
    "rawMemory": "4872000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/linked-list-cycle-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643907910,
    "totalTestCaseCnt": 16
   }
  },
  "linked-list-random-node": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    Solution(ListNode* head) {\n        while (head) {\n            vec_.push_back(head);\n            head = head-\u003enext;\n        }\n    }\n    \n    int getRandom() {\n        return vec_[rand() % vec_.size()]-\u003eval;\n    }\nprivate:\n    std::vector\u003cListNode*\u003e vec_;\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(head);\n * int param_1 = obj-\u003egetRandom();\n */",
    "id": "264594050",
    "lang": "cpp",
    "memory": "16.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 8,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "382",
     "title": "Linked List Random Node",
     "titleSlug": "linked-list-random-node",
     "translatedTitle": "链表随机节点"
    },
    "rawMemory": "16840000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/linked-list-random-node/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643910383,
    "totalTestCaseCnt": 8
   }
  },
  "longest-common-prefix": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string CommonPrefix(string\u0026 a, string\u0026 b) {\n        //string cp;\n        int j = 0;\n        for (j = 0; j \u003c a.size() \u0026\u0026 j \u003c b.size(); j++) {\n            if (a[j] == b[j]) {\n                //cp.append(1, a[j]);\n            } else {\n                break;\n            }\n        }\n        //return cp;\n        return a.substr(0, j);\n    }\n\n    string longestCommonPrefix(vector\u003cstring\u003e\u0026 strs) {\n        if (strs.size() == 0) {\n            return \"\";\n        }\n        string lcp = strs[0];\n        for (auto i = 0; i \u003c strs.size() - 1; i++) {\n            string cp = CommonPrefix(strs[i], strs[i+1]);\n            if (cp.size() == 0) {\n                return \"\";\n            }\n            if (cp.size() \u003c lcp.size()) {\n                lcp = cp;\n            }\n        }\n        return  lcp;\n    }\n};",
    "id": "9517939",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 118,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "14",
     "title": "Longest Common Prefix",
     "titleSlug": "longest-common-prefix",
     "translatedTitle": "最长公共前缀"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/longest-common-prefix/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1542596283,
    "totalTestCaseCnt": 123
   }
  },
  "longest-common-subsequence": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        vector\u003cvector\u003cint\u003e\u003e dp(text1.size()+1, vector\u003cint\u003e(text2.size()+1));\n        for (int i = 1; i \u003c= text1.size(); i++) {\n            for (int j = 1; j \u003c= text2.size(); j++) {\n                if (text1[i-1] == text2[j-1]) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                } else {\n                    dp[i][j] = std::max(dp[i][j-1], dp[i-1][j]);\n                }\n            }\n        }\n\n        return dp.back().back();\n    }\n};",
    "id": "261806534",
    "lang": "cpp",
    "memory": "12.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 44,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1250",
     "title": "Longest Common Subsequence",
     "titleSlug": "longest-common-subsequence",
     "translatedTitle": "最长公共子序列"
    },
    "rawMemory": "13068000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/longest-common-subsequence/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642997074,
    "totalTestCaseCnt": 44
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func longestCommonSubsequence(text1 string, text2 string) int {\n    memo := make([][]int, len(text1) + 1)\n    for i := 0; i \u003c len(memo); i++ {\n        memo[i] = make([]int, len(text2) + 1)\n    }\n    return getLcs(text1, text2, memo)\n}\n\nfunc getLcs(t1, t2 string, memo [][]int) int {\n    len1, len2 := len(t1), len(t2)\n    if len1 == 0 || len2 == 0 {\n        return 0;\n    }\n\n    if memo[len1][len2] \u003e 0 {\n        return memo[len1][len2]\n    }\n\n    if t1[0] == t2[0] {\n        return 1 + getLcs(t1[1:], t2[1:], memo)\n    }\n    \n    memo[len1][len2] = max(getLcs(t1, t2[1:], memo), getLcs(t1[1:], t2, memo))\n    return memo[len1][len2]\n}\n\nfunc max(a, b int) int {\n    if a \u003e b {\n        return a\n    }\n    return b\n}",
    "id": "261809917",
    "lang": "golang",
    "memory": "11 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 44,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1250",
     "title": "Longest Common Subsequence",
     "titleSlug": "longest-common-subsequence",
     "translatedTitle": "最长公共子序列"
    },
    "rawMemory": "11232000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/longest-common-subsequence/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "递归： 自顶向下",
     "flagType": "RED"
    },
    "timestamp": 1642997935,
    "totalTestCaseCnt": 44
   }
  },
  "longest-consecutive-sequence": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int longestConsecutive(vector\u003cint\u003e\u0026 nums) {\n        unordered_set\u003cint\u003e nums_set;\n        int max_len = 0;\n        for (auto \u0026n : nums) {\n            nums_set.insert(n);\n        }\n\n        for (auto \u0026n : nums) {\n            // 从起点开始\n            if (nums_set.count(n-1) == 0) {\n                int next = n;\n                while(nums_set.count(next)) {\n                    next++;\n                }\n                max_len = std::max(max_len, next - n);\n            }\n        }\n\n        return max_len;\n    }\n};",
    "id": "261983258",
    "lang": "cpp",
    "memory": "30.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "128",
     "title": "Longest Consecutive Sequence",
     "titleSlug": "longest-consecutive-sequence",
     "translatedTitle": "最长连续序列"
    },
    "rawMemory": "30808000",
    "runtime": "452 ms",
    "sourceUrl": "/problems/longest-consecutive-sequence/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "哈希表法。太慢了。\n思路：\n构建全量set\n是从一个连续序列的起点开始，即 当前值的前一个值： n - 1 不在哈希表中 ，\n然后看下一个序列是否再哈希表中。",
     "flagType": "RED"
    },
    "timestamp": 1643029302,
    "totalTestCaseCnt": 70
   }
  },
  "longest-palindrome": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int longestPalindrome(char * s){\n    int seen[128] = {0,};\n    int strlen = 0;\n    while (*s) seen[*s++]++, strlen++;\n    int ocnt = 0;\n    for (int i = 'a'; i \u003c= 'z'; i++) {\n        ocnt += seen[i] % 2;\n    }\n    for (int i = 'A'; i \u003c= 'Z'; i++) {\n        ocnt += seen[i] % 2;\n    }\n    if (ocnt \u003e 0) ocnt--;\n    \n    return strlen - ocnt;\n}",
    "id": "264001182",
    "lang": "c",
    "memory": "5.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 95,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "409",
     "title": "Longest Palindrome",
     "titleSlug": "longest-palindrome",
     "translatedTitle": "最长回文串"
    },
    "rawMemory": "5800000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/longest-palindrome/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OKK\n",
     "flagType": "RED"
    },
    "timestamp": 1643659150,
    "totalTestCaseCnt": 95
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n\n\n    int longestPalindrome(string s) {\n\n        int n = s.size();\n        if (n == 0) return 0;\n        int table[52] = {0};\n            \n        for (int i = 0; i \u003c n; i++)\n        {\n            int index = int(s[i] - 'A');\n            if (s[i] \u003e= 'a')    index -= 6;\n            table[index]++;\n        }\n\n        int even = 0;\n        int odd = 0;\n        for (int i = 0; i \u003c 52; i++)\n        {\n            even += table[i] / 2 * 2;\n            odd += table[i] % 2;     \n        }\n        \n        odd = odd \u003e 0 ? 1: 0;\n        return even + odd;\n    }\n};",
    "id": "265567137",
    "lang": "cpp",
    "memory": "6.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 95,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "409",
     "title": "Longest Palindrome",
     "titleSlug": "longest-palindrome",
     "translatedTitle": "最长回文串"
    },
    "rawMemory": "6572000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/longest-palindrome/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "牛逼啊。\n0 的 asicc 码是 0x30\na 的 asicc 码是 0x41\nA 的 asicc 码是 0x61\n\n还有一个步骤是去奇数加和 的操作。",
     "flagType": "BLUE"
    },
    "timestamp": 1644230595,
    "totalTestCaseCnt": 95
   }
  },
  "longest-palindromic-substring": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        if (s.size() \u003c 2) return s;\n        int n = s.size(), maxLen = 0, start = 0;\n        for (int i = 0; i \u003c n - 1; ++i) {\n            searchPalindrome(s, i, i, start, maxLen);\n            searchPalindrome(s, i, i + 1, start, maxLen);\n        }\n        return s.substr(start, maxLen);\n    }\n    void searchPalindrome(string s, int left, int right, int\u0026 start, int\u0026 maxLen) {\n        while (left \u003e= 0 \u0026\u0026 right \u003c s.size() \u0026\u0026 s[left] == s[right]) {\n            --left; ++right;\n        }\n        if (maxLen \u003c right - left - 1) {\n            start = left + 1;\n            maxLen = right - left - 1;\n        }\n    }\n};",
    "id": "10120652",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 103,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "5",
     "title": "Longest Palindromic Substring",
     "titleSlug": "longest-palindromic-substring",
     "translatedTitle": "最长回文子串"
    },
    "rawMemory": "N/A",
    "runtime": "20 ms",
    "sourceUrl": "/problems/longest-palindromic-substring/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543987966,
    "totalTestCaseCnt": 180
   }
  },
  "longest-substring-without-repeating-characters": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int lengthOfLongestSubstring(char * s){\n    int left = 0;\n    int right = 0;\n    int max_len = 0;\n\n    bool exist[256] = {false,};\n\n    while (*(s+right)) {\n        if (!exist[*(s+right)]) {\n            exist[*(s+right)] = true;\n            if (right - left + 1 \u003e max_len) {\n                max_len = right - left + 1;\n            }\n            right++;\n        } else {\n            exist[*(s+left)] = false;\n            left++;\n        }\n    }\n    return max_len;\n}",
    "id": "261629213",
    "lang": "c",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 987,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "3",
     "title": "Longest Substring Without Repeating Characters",
     "titleSlug": "longest-substring-without-repeating-characters",
     "translatedTitle": "无重复字符的最长子串"
    },
    "rawMemory": "5900000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/longest-substring-without-repeating-characters/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642936444,
    "totalTestCaseCnt": 987
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        bool exists[256] = {false};\n        int left = 0, right = 0;\n        int max_len = 0;\n\n        while (right \u003c s.size()) {\n            int next = s[right];\n            if (!exists[next]) {\n                exists[s[right]] = true;\n                max_len = std::max(max_len, right - left + 1);\n                right++;\n            } else {\n                exists[s[left]] = false;\n                left++;\n            }\n        }\n        return max_len;\n    }\n};",
    "id": "261588366",
    "lang": "cpp",
    "memory": "6.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 987,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "3",
     "title": "Longest Substring Without Repeating Characters",
     "titleSlug": "longest-substring-without-repeating-characters",
     "translatedTitle": "无重复字符的最长子串"
    },
    "rawMemory": "6900000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/longest-substring-without-repeating-characters/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642928396,
    "totalTestCaseCnt": 987
   }
  },
  "lowest-common-ancestor-of-a-binary-search-tree": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if (root == NULL) {\n        return NULL;\n    }\n    if (root-\u003eval \u003e p-\u003eval \u0026\u0026 root-\u003eval \u003e q-\u003eval) {\n        return lowestCommonAncestor(root-\u003eleft, p, q);\n    } else if (root-\u003eval \u003c p-\u003eval \u0026\u0026 root-\u003eval \u003c q-\u003eval) {\n        return lowestCommonAncestor(root-\u003eright, p, q);\n    }\n    return root;    \n}",
    "id": "264002348",
    "lang": "c",
    "memory": "28.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 27,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "235",
     "title": "Lowest Common Ancestor of a Binary Search Tree",
     "titleSlug": "lowest-common-ancestor-of-a-binary-search-tree",
     "translatedTitle": "二叉搜索树的最近公共祖先"
    },
    "rawMemory": "28864000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "递归。",
     "flagType": "RED"
    },
    "timestamp": 1643661246,
    "totalTestCaseCnt": 27
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        while (root) {\n            if (root-\u003eval \u003e std::max(p-\u003eval, q-\u003eval)) {\n                root = root-\u003eleft;\n            } else if (root-\u003eval \u003c std::min(p-\u003eval, q-\u003eval)) {\n                root = root-\u003eright;\n            } else {\n                return root;\n            }\n        }\n        return root;\n    }\n};",
    "id": "264002495",
    "lang": "cpp",
    "memory": "22.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 27,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "235",
     "title": "Lowest Common Ancestor of a Binary Search Tree",
     "titleSlug": "lowest-common-ancestor-of-a-binary-search-tree",
     "translatedTitle": "二叉搜索树的最近公共祖先"
    },
    "rawMemory": "23304000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这样看代码，格式还是不错的。\n",
     "flagType": "RED"
    },
    "timestamp": 1643662236,
    "totalTestCaseCnt": 27
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val   int\n *     Left  *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root != nil {\n        if root.Val \u003e p.Val \u0026\u0026 root.Val \u003e q.Val {\n            return lowestCommonAncestor(root.Left, p, q)\n        } else if root.Val \u003c p.Val \u0026\u0026 root.Val \u003c q.Val {\n            return lowestCommonAncestor(root.Right, p, q)\n        }\n    }\n    return root\n}",
    "id": "264002536",
    "lang": "golang",
    "memory": "6.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 27,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "235",
     "title": "Lowest Common Ancestor of a Binary Search Tree",
     "titleSlug": "lowest-common-ancestor-of-a-binary-search-tree",
     "translatedTitle": "二叉搜索树的最近公共祖先"
    },
    "rawMemory": "7068000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OKK",
     "flagType": "RED"
    },
    "timestamp": 1643662548,
    "totalTestCaseCnt": 27
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u003e 'TreeNode':\n        while root != None:\n            if root.val \u003e max(p.val, q.val):\n                root = root.left\n            elif root.val \u003c min(p.val, q.val):\n                root = root.right\n            else: \n                return root\n        return root",
    "id": "264002462",
    "lang": "python3",
    "memory": "19.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 27,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "235",
     "title": "Lowest Common Ancestor of a Binary Search Tree",
     "titleSlug": "lowest-common-ancestor-of-a-binary-search-tree",
     "translatedTitle": "二叉搜索树的最近公共祖先"
    },
    "rawMemory": "19624000",
    "runtime": "76 ms",
    "sourceUrl": "/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OKKK",
     "flagType": "RED"
    },
    "timestamp": 1643661926,
    "totalTestCaseCnt": 27
   },
   "typescript": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n\tif (root != null) {\n        if (root.val \u003e p.val \u0026\u0026 root.val \u003e q.val) {\n            return lowestCommonAncestor(root.left, p, q)\n        } else if (root.val \u003c p.val \u0026\u0026 root.val \u003c q.val) {\n            return lowestCommonAncestor(root.right, p, q)\n        }\n    }\n    return root\n};",
    "id": "264002581",
    "lang": "typescript",
    "memory": "51.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 27,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "235",
     "title": "Lowest Common Ancestor of a Binary Search Tree",
     "titleSlug": "lowest-common-ancestor-of-a-binary-search-tree",
     "translatedTitle": "二叉搜索树的最近公共祖先"
    },
    "rawMemory": "52904000",
    "runtime": "80 ms",
    "sourceUrl": "/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643662760,
    "totalTestCaseCnt": 27
   }
  },
  "lowest-common-ancestor-of-a-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n        auto l = lowestCommonAncestor(root-\u003eleft, p, q);\n        auto r = lowestCommonAncestor(root-\u003eright, p, q);\n        if (l == nullptr \u0026\u0026 r == nullptr) \n            return nullptr;\n        else if (l == nullptr) \n            return r;\n        else if (r == nullptr) \n            return l;\n        return root;\n    }\n};",
    "id": "266437397",
    "lang": "cpp",
    "memory": "14 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "236",
     "title": "Lowest Common Ancestor of a Binary Tree",
     "titleSlug": "lowest-common-ancestor-of-a-binary-tree",
     "translatedTitle": "二叉树的最近公共祖先"
    },
    "rawMemory": "14380000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/lowest-common-ancestor-of-a-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644421527,
    "totalTestCaseCnt": 31
   }
  },
  "lru-cache": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class LRUCache {\npublic:\n    template \u003ctypename K, typename V\u003e\n    struct Node {\n        K key;\n        V value;\n        Node\u003cK,V\u003e* next;\n        Node\u003cK,V\u003e* prev;\n\n        Node\u003cK,V\u003e (K k,V v):key(k), value(v), next(nullptr), prev(nullptr) {\n        }\n    };\n    using LruNode = Node\u003cint,int\u003e;\npublic:\n    LRUCache(int capacity) :cap_(capacity), size_(0), head_(0, 0) {\n        head_.next = \u0026head_;\n        head_.prev = \u0026head_;\n    }\n    \n    int get(int key) {\n        auto it = table_.find(key);\n        if (it == table_.end()) {\n            return -1;\n        }\n        LruNode* node = it-\u003esecond;\n        // LRU update\n        removeNode(node);\n        updateNode(node);\n\n        return node-\u003evalue;\n    }\n    \n    void put(int key, int value) {\n        LruNode* node = nullptr;\n        auto it = table_.find(key);\n        if (it == table_.end()) {\n            node = new LruNode(key, value);\n            table_[key] = node;\n            size_++;\n            // LRU update\n            updateNode(node);\n            if (size_ \u003e cap_) {\n                // LRU erase\n                LruNode* rmNode = head_.prev;\n                removeNode(rmNode);\n                table_.erase(rmNode-\u003ekey);\n                delete rmNode;\n                size_--;\n            }\n\n        } else {\n            node = it-\u003esecond;\n            node-\u003evalue = value;\n            // LRU update\n            removeNode(node);\n            updateNode(node);\n        }\n    }\n\n    void updateNode(LruNode* node) {\n        node-\u003eprev = \u0026head_;\n        node-\u003enext = head_.next;\n        head_.next-\u003eprev = node;\n        head_.next = node;\n    }\n\n    void removeNode(LruNode* node) {\n        node-\u003eprev-\u003enext = node-\u003enext;\n        node-\u003enext-\u003eprev = node-\u003eprev;\n    }\n\nprivate:\n    int cap_;\n    int size_;\n    LruNode head_;\n    unordered_map\u003cint, LruNode*\u003e table_;\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj-\u003eget(key);\n * obj-\u003eput(key,value);\n */",
    "id": "261076344",
    "lang": "cpp",
    "memory": "161.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 22,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "146",
     "title": "LRU Cache",
     "titleSlug": "lru-cache",
     "translatedTitle": "LRU 缓存"
    },
    "rawMemory": "165064000",
    "runtime": "360 ms",
    "sourceUrl": "/leetbook/read/designing-data-structures/rt971j/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642783757,
    "totalTestCaseCnt": 21
   }
  },
  "majority-element": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int majorityElement(vector\u003cint\u003e\u0026 nums) {\n        int res = -1, cnt = 0;\n        for (auto n : nums) {\n            if (cnt == 0) {\n                res = n;\n            }\n            if (res == n) {\n                cnt++;\n            } else {\n                cnt--;\n            }\n        }\n        return res;\n    }\n};",
    "id": "265413996",
    "lang": "cpp",
    "memory": "19.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "169",
     "title": "Majority Element",
     "titleSlug": "majority-element",
     "translatedTitle": "多数元素"
    },
    "rawMemory": "19600000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/majority-element/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644204903,
    "totalTestCaseCnt": 43
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func majorityElement(nums []int) int {\n\tres, count := nums[0], 0\n\tfor i := 0; i \u003c len(nums); i++ {\n\t\tif count == 0 {\n\t\t\tres, count = nums[i], 1\n\t\t} else {\n\t\t\tif nums[i] == res {\n\t\t\t\tcount++\n\t\t\t} else {\n\t\t\t\tcount--\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}",
    "id": "179112006",
    "lang": "golang",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "169",
     "title": "Majority Element",
     "titleSlug": "majority-element",
     "translatedTitle": "多数元素"
    },
    "rawMemory": "6116000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/majority-element/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621447638,
    "totalTestCaseCnt": 43
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -\u003e int:\n        ans, count = 0, 0\n        for x in nums:\n            ans = x if count == 0  else ans\n            count = count + 1 if ans == x else count - 1\n\n        return ans",
    "id": "179112522",
    "lang": "python3",
    "memory": "16 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "169",
     "title": "Majority Element",
     "titleSlug": "majority-element",
     "translatedTitle": "多数元素"
    },
    "rawMemory": "16400000",
    "runtime": "48 ms",
    "sourceUrl": "/problems/majority-element/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621448315,
    "totalTestCaseCnt": 43
   }
  },
  "max-stack": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class MaxStack {\npublic:\n    MaxStack() {\n\n    }\n    \n    void push(int x) {\n        stack_.push(x);\n        if (stack_max_.empty()) {\n            stack_max_.push(x);\n        } else {\n            stack_max_.push(std::max(peekMax(), x));\n        }\n    }\n    \n    int pop() {\n        int t = top();\n        stack_.pop();\n        stack_max_.pop();\n        return t;\n    }\n    \n    int top() {\n        return stack_.top();\n    }\n    \n    int peekMax() {\n        return stack_max_.top();\n    }\n    \n    // 这块很容易写错啊。\n    int popMax() {\n        int max = peekMax();\n        std::stack\u003cint\u003e tmp;\n        while (max != top()) {\n            tmp.push(pop());\n        }\n        pop();\n        while (!tmp.empty()) {\n            push(tmp.top());\n            tmp.pop();\n        }\n        return max;\n    }\nprivate:\n    std::stack\u003cint\u003e stack_;\n    std::stack\u003cint\u003e stack_max_;\n};\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack* obj = new MaxStack();\n * obj-\u003epush(x);\n * int param_2 = obj-\u003epop();\n * int param_3 = obj-\u003etop();\n * int param_4 = obj-\u003epeekMax();\n * int param_5 = obj-\u003epopMax();\n */",
    "id": "261004364",
    "lang": "cpp",
    "memory": "40.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 164,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "716",
     "title": "Max Stack",
     "titleSlug": "max-stack",
     "translatedTitle": "最大栈"
    },
    "rawMemory": "41400000",
    "runtime": "68 ms",
    "sourceUrl": "/problems/max-stack/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642767684,
    "totalTestCaseCnt": 164
   }
  },
  "maximal-square": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int max(int a, int b) {\n    if (a \u003e b) {\n        return a;\n    }\n    return b;\n}\n\nint min(int a, int b) {\n    if (a \u003e b) {\n        return b;\n    }\n    return a;\n}\n\nint min3(int a, int b, int c) {\n    return min(min(a, b), c);\n}\n\nint maximalSquare(char** matrix, int matrixSize, int* matrixColSize){\n    int* dp[matrixSize];\n    for (int i = 0; i \u003c matrixSize; i++) {\n        dp[i] = (int*)malloc(sizeof(int)*(matrixColSize[0]));\n    }\n    int maxWidth = 0;\n    for (int i = 0; i \u003c matrixSize; i++) {\n        for (int j = 0; j \u003c matrixColSize[0]; j++) {\n            if (matrix[i][j] == '1') {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = min3(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1;\n                } \n                maxWidth = max(maxWidth, dp[i][j]);\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 0; i \u003c matrixSize; i++) {\n        free(dp[i]);\n    }\n    return maxWidth * maxWidth;\n}",
    "id": "263981164",
    "lang": "c",
    "memory": "10.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 77,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "221",
     "title": "Maximal Square",
     "titleSlug": "maximal-square",
     "translatedTitle": "最大正方形"
    },
    "rawMemory": "10804000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/maximal-square/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643638258,
    "totalTestCaseCnt": 75
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maximalSquare(vector\u003cvector\u003cchar\u003e\u003e\u0026 matrix) {\n        int m = matrix.size(), n = matrix.back().size();\n        int res = 0;\n        vector\u003cvector\u003cint\u003e\u003e dp(m, vector\u003cint\u003e(n));\n\n        for (int i = 0; i \u003c m; i++) {\n            for (int j = 0; j \u003c n; j++) {\n                if (matrix[i][j] == '1') {\n                    if (i == 0 || j == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        dp[i][j] = std::min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]}) + 1;\n                    }\n                    res = std::max(res, dp[i][j]);\n                } else {\n                    dp[i][j] = 0;\n                }\n            }\n        }\n        return res * res;\n    }\n};",
    "id": "263976736",
    "lang": "cpp",
    "memory": "17.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 77,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "221",
     "title": "Maximal Square",
     "titleSlug": "maximal-square",
     "translatedTitle": "最大正方形"
    },
    "rawMemory": "18116000",
    "runtime": "64 ms",
    "sourceUrl": "/problems/maximal-square/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643635600,
    "totalTestCaseCnt": 75
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func maximalSquare(matrix [][]byte) int {\n    m, n := len(matrix), len(matrix[0])\n    max_width := 0\n    dp := make([][]int, m)\n    for i := 0; i \u003c m; i++ {\n        dp[i] = make([]int, n)\n    }\n    for i := 0; i \u003c m; i++ {\n        for j := 0; j \u003c n; j++ {\n            if matrix[i][j] == '1' {\n                if i == 0 || j == 0 {\n                    dp[i][j] = 1        \n                } else {\n                    dp[i][j] = min3(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n                }\n                max_width = max(max_width, dp[i][j])\n            }\n        }\n    }\n    return max_width*max_width\n}\n\nfunc max(a, b int) int {\n    if a \u003e b {\n        return a\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a \u003e b {\n        return b\n    }\n    return a\n} \n\nfunc min3(a, b, c int) int {\n    res := min(a, b)\n    res = min(res, c)\n    return res\n}",
    "id": "263979198",
    "lang": "golang",
    "memory": "6.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 77,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "221",
     "title": "Maximal Square",
     "titleSlug": "maximal-square",
     "translatedTitle": "最大正方形"
    },
    "rawMemory": "6508000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/maximal-square/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643637017,
    "totalTestCaseCnt": 75
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -\u003e int:\n        m = len(matrix)\n        n = len(matrix[0])\n        max_width =  0\n        dp = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else: \n                        dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n                    max_width = max(max_width, dp[i][j])\n                else:\n                    dp[i][j] = 0\n        return max_width * max_width",
    "id": "263977756",
    "lang": "python3",
    "memory": "27.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 77,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "221",
     "title": "Maximal Square",
     "titleSlug": "maximal-square",
     "translatedTitle": "最大正方形"
    },
    "rawMemory": "28592000",
    "runtime": "180 ms",
    "sourceUrl": "/problems/maximal-square/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643636232,
    "totalTestCaseCnt": 75
   }
  },
  "maximum-depth-of-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        return std::max(maxDepth(root-\u003eright), maxDepth(root-\u003eleft)) + 1;\n    }\n};",
    "id": "265177866",
    "lang": "cpp",
    "memory": "18.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "104",
     "title": "Maximum Depth of Binary Tree",
     "titleSlug": "maximum-depth-of-binary-tree",
     "translatedTitle": "二叉树的最大深度"
    },
    "rawMemory": "18808000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/maximum-depth-of-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644129671,
    "totalTestCaseCnt": 39
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxDepth(root *TreeNode) int {\n    if root ==  nil {\n        return 0\n    }\n    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1\n}\n\nfunc max(a, b int) int {\n    if a \u003e b {\n        return a\n    }\n    return b;\n}",
    "id": "234649943",
    "lang": "golang",
    "memory": "4.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "104",
     "title": "Maximum Depth of Binary Tree",
     "titleSlug": "maximum-depth-of-binary-tree",
     "translatedTitle": "二叉树的最大深度"
    },
    "rawMemory": "4336000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/maximum-depth-of-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635827436,
    "totalTestCaseCnt": 39
   }
  },
  "maximum-depth-of-n-ary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector\u003cNode*\u003e children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector\u003cNode*\u003e _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int maxDepth(Node* root) {\n        if (root == nullptr) return 0;\n        int max = 0;\n        for (auto \u0026node : root-\u003echildren) {\n            int node_depth = maxDepth(node);\n            if (node_depth \u003e max) {\n                max = node_depth;\n            }\n        }\n        return max + 1;\n    }\n};",
    "id": "234705170",
    "lang": "cpp",
    "memory": "10.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "774",
     "title": "Maximum Depth of N-ary Tree",
     "titleSlug": "maximum-depth-of-n-ary-tree",
     "translatedTitle": "N 叉树的最大深度"
    },
    "rawMemory": "10816000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/maximum-depth-of-n-ary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635838405,
    "totalTestCaseCnt": 38
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Children []*Node\n * }\n */\n\nfunc maxDepth(root *Node) int {\n    q := []*Node{}\n    if root == nil {\n        return 0\n    }\n    depth := 0\n    q = append(q, root)\n\n    for {\n        levelCnt := len(q)\n        if levelCnt == 0 {\n            break\n        }\n\n        for i := 0; i \u003c levelCnt; i++ {\n            for _, childNode := range q[i].Children {\n                if childNode != nil {\n                    q = append(q, childNode)\n                }\n            }\n        }\n\n        q = q[levelCnt:len(q)]\n        depth++\n    }\n    return depth\n}",
    "id": "234710925",
    "lang": "golang",
    "memory": "3.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "774",
     "title": "Maximum Depth of N-ary Tree",
     "titleSlug": "maximum-depth-of-n-ary-tree",
     "translatedTitle": "N 叉树的最大深度"
    },
    "rawMemory": "3528000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/maximum-depth-of-n-ary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635839201,
    "totalTestCaseCnt": 38
   }
  },
  "maximum-frequency-stack": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class FreqStack {\npublic:\n    FreqStack() {\n        max_freq_ = 0;\n    }\n    \n    void push(int val) {\n        int cntofval = 1 + freqs_[val];\n        max_freq_ = std::max(max_freq_, cntofval);\n        freqs_[val] = cntofval;\n        stacks_[cntofval].push(val);\n    }\n    \n    int pop() {\n        if (stacks_[max_freq_].size() == 0) {\n            throw \"no value\";\n        }\n        int top = stacks_[max_freq_].top();\n        stacks_[max_freq_].pop();\n        freqs_[top]--;\n        if (stacks_[max_freq_].size() == 0) max_freq_--;\n        return top;\n    }\nprivate:\n    std::unordered_map\u003cint, int\u003e freqs_;\n    std::unordered_map\u003cint, std::stack\u003cint\u003e\u003e stacks_;\n    int max_freq_;\n};\n\n/**\n * Your FreqStack object will be instantiated and called as such:\n * FreqStack* obj = new FreqStack();\n * obj-\u003epush(val);\n * int param_2 = obj-\u003epop();\n */",
    "id": "265126125",
    "lang": "cpp",
    "memory": "84.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 37,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "931",
     "title": "Maximum Frequency Stack",
     "titleSlug": "maximum-frequency-stack",
     "translatedTitle": "最大频率栈"
    },
    "rawMemory": "86340000",
    "runtime": "148 ms",
    "sourceUrl": "/problems/maximum-frequency-stack/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "ok",
     "flagType": "ORANGE"
    },
    "timestamp": 1644118374,
    "totalTestCaseCnt": 38
   }
  },
  "maximum-lcci": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maximum(int a, int b) {\n        long _sum = long(a) + long(b);\n        long _diff = long(a) - long(b);\n        long _abs_diff = (_diff ^ (_diff \u003e\u003e 63)) - (_diff \u003e\u003e 63);\n        return (_sum + _abs_diff) / 2;\n    }\n};",
    "id": "231740450",
    "lang": "cpp",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 103,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100349",
     "title": "Maximum LCCI",
     "titleSlug": "maximum-lcci",
     "translatedTitle": "最大数值"
    },
    "rawMemory": "6008000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/maximum-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635010112,
    "totalTestCaseCnt": 103
   }
  },
  "maximum-number-of-balloons": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maxNumberOfBalloons(string text) {\n        int freq[128] = {0,};\n        for (auto c : text) {\n            freq[c]++;\n        }\n        int m1 = std::min(freq['l']/2, freq['o']/2);\n        return std::min({freq['b'], freq['a'], freq['n'], m1});\n    }\n};",
    "id": "267637165",
    "lang": "cpp",
    "memory": "6.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 25,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1297",
     "title": "Maximum Number of Balloons",
     "titleSlug": "maximum-number-of-balloons",
     "translatedTitle": "“气球” 的最大数量"
    },
    "rawMemory": "6752000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/maximum-number-of-balloons/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644714375,
    "totalTestCaseCnt": 25
   }
  },
  "maximum-product-of-three-numbers": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maximumProduct(vector\u003cint\u003e\u0026 nums) {        \n        if (nums.size() \u003c 3) {\n            return 0;\n        }\n        sort(nums.begin(), nums.end());\n        int a = nums[nums.size() - 1] * nums[nums.size() - 2] * nums[nums.size() - 3];\n        int b = nums[nums.size() - 1]* nums[0] * nums[1];\n        return a \u003e b ? a : b;\n    }\n};",
    "id": "10188071",
    "lang": "cpp",
    "memory": "1.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 83,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "628",
     "title": "Maximum Product of Three Numbers",
     "titleSlug": "maximum-product-of-three-numbers",
     "translatedTitle": "三个数的最大乘积"
    },
    "rawMemory": "1503232",
    "runtime": "56 ms",
    "sourceUrl": "/problems/maximum-product-of-three-numbers/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544100337,
    "totalTestCaseCnt": 92
   }
  },
  "maximum-subarray": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maxSubArray(vector\u003cint\u003e\u0026 nums) {\n        int max_sum = nums[0];\n        int sum = nums[0];\n        for (int i = 1; i \u003c nums.size(); i++) {\n            if (sum \u003c 0) {\n                sum = nums[i];\n            } else {\n                sum += nums[i];\n            }\n\n            if (sum \u003e max_sum) {\n                max_sum = sum;\n            }\n        }\n        return max_sum;\n    }\n};",
    "id": "267489215",
    "lang": "cpp",
    "memory": "66.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 209,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "53",
     "title": "Maximum Subarray",
     "titleSlug": "maximum-subarray",
     "translatedTitle": "最大子数组和"
    },
    "rawMemory": "67728000",
    "runtime": "92 ms",
    "sourceUrl": "/problems/maximum-subarray/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644663006,
    "totalTestCaseCnt": 209
   }
  },
  "maximum-twin-sum-of-a-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int pairSum(ListNode* head) {\n        vector\u003cint\u003e vec;\n        for (auto p = head; p; p = p-\u003enext) {\n            vec.push_back(p-\u003eval);\n        }\n        int sum = 0;\n        for (int i = 0; i \u003c vec.size()/2; i++) {\n            sum = std::max(sum, vec[i] + vec[vec.size()-1-i]);\n        }\n        return sum;\n    }\n};",
    "id": "265039858",
    "lang": "cpp",
    "memory": "123.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 46,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "2236",
     "title": "Maximum Twin Sum of a Linked List",
     "titleSlug": "maximum-twin-sum-of-a-linked-list",
     "translatedTitle": "链表最大孪生和"
    },
    "rawMemory": "126720000",
    "runtime": "204 ms",
    "sourceUrl": "/problems/maximum-twin-sum-of-a-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644074834,
    "totalTestCaseCnt": 46
   }
  },
  "median-of-two-sorted-arrays": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) {\n        for (auto n1 : nums1) {\n            nums2.push_back(n1);\n        }\n        sort(nums2.begin(), nums2.end());\n        if (nums2.size() % 2) {\n            return nums2[nums2.size() / 2];\n        }\n\n        return (nums2[nums2.size() / 2] + nums2[nums2.size() / 2 - 1]) / 2.0;\n    }\n};",
    "id": "268810480",
    "lang": "cpp",
    "memory": "87.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 2094,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "4",
     "title": "Median of Two Sorted Arrays",
     "titleSlug": "median-of-two-sorted-arrays",
     "translatedTitle": "寻找两个正序数组的中位数"
    },
    "rawMemory": "89284000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/median-of-two-sorted-arrays/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644936690,
    "totalTestCaseCnt": 2094
   }
  },
  "meeting-rooms": {
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func canAttendMeetings(intervals [][]int) bool {\n    sort.Slice(intervals, func(i, j int) bool {\n        return intervals[i][0] \u003c intervals[j][0]\n    })\n    for i := 0; i \u003c len(intervals)-1; i++ {\n        cur, next := intervals[i][1], intervals[i+1][0]\n        if cur \u003e next {\n            return false\n        }\n    }\n    return true\n}",
    "id": "265758038",
    "lang": "golang",
    "memory": "4.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 78,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "252",
     "title": "Meeting Rooms",
     "titleSlug": "meeting-rooms",
     "translatedTitle": "会议室"
    },
    "rawMemory": "4192000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/meeting-rooms/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "不错啊。",
     "flagType": "BLUE"
    },
    "timestamp": 1644291878,
    "totalTestCaseCnt": 78
   }
  },
  "merge-in-between-linked-lists": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\n    struct ListNode *ap = list1, *bp = list1;\n    struct ListNode* head = list1;\n    for (int i = 0; list1; list1 = list1-\u003enext, i++) {\n        if (i == a - 1) ap = list1;\n        if (i == b + 1) bp = list1;\n    }\n    ap-\u003enext = list2;\n    for (; list2-\u003enext; list2 = list2-\u003enext);\n    list2-\u003enext = bp;\n    return head;\n}",
    "id": "265046223",
    "lang": "c",
    "memory": "32.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1765",
     "title": "Merge In Between Linked Lists",
     "titleSlug": "merge-in-between-linked-lists",
     "translatedTitle": "合并两个链表"
    },
    "rawMemory": "32952000",
    "runtime": "124 ms",
    "sourceUrl": "/problems/merge-in-between-linked-lists/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644076144,
    "totalTestCaseCnt": 61
   }
  },
  "merge-intervals": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e merge(vector\u003cvector\u003cint\u003e\u003e\u0026 intervals) {\n        if (intervals.size() == 0) return {};\n        vector\u003cvector\u003cint\u003e\u003e res;\n        std::sort(intervals.begin(), intervals.end());\n\n        for (int i = 0, k = 0, end = 0; i \u003c intervals.size(); ) {\n            k = i + 1;\n            end = intervals[i].back();\n            while (k \u003c intervals.size() \u0026\u0026 intervals[k].front() \u003c= end) {\n                end = std::max(end, intervals[k].back());\n                k++;\n            }\n            res.push_back({intervals[i].front(), end});\n            i = k;\n        }\n\n        return res;\n    }\n};",
    "id": "266377926",
    "lang": "cpp",
    "memory": "18.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 169,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "56",
     "title": "Merge Intervals",
     "titleSlug": "merge-intervals",
     "translatedTitle": "合并区间"
    },
    "rawMemory": "19024000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/merge-intervals/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "方法是对的。",
     "flagType": "BLUE"
    },
    "timestamp": 1644413006,
    "totalTestCaseCnt": 168
   }
  },
  "merge-k-sorted-lists": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\nclass CompareListNode{\npublic:\n    bool operator()(ListNode* node1, ListNode* node2){\n        return node1-\u003eval \u003e node2-\u003eval;\n    }\n};\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) {\n        if(lists.size() == 0)\n            return NULL;\n\n        ListNode* dummyHead = new ListNode(-1);\n        ListNode* curNode = dummyHead;\n\n        priority_queue\u003cListNode*, vector\u003cListNode*\u003e, CompareListNode\u003e q;\n        for(ListNode* node: lists)\n            if(node != NULL)\n                q.push(node);\n\n        while(!q.empty()){\n\n            ListNode* nextNode = q.top();\n            q.pop();\n\n\n            curNode-\u003enext = nextNode;\n            if(nextNode-\u003enext != NULL)\n                q.push(nextNode-\u003enext);\n\n            nextNode-\u003enext = NULL;\n            curNode = curNode-\u003enext;\n        }\n\n        ListNode* ret = dummyHead-\u003enext;\n        delete dummyHead;\n        return ret;\n    }\n};",
    "id": "10424419",
    "lang": "cpp",
    "memory": "2.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 131,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "23",
     "title": "Merge k Sorted Lists",
     "titleSlug": "merge-k-sorted-lists",
     "translatedTitle": "合并K个升序链表"
    },
    "rawMemory": "2490368",
    "runtime": "24 ms",
    "sourceUrl": "/problems/merge-k-sorted-lists/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544681758,
    "totalTestCaseCnt": 133
   }
  },
  "merge-sorted-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) {\n\n        assert(nums1.size() == m + n \u0026\u0026 nums2.size() == n);\n\n        for(int i = n + m - 1 ; i \u003e= n ; i -- )\n            nums1[i] = nums1[i - n];\n\n        int i = n;  // pointer for nums1 [n, n+m)\n        int j = 0;  // pointer for nums2 [0, n)\n        int k = 0;  // pointer merged nums1 [0, n+m)\n        while( k \u003c n + m ){\n            if( i \u003e= n+m )\n                nums1[k++] = nums2[j++];\n            else if( j \u003e= n )\n                nums1[k++] = nums1[i++];\n            else if( nums1[i] \u003c nums2[j] )\n                nums1[k++] = nums1[i++];\n            else\n                nums1[k++] = nums2[j++];\n        }\n    }\n};\n",
    "id": "9862369",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 59,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "88",
     "title": "Merge Sorted Array",
     "titleSlug": "merge-sorted-array",
     "translatedTitle": "合并两个有序数组"
    },
    "rawMemory": "N/A",
    "runtime": "20 ms",
    "sourceUrl": "/problems/merge-sorted-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543394418,
    "totalTestCaseCnt": 59
   }
  },
  "merge-two-binary-trees": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        TreeNode* new_tr = NULL;\n        if (t1 == NULL \u0026\u0026 t2 == NULL) {\n            return NULL;\n        } if (t1 != NULL \u0026\u0026 t2 != NULL) {\n            t1-\u003eval += t2-\u003eval;\n            new_tr = t1;\n            new_tr-\u003eleft = mergeTrees(t2-\u003eleft, t1-\u003eleft);\n            new_tr-\u003eright = mergeTrees(t2-\u003eright, t1-\u003eright);\n        } else if (t1) {\n            new_tr = t1;\n            new_tr-\u003eleft = mergeTrees(t1-\u003eleft, NULL);\n            new_tr-\u003eright = mergeTrees(t1-\u003eright, NULL);\n        } else {\n            new_tr = t2;\n            new_tr-\u003eleft = mergeTrees(t2-\u003eleft, NULL);\n            new_tr-\u003eright = mergeTrees(t2-\u003eright, NULL);\n        }\n        return new_tr;\n    }\n};",
    "id": "10187535",
    "lang": "cpp",
    "memory": "2.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 183,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "617",
     "title": "Merge Two Binary Trees",
     "titleSlug": "merge-two-binary-trees",
     "translatedTitle": "合并二叉树"
    },
    "rawMemory": "2736128",
    "runtime": "36 ms",
    "sourceUrl": "/problems/merge-two-binary-trees/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544099736,
    "totalTestCaseCnt": 182
   }
  },
  "merge-two-sorted-lists": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* l3 = \u0026dummy;\n        while (list1 \u0026\u0026 list2) {\n            if (list1-\u003eval \u003e list2-\u003eval) {\n                l3-\u003enext = list2;\n                list2 = list2-\u003enext;\n            } else {\n                l3-\u003enext = list1;\n                list1 = list1-\u003enext;\n            }\n            l3 = l3-\u003enext;\n        }\n        if (list1) {\n            l3-\u003enext = list1;\n        } else {\n            l3-\u003enext = list2;\n        }\n\n        return dummy.next;\n    }\n};",
    "id": "266203188",
    "lang": "cpp",
    "memory": "14.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "21",
     "title": "Merge Two Sorted Lists",
     "titleSlug": "merge-two-sorted-lists",
     "translatedTitle": "合并两个有序链表"
    },
    "rawMemory": "14776000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/merge-two-sorted-lists/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644389136,
    "totalTestCaseCnt": 208
   }
  },
  "middle-of-the-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != NULL) {\n            if (fast-\u003enext != NULL) {\n                slow = slow-\u003enext;\n                fast = fast-\u003enext-\u003enext;\n            } else {\n                fast = NULL;\n            }\n        }\n        return slow;\n    }\n};",
    "id": "10357447",
    "lang": "cpp",
    "memory": "884.7 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 15,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "908",
     "title": "Middle of the Linked List",
     "titleSlug": "middle-of-the-linked-list",
     "translatedTitle": "链表的中间结点"
    },
    "rawMemory": "884736",
    "runtime": "0 ms",
    "sourceUrl": "/problems/middle-of-the-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544519000,
    "totalTestCaseCnt": 36
   }
  },
  "min-stack": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class MinStack {\npublic:\n    MinStack() {\n\n    }\n    \n    void push(int val) {\n        if (stack_.empty()) {\n            stack_.push({val, val});\n        } else {\n            stack_.push({val, std::min(val, stack_.top().second)});\n        }\n    }\n    \n    void pop() {\n        stack_.pop();\n    }\n    \n    int top() {\n        return stack_.top().first;\n    }\n    \n    int getMin() {\n        return stack_.top().second;\n    }\nprivate:\n    std::stack\u003cstd::pair\u003cint,int\u003e\u003e stack_;\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj-\u003epush(val);\n * obj-\u003epop();\n * int param_3 = obj-\u003etop();\n * int param_4 = obj-\u003egetMin();\n */",
    "id": "265301948",
    "lang": "cpp",
    "memory": "15.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "155",
     "title": "Min Stack",
     "titleSlug": "min-stack",
     "translatedTitle": "最小栈"
    },
    "rawMemory": "16276000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/min-stack/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644157537,
    "totalTestCaseCnt": 31
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "type MinStack struct {\n    data []int\n}\n\n\nfunc Constructor() MinStack {\n    return MinStack {\n        data : make([]int, 0, 512),\n    }\n}\n\n\nfunc (this *MinStack) Push(val int)  {\n    if len(this.data) == 0 {\n        this.data = append(this.data, val, val)\n    } else {\n        min := this.GetMin()\n        min = func(a, b int) int {\n            if  a \u003e b {\n                return b\n            }\n            return a\n        }(min, val)\n        this.data = append(this.data, min, val)\n    }\n}\n\n\nfunc (this *MinStack) Pop()  {\n    dataSize := len(this.data)\n    if dataSize \u003c 2 {\n        return\n    }\n\n    this.data = this.data[0: dataSize-2]\n}\n\n\nfunc (this *MinStack) Top() int {\n    return this.data[len(this.data) - 1]\n}\n\n\nfunc (this *MinStack) GetMin() int {\n    return this.data[len(this.data) - 2]\n}\n\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(val);\n * obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.GetMin();\n */",
    "id": "234780319",
    "lang": "golang",
    "memory": "8.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 31,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "155",
     "title": "Min Stack",
     "titleSlug": "min-stack",
     "translatedTitle": "最小栈"
    },
    "rawMemory": "8432000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/min-stack/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635851566,
    "totalTestCaseCnt": 31
   }
  },
  "minimum-ascii-delete-sum-for-two-strings": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        vector\u003cvector\u003cint\u003e\u003e dp(s1.size()+1, vector\u003cint\u003e(s2.size()+1));\n        \n        for (int i = 1; i \u003c= s1.size(); i++) \n            dp[i][0] = s1[i-1] + dp[i-1][0];\n\n        for (int i = 1; i \u003c= s2.size(); i++) \n            dp[0][i] = s2[i-1] + dp[0][i-1];\n\n        for (int i = 1; i \u003c= s1.size(); i++) {\n            for (int j = 1; j \u003c= s2.size(); j++) {\n                if (s1[i-1] == s2[j-1]) {\n                    dp[i][j] = dp[i-1][j-1];\n                } else {\n                    dp[i][j] = std::min(s1[i-1] + dp[i-1][j], s2[j-1] + dp[i][j-1]);\n                }\n            }\n        }\n        return dp[s1.size()][s2.size()];\n    }\n};",
    "id": "261739019",
    "lang": "cpp",
    "memory": "14.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 93,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "712",
     "title": "Minimum ASCII Delete Sum for Two Strings",
     "titleSlug": "minimum-ascii-delete-sum-for-two-strings",
     "translatedTitle": "两个字符串的最小ASCII删除和"
    },
    "rawMemory": "15284000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/minimum-ascii-delete-sum-for-two-strings/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642964310,
    "totalTestCaseCnt": 93
   }
  },
  "minimum-depth-of-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        queue\u003cpair\u003cTreeNode*, int\u003e\u003e q;\n        int min = 0;\n\n        q.push({root, 1});\n        while (root !=  nullptr \u0026\u0026 !q.empty()) {\n            auto tp = q.front(); q.pop();\n            auto node = tp.first;\n            auto level = tp.second;\n            if (node-\u003eleft == nullptr \u0026\u0026 node-\u003eright == nullptr) {\n                return level;\n            }\n            if (node-\u003eleft != nullptr) q.push({node-\u003eleft, level + 1});\n            if (node-\u003eright != nullptr) q.push({node-\u003eright, level + 1});\n        }\n\n        return min;\n    }\n};",
    "id": "234648140",
    "lang": "cpp",
    "memory": "141.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 52,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "111",
     "title": "Minimum Depth of Binary Tree",
     "titleSlug": "minimum-depth-of-binary-tree",
     "translatedTitle": "二叉树的最小深度"
    },
    "rawMemory": "144692000",
    "runtime": "220 ms",
    "sourceUrl": "/problems/minimum-depth-of-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635826801,
    "totalTestCaseCnt": 52
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc minDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    if root.Left == nil \u0026\u0026 root.Right == nil {\n        return 1\n    }\n\n    lMinDepth := minDepth(root.Left)\n    rMinDepth := minDepth(root.Right)\n    if lMinDepth == 0 {\n        // 左子树为空\n        return rMinDepth + 1\n    } \n    if rMinDepth == 0 {\n        // 右子树为空\n        return lMinDepth + 1\n    }\n    return min(lMinDepth, rMinDepth) + 1\n}\n\nfunc min(a, b int) int {\n    if a \u003e b {\n        return b\n    }\n    return a\n}",
    "id": "234655058",
    "lang": "golang",
    "memory": "20.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 52,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "111",
     "title": "Minimum Depth of Binary Tree",
     "titleSlug": "minimum-depth-of-binary-tree",
     "translatedTitle": "二叉树的最小深度"
    },
    "rawMemory": "20544000",
    "runtime": "188 ms",
    "sourceUrl": "/problems/minimum-depth-of-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635829234,
    "totalTestCaseCnt": 52
   }
  },
  "minimum-height-tree-lcci": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector\u003cint\u003e\u0026 nums) {\n        return helper(0, nums.size(), nums);\n    }\n\n    TreeNode* helper(int left, int right, vector\u003cint\u003e\u0026 nums) {\n        if (left \u003e= right) return nullptr; \n        int mid = (left + right) \u003e\u003e 1;\n        TreeNode* node = new TreeNode(nums[mid]);\n        node-\u003eleft = helper(left, mid, nums);\n        node-\u003eright = helper(mid+1, right, nums);\n\n        return node;\n    }\n};",
    "id": "277949231",
    "lang": "cpp",
    "memory": "23.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 32,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100174",
     "title": "Minimum Height Tree LCCI",
     "titleSlug": "minimum-height-tree-lcci",
     "translatedTitle": "最小高度树"
    },
    "rawMemory": "24404000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/minimum-height-tree-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "注意左闭右开！！！",
     "flagType": "BLUE"
    },
    "timestamp": 1646495083,
    "totalTestCaseCnt": 32
   }
  },
  "minimum-path-sum": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int minPathSum(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n        int m = grid.size(), n = grid.front().size();\n        if (m == 0 || n == 0) {\n            return 0;\n        }\n        \n        // 初始化矩阵\n        vector\u003cvector\u003cint\u003e\u003e stepSum(m+1, vector\u003cint\u003e(n+1, INT_MAX));\n        \n        int from = 0;\n        for (int j = 1; j \u003c= m; j++) {\n            for (int k = 1; k \u003c= n; k++) {\n                if (j != 1 || k != 1) \n                    from = std::min(stepSum[j][k-1], stepSum[j-1][k]);\n                stepSum[j][k] = grid[j-1][k-1] + from;\n            }\n        }\n\n        return stepSum[m][n];\n    }\n};",
    "id": "257126506",
    "lang": "cpp",
    "memory": "9.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "64",
     "title": "Minimum Path Sum",
     "titleSlug": "minimum-path-sum",
     "translatedTitle": "最小路径和"
    },
    "rawMemory": "10016000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/minimum-path-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "",
     "flagType": "RED"
    },
    "timestamp": 1641831206,
    "totalTestCaseCnt": 61
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int width = grid[0].length, high = grid.length;\n        if (high == 0 || width == 0) return 0;\n        // 初始化\n        for (int i = 1; i \u003c high; i++) grid[i][0] += grid[i - 1][0];\n        for (int i = 1; i \u003c width; i++) grid[0][i] += grid[0][i - 1];\n        for (int i = 1; i \u003c high; i++)\n            for (int j = 1; j \u003c width; j++)\n                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        return grid[high - 1][width - 1];\n    }\n}",
    "id": "257128059",
    "lang": "java",
    "memory": "41.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "64",
     "title": "Minimum Path Sum",
     "titleSlug": "minimum-path-sum",
     "translatedTitle": "最小路径和"
    },
    "rawMemory": "42048000",
    "runtime": "2 ms",
    "sourceUrl": "/problems/minimum-path-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "可以",
     "flagType": "RED"
    },
    "timestamp": 1641831635,
    "totalTestCaseCnt": 61
   }
  },
  "minimum-size-subarray-sum": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int minSubArrayLen(int s, vector\u003cint\u003e \u0026nums) {\n        int l = 0, r = -1;\n        int sum = 0;\n        int ret = nums.size() + 1;\n\n        while (l \u003c nums.size()) {\n            if (r + 1 \u003c nums.size() \u0026\u0026 sum \u003c s) {\n                sum += nums[++r];\n            } else {\n                sum -= nums[l++];\n            }\n\n            if (sum \u003e= s) {\n                ret = std::min(ret, r-l+1);\n            }\n        }\n        if (ret \u003e nums.size()) ret = 0;\n        return ret;\n    }\n};\n",
    "id": "9883976",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 15,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "209",
     "title": "Minimum Size Subarray Sum",
     "titleSlug": "minimum-size-subarray-sum",
     "translatedTitle": "长度最小的子数组"
    },
    "rawMemory": "N/A",
    "runtime": "8 ms",
    "sourceUrl": "/problems/minimum-size-subarray-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543419625,
    "totalTestCaseCnt": 19
   }
  },
  "missing-number": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int missingNumber(int* nums, int numsSize) {\n    int result = 0;\n    for (int i = 0; i \u003c numsSize; i++)\n        result ^= nums[i]^(i+1);\n    return result;\n}",
    "id": "8298605",
    "lang": "c",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 122,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "268",
     "title": "Missing Number",
     "titleSlug": "missing-number",
     "translatedTitle": "丢失的数字"
    },
    "rawMemory": "N/A",
    "runtime": "8 ms",
    "sourceUrl": "/problems/missing-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539617266,
    "totalTestCaseCnt": 122
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int missingNumber(vector\u003cint\u003e\u0026 nums) {\n        auto sum = std::accumulate(nums.begin(), nums.end(), 0);\n        auto size = nums.size();\n        return  (size * (size + 1) /2) - sum;\n    }\n};",
    "id": "8298371",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 122,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "268",
     "title": "Missing Number",
     "titleSlug": "missing-number",
     "translatedTitle": "丢失的数字"
    },
    "rawMemory": "N/A",
    "runtime": "20 ms",
    "sourceUrl": "/problems/missing-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539616813,
    "totalTestCaseCnt": 122
   }
  },
  "missing-ranges": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution\n{\npublic:\n    vector\u003cstring\u003e findMissingRanges(vector\u003cint\u003e\u0026 nums, int lower, int upper) {\n        int n = nums.size();\n        int L = lower;\n        vector\u003cstring\u003e res;\n        for (int i = 0; i \u003c n; i ++) {\n            if (L == nums[i]) {\n                L ++;\n            } else {\n                if (L \u003c nums[i] - 1) {\n                    res.push_back(to_string(L) + \"-\u003e\" + to_string(nums[i] - 1));\n                } else if (L == nums[i] - 1) {\n                    res.push_back(to_string(L));\n                }\n\n                L = nums[i] + 1;\n            }\n        }\n        if (L \u003c upper)\n            res.push_back(to_string(L) + \"-\u003e\" + to_string(upper));\n        if (L == upper)\n            res.push_back(to_string(L));        \n        return res;\n    }\n};\n",
    "id": "265680237",
    "lang": "cpp",
    "memory": "6.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "163",
     "title": "Missing Ranges",
     "titleSlug": "missing-ranges",
     "translatedTitle": "缺失的区间"
    },
    "rawMemory": "7072000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/missing-ranges/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "牛逼啊。\n自己没写出来啊。最开始的思路就是这个。",
     "flagType": "BLUE"
    },
    "timestamp": 1644251496,
    "totalTestCaseCnt": 38
   }
  },
  "most-common-word": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string mostCommonWord(string paragraph, vector\u003cstring\u003e\u0026 banned) {\n        string res;\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\n        unordered_set\u003cstring\u003e ban(banned.begin(), banned.end());\n        vector\u003cstring\u003e words;\n        unordered_map\u003cstring, int\u003e freq;\n\n        bool next_islower = false, pre_islower = false;\n        int b = 0, e = 0;\n        int max_cnt = 0;\n        for (int i = 0; i \u003c paragraph.size(); i++) {\n            next_islower = islower(paragraph[i + 1]);\n            if (islower(paragraph[i])) {\n                if (!pre_islower) {\n                    b = i;\n                }\n                if (!next_islower) {\n                    e = i + 1;\n                    string word = paragraph.substr(b, e - b);\n                    if (ban.find(word) == ban.end()) {\n                        freq[word] += 1;\n                        if (freq[word] \u003e max_cnt) {\n                            max_cnt = freq[word];\n                            res = word;\n                        }\n                    }\n                }\n                pre_islower = true;\n            } else {\n                pre_islower = false;\n            }\n        }\n\n        return res;\n    }\n};",
    "id": "10498560",
    "lang": "cpp",
    "memory": "1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "837",
     "title": "Most Common Word",
     "titleSlug": "most-common-word",
     "translatedTitle": "最常见的单词"
    },
    "rawMemory": "1040384",
    "runtime": "4 ms",
    "sourceUrl": "/problems/most-common-word/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544867477,
    "totalTestCaseCnt": 47
   }
  },
  "move-zeroes": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void moveZeroes(vector\u003cint\u003e\u0026 nums) {\n        int k = 0;\n        for (int j = 0; j \u003c nums.size(); j++) {\n            if (nums[j] != 0) {\n                if (j != k) {\n                    std::swap(nums[k], nums[j]);   \n                }\n                k++;\n            }\n        }\n    }\n};",
    "id": "262801621",
    "lang": "cpp",
    "memory": "18.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 74,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "283",
     "title": "Move Zeroes",
     "titleSlug": "move-zeroes",
     "translatedTitle": "移动零"
    },
    "rawMemory": "19208000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/move-zeroes/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643260215,
    "totalTestCaseCnt": 74
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func moveZeroes(nums []int) {\n\tk := 0\n\tfor i := range nums {\n\t\tif nums[i] != 0 {\n\t\t\tif i != k {\n\t\t\t\tnums[i], nums[k] = nums[k], nums[i]\n\t\t\t}\n\t\t\tk++\n\t\t}\n\t}\n}",
    "id": "179951347",
    "lang": "golang",
    "memory": "3.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "283",
     "title": "Move Zeroes",
     "titleSlug": "move-zeroes",
     "translatedTitle": "移动零"
    },
    "rawMemory": "3768000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/move-zeroes/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621699950,
    "totalTestCaseCnt": 74
   }
  },
  "moving-average-from-data-stream": {
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "type MovingAverage struct {\n    cnt     int\n    data    []int\n}\n\n\nfunc Constructor(size int) MovingAverage {\n    return MovingAverage{\n        data : make([]int, size),\n    }\n}\n\n\nfunc (this *MovingAverage) Next(val int) float64 {\n    dataSize := len(this.data)\n    this.data[this.cnt % dataSize] = val\n\n    var sum int\n    for _, v := range this.data {\n        sum += v\n    }\n    this.cnt++\n\n    if this.cnt \u003e dataSize {\n        return float64(sum) / float64(dataSize) \n    } else {\n        return float64(sum) / float64(this.cnt)\n    }\n}\n\n\n/**\n * Your MovingAverage object will be instantiated and called as such:\n * obj := Constructor(size);\n * param_1 := obj.Next(val);\n */",
    "id": "234792854",
    "lang": "golang",
    "memory": "7.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 11,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "346",
     "title": "Moving Average from Data Stream",
     "titleSlug": "moving-average-from-data-stream",
     "translatedTitle": "数据流中的移动平均值"
    },
    "rawMemory": "7436000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/moving-average-from-data-stream/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635853853,
    "totalTestCaseCnt": 11
   }
  },
  "multiply-strings": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n\n    string reverse_str(string num) {\n        string res = num;\n        if (num.size() == 0) return res;\n        int l = 0, r = num.size() - 1;\n        while (l \u003c r) {\n            swap(res[l++], res[r--]);\n        }\n        return res;\n    }\n\n    string multiply(string num1, string num2) {\n        //mul1是乘法式子中上面的数字，mul2是下面的。\n        string mul1 = reverse_str(num1), mul2 = reverse_str(num2);\n        if (mul2.size() \u003e mul1.size()) {\n            mul1 = mul2;\n            mul2 = reverse_str(num1);\n        }\n        //vector\u003cint\u003e res(0, mul1.size() + mul2.size());\n        vector\u003cint\u003e res;\n\n        for (int i = 0; i \u003c mul2.size(); i++) {\n            int n2 = mul2[i] - 0x30;\n            int carry = 0;\n            for (int j = 0; j \u003c mul1.size(); j++) {\n                if (i + j \u003e= res.size()) res.push_back(0);\n                int n1 = mul1[j] - 0x30;\n                int mul_n = (n1 * n2 + carry + res[i + j]) % 10;\n                carry = (n1 * n2 + carry + res[i + j]) / 10;\n                res[i + j] = mul_n;\n            }\n            if (carry) {\n                res.push_back(carry);\n            }\n        }\n\n        string s;\n        auto it = res.rbegin();\n        for (; it != res.rend(); it++) {\n            if (*it != 0) break;\n        }\n        for (auto it_skip_zero = it; it_skip_zero != res.rend(); it_skip_zero++) {\n            s += to_string(*it_skip_zero);\n        }\n        if (s.size() == 0) return \"0\";\n        return s;\n    }\n};",
    "id": "11097967",
    "lang": "cpp",
    "memory": "2.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 311,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "43",
     "title": "Multiply Strings",
     "titleSlug": "multiply-strings",
     "translatedTitle": "字符串相乘"
    },
    "rawMemory": "2113536",
    "runtime": "8 ms",
    "sourceUrl": "/problems/multiply-strings/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1546317143,
    "totalTestCaseCnt": 311
   }
  },
  "n-ary-tree-level-order-traversal": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector\u003cNode*\u003e children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector\u003cNode*\u003e _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e levelOrder(Node* root) {\n        queue\u003cNode*\u003e _q;\n        auto pushq = [\u0026](Node* node) {\n            if (node) _q.push(node);\n        };\n\n        pushq(root);\n        vector\u003cvector\u003cint\u003e\u003e res;\n        vector\u003cint\u003e tmp;\n        while (_q.size() \u003e 0) {\n            int n = _q.size();\n            tmp.clear();\n            for (int i = 0; i \u003c n; i++) {\n                Node* node = _q.front(); \n                tmp.push_back(node-\u003eval);\n                for (auto\u0026 child : node-\u003echildren) {\n                    pushq(child);\n                }\n                _q.pop();\n            }\n            res.emplace_back(tmp);\n        }\n        return res;\n    }\n};",
    "id": "262481314",
    "lang": "cpp",
    "memory": "11.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "764",
     "title": "N-ary Tree Level Order Traversal",
     "titleSlug": "n-ary-tree-level-order-traversal",
     "translatedTitle": "N 叉树的层序遍历"
    },
    "rawMemory": "11852000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/n-ary-tree-level-order-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "队列缓存行。每次取出的个数应该提前获取。否则向队列中push数据后，队列的大小会改变。",
     "flagType": "RED"
    },
    "timestamp": 1643173705,
    "totalTestCaseCnt": 38
   }
  },
  "n-ary-tree-preorder-traversal": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector\u003cNode*\u003e children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector\u003cNode*\u003e _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector\u003cint\u003e preorder(Node* root) {\n        std::stack\u003cNode*\u003e st;\n        std::vector\u003cint\u003e res;\n        auto _push_stack = [\u0026](Node* node) {\n            if (node) st.push(node);\n        };\n        _push_stack(root);\n        while (st.size() \u003e 0) {\n            Node* node = st.top();\n            res.push_back(node-\u003eval);\n            st.pop();\n            \n            for (auto it = node-\u003echildren.rbegin(); \n                    it != node-\u003echildren.rend(); it++) {\n                _push_stack(*it);\n            }\n        }\n\n        return res;\n    }\n};",
    "id": "262358318",
    "lang": "cpp",
    "memory": "11 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "775",
     "title": "N-ary Tree Preorder Traversal",
     "titleSlug": "n-ary-tree-preorder-traversal",
     "translatedTitle": "N 叉树的前序遍历"
    },
    "rawMemory": "11308000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/n-ary-tree-preorder-traversal/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "stack 方式",
     "flagType": "RED"
    },
    "timestamp": 1643122481,
    "totalTestCaseCnt": 38
   }
  },
  "n-th-tribonacci-number": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int tribonacci(int n) {\n        int tri[4] = {0,1,};\n        for (int i = 1; i \u003c=n; i++) {\n            tri[0] = tri[1];\n            tri[1] = tri[2];\n            tri[2] = tri[3];\n            tri[3] = tri[0] + tri[1] + tri[2];\n        }\n        return tri[3];\n    }\n};",
    "id": "266427243",
    "lang": "cpp",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1236",
     "title": "N-th Tribonacci Number",
     "titleSlug": "n-th-tribonacci-number",
     "translatedTitle": "第 N 个泰波那契数"
    },
    "rawMemory": "5992000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/n-th-tribonacci-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644419998,
    "totalTestCaseCnt": 39
   }
  },
  "next-greater-element-i": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e nextGreaterElement(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) {\n        stack\u003cint\u003e st;\n        map\u003cint, int\u003e greaterMap;\n\n        for (auto\u0026 n : nums2) {\n            while (!st.empty() \u0026\u0026 n \u003e st.top()) {\n                greaterMap[st.top()] = n;\n                st.pop();\n            }\n            st.push(n);\n        }\n        \n        vector\u003cint\u003e res;\n        for (auto\u0026 n : nums1) {\n            auto itr = greaterMap.find(n);\n            if (itr != greaterMap.end()) {\n                res.push_back(itr-\u003esecond);\n            } else {\n                res.push_back(-1);\n            }\n        }\n\n        return res;\n    }\n};",
    "id": "262099194",
    "lang": "cpp",
    "memory": "8.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 15,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "496",
     "title": "Next Greater Element I",
     "titleSlug": "next-greater-element-i",
     "translatedTitle": "下一个更大元素 I"
    },
    "rawMemory": "9060000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/next-greater-element-i/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "最小栈解法",
     "flagType": "RED"
    },
    "timestamp": 1643077364,
    "totalTestCaseCnt": 15
   }
  },
  "nim-game": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "bool canWinNim(int n){\n    return n % 4 != 0;\n}",
    "id": "264005022",
    "lang": "c",
    "memory": "5.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "292",
     "title": "Nim Game",
     "titleSlug": "nim-game",
     "translatedTitle": "Nim 游戏"
    },
    "rawMemory": "5384000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/nim-game/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "",
     "flagType": "RED"
    },
    "timestamp": 1643665018,
    "totalTestCaseCnt": 60
   }
  },
  "number-complement": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int findComplement(int num) {\n        int f = 1;\n        // find (2^n -1), n is highest bit \n        while (f \u003c num) {\n            f \u003c\u003c= 1;\n            f++;\n        }\n        return f ^ num; // or return f \u0026 (~num);\n    }\n};",
    "id": "262514903",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 149,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "476",
     "title": "Number Complement",
     "titleSlug": "number-complement",
     "translatedTitle": "数字的补数"
    },
    "rawMemory": "5952000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/number-complement/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643179891,
    "totalTestCaseCnt": 149
   }
  },
  "number-of-1-bits": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int ret = 0;\n        while (n \u003e 0) {\n            ret += (n \u0026 1);\n            n \u003e\u003e= 1;\n        }\n        return ret;\n    }\n};",
    "id": "234490319",
    "lang": "cpp",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 601,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "191",
     "title": "Number of 1 Bits",
     "titleSlug": "number-of-1-bits",
     "translatedTitle": "位1的个数"
    },
    "rawMemory": "6040000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/number-of-1-bits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635774320,
    "totalTestCaseCnt": 601
   }
  },
  "number-of-enclaves": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "void dfs(int** grid, int gridSize, int ColSize, int i, int j, int *res) {\n  if (i \u003c 0 || i == gridSize || j \u003c 0 || j == ColSize || grid[i][j] == 0) {\n    return;\n  }\n  *res = *res -1;\n  grid[i][j] = 0;\n  dfs(grid, gridSize, ColSize, i, j - 1, res);\n  dfs(grid, gridSize, ColSize, i - 1, j, res);\n  dfs(grid, gridSize, ColSize, i, j + 1, res);\n  dfs(grid, gridSize, ColSize, i + 1, j, res);\n}\n\nint numEnclaves(int** grid, int gridSize, int* gridColSize){\n  int cnt1 = 0;\n  for (int i = 0; i \u003c gridSize; i++) {\n    for (int j = 0; j \u003c gridColSize[0]; j++) {\n      cnt1 += grid[i][j];\n    }\n  }\n\n  for (int i = 0; i \u003c gridColSize[0]; i++) {\n    dfs(grid, gridSize, gridColSize[0], 0, i, \u0026cnt1);\n    dfs(grid, gridSize, gridColSize[0], gridSize - 1, i, \u0026cnt1);\n  }\n\n  for (int i = 0; i \u003c gridSize; i++) {\n    dfs(grid, gridSize, gridColSize[0], i, 0, \u0026cnt1);\n    dfs(grid, gridSize, gridColSize[0], i, gridColSize[0] - 1, \u0026cnt1);\n  }\n\n  return cnt1;\n}",
    "id": "267479507",
    "lang": "c",
    "memory": "9.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 57,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1073",
     "title": "Number of Enclaves",
     "titleSlug": "number-of-enclaves",
     "translatedTitle": "飞地的数量"
    },
    "rawMemory": "9496000",
    "runtime": "64 ms",
    "sourceUrl": "/problems/number-of-enclaves/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644661377,
    "totalTestCaseCnt": 57
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int numEnclaves(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n      int cnt = 0, m = grid.size(), n = grid.front().size();\n      for (int i = 0; i \u003c m; i++) {\n        for (int j = 0; j \u003c n; j++) {\n          cnt += grid[i][j];\n        }\n      }\n\n      function\u003cvoid(int,int)\u003e dfsSubtract = [\u0026](int i, int j) {\n        if (i \u003c 0 || j \u003c 0 || i == m || j == n || grid[i][j] == 0) {\n          return;\n        }\n        grid[i][j] = 0;\n        cnt--;\n        dfsSubtract(i, j-1);\n        dfsSubtract(i-1, j);\n        dfsSubtract(i, j+1);\n        dfsSubtract(i+1, j);\n      };\n\n      for (int i = 0; i \u003c m; i++) {\n        dfsSubtract(i, 0);\n        dfsSubtract(i, n-1);\n      }\n\n      for (int i = 0; i \u003c n; i++) {\n        dfsSubtract(0, i);\n        dfsSubtract(m - 1, i);\n      }\n      return cnt;\n    }\n};",
    "id": "267473258",
    "lang": "cpp",
    "memory": "21.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 57,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1073",
     "title": "Number of Enclaves",
     "titleSlug": "number-of-enclaves",
     "translatedTitle": "飞地的数量"
    },
    "rawMemory": "21692000",
    "runtime": "60 ms",
    "sourceUrl": "/problems/number-of-enclaves/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "编程要注意啊。",
     "flagType": "ORANGE"
    },
    "timestamp": 1644660098,
    "totalTestCaseCnt": 57
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func numEnclaves(grid [][]int) int {\n    m, n := len(grid), len(grid[0])\n    cnt1 := 0\n    for i := 0; i \u003c m; i++ {\n        for j := 0; j \u003c n; j++ {\n            cnt1 += grid[i][j]\n        }\n    }\n    var dfs func (int, int)\n    dfs = func(i, j int) {\n        if i \u003c 0 || j \u003c 0 || i == m || j == n || grid[i][j] == 0 {\n            return\n        }\n        grid[i][j] = 0\n        cnt1--\n        dfs(i, j - 1)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i + 1, j)\n    }\n\n    for i := 0; i \u003c m; i++ {\n        dfs(i, 0)\n        dfs(i, n - 1)\n    }\n\n    for i := 0; i \u003c n; i++ {\n        dfs(0, i)\n        dfs(m - 1, i)\n    }\n    return cnt1;\n}",
    "id": "267484580",
    "lang": "golang",
    "memory": "6.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 57,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1073",
     "title": "Number of Enclaves",
     "titleSlug": "number-of-enclaves",
     "translatedTitle": "飞地的数量"
    },
    "rawMemory": "6884000",
    "runtime": "48 ms",
    "sourceUrl": "/problems/number-of-enclaves/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "dfs",
     "flagType": "ORANGE"
    },
    "timestamp": 1644662386,
    "totalTestCaseCnt": 57
   }
  },
  "number-of-islands": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int numIslands(vector\u003cvector\u003cchar\u003e\u003e\u0026 grid) {\n        int m = grid.size(), n = grid.front().size();\n        vector\u003cvector\u003cbool\u003e\u003e vis(m, vector\u003cbool\u003e(n, false));\n        int res = 0;\n\n        function\u003cint(int, int)\u003e dfs = [\u0026](int i, int j) {\n            if (i \u003c 0 || j \u003c 0 || i == m || j == n) {\n                return 0;\n            }\n            if (vis[i][j] || grid[i][j] == '0') return 0;\n            vis[i][j] = true;\n            return 1 + dfs(i, j-1) + dfs(i-1,j) + dfs(i+1,j) + dfs(i,j+1);\n        };\n\n        for (int i = 0; i \u003c m; i++) {\n            for (int j = 0; j \u003c n; j++) {\n                if (grid[i][j] == '1') {\n                    res += (dfs(i, j) \u003e 0);\n                }\n            }\n        }\n\n        return res;\n    }\n};",
    "id": "267902191",
    "lang": "cpp",
    "memory": "12.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 49,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "200",
     "title": "Number of Islands",
     "titleSlug": "number-of-islands",
     "translatedTitle": "岛屿数量"
    },
    "rawMemory": "12616000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/number-of-islands/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "dfs",
     "flagType": "PURPLE"
    },
    "timestamp": 1644754102,
    "totalTestCaseCnt": 49
   }
  },
  "number-of-matching-subsequences": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int numMatchingSubseq(string s, vector\u003cstring\u003e\u0026 words) {\n        if (words.size() == 0 || s.size() == 0) return 0;\n        vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003e w(128);\n        for (int i = 0; i \u003c words.size(); i++) {\n            auto \u0026word = words[i];\n            w[word.front()].push_back({i, 0});\n        }\n\n        int cnt = 0;\n        vector\u003cpair\u003cint, int\u003e\u003e tmp;\n        for (auto c : s) {\n            tmp.clear();\n            tmp.swap(w[c]);\n\n            for (auto \u0026p : tmp) {\n                size_t indexInWords = p.first;\n                size_t indexOfWord = p.second + 1;\n                if (indexOfWord != words[indexInWords].size()) {\n                    w[words[indexInWords][indexOfWord]].push_back({indexInWords, indexOfWord});\n                } else {\n                    cnt++;\n                }\n            }\n        }\n\n        return cnt;\n    }\n};",
    "id": "266351616",
    "lang": "cpp",
    "memory": "34.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 52,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "808",
     "title": "Number of Matching Subsequences",
     "titleSlug": "number-of-matching-subsequences",
     "translatedTitle": "匹配子序列的单词数"
    },
    "rawMemory": "35276000",
    "runtime": "108 ms",
    "sourceUrl": "/problems/number-of-matching-subsequences/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "使用字符桶的 解法。",
     "flagType": "ORANGE"
    },
    "timestamp": 1644409219,
    "totalTestCaseCnt": 52
   }
  },
  "number-of-provinces": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int findCircleNum(vector\u003cvector\u003cint\u003e\u003e\u0026 isConnected) {\n        int N = isConnected.size();\n        std::vector\u003cbool\u003e visited(N, false);\n\n        std::function\u003cvoid(int)\u003e dfsVisit = [\u0026](int n) {\n            if (visited[n]) return;\n            visited[n] = true;\n            for (int i = 0; i \u003c isConnected[n].size(); i++) {\n                if (isConnected[n][i] == 1) {\n                    dfsVisit(i);\n                }     \n            }\n        };\n\n        int cnt = 0;\n        for (int i = 0; i \u003c N; i++) {\n            if (!visited[i]) {\n                dfsVisit(i);\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n};",
    "id": "262279185",
    "lang": "cpp",
    "memory": "13.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 113,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "547",
     "title": "Number of Provinces",
     "titleSlug": "number-of-provinces",
     "translatedTitle": "省份数量"
    },
    "rawMemory": "13732000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/number-of-provinces/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "DFS\n判断是不是第一次来到",
     "flagType": "RED"
    },
    "timestamp": 1643105924,
    "totalTestCaseCnt": 113
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func findCircleNum(isConnected [][]int) int {\n    pCnt := 0\n    vis := make([]bool, len(isConnected))\n    \n    var dfs func(int)\n    dfs = func(from int) {\n        vis[from] = true;\n        for i, c := range isConnected[from] {\n            if c == 1 \u0026\u0026 !vis[i] {\n                dfs(i)\n            }\n        }\n    }\n\n    for i, _:= range isConnected {\n        if !vis[i] {\n            pCnt++\n            dfs(i)\n        }\n    }\n    return pCnt\n}",
    "id": "233309965",
    "lang": "golang",
    "memory": "6.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 113,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "547",
     "title": "Number of Provinces",
     "titleSlug": "number-of-provinces",
     "translatedTitle": "省份数量"
    },
    "rawMemory": "6696000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/number-of-provinces/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635429796,
    "totalTestCaseCnt": 113
   }
  },
  "number-of-recent-calls": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "typedef struct Node {\n    struct Node* next;\n    struct Node* pre;\n    int time;\n} Node;\n\ntypedef struct {\n    struct Node* head;\n    struct Node* tail;\n    int size;\n} RecentCounter;\n\n\nRecentCounter* recentCounterCreate() {\n    RecentCounter* c = (RecentCounter*)malloc(sizeof(RecentCounter));\n    c-\u003ehead = (Node*)malloc(sizeof(Node));\n    c-\u003etail = (Node*)malloc(sizeof(Node));\n    c-\u003ehead-\u003epre = NULL;\n    c-\u003ehead-\u003enext = c-\u003etail;\n    c-\u003etail-\u003epre = c-\u003ehead;\n    c-\u003etail-\u003enext = NULL;\n    c-\u003esize = 0;\n    return c;\n}\n\nint recentCounterPing(RecentCounter* obj, int t) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node-\u003etime = t;\n    node-\u003epre = obj-\u003etail-\u003epre;\n    node-\u003enext = obj-\u003etail;\n    obj-\u003etail-\u003epre-\u003enext = node;\n    obj-\u003etail-\u003epre = node;\n    obj-\u003esize++;\n\n    while (obj-\u003ehead-\u003enext-\u003etime + 3000 \u003c t \u0026\u0026 obj-\u003esize != 0) {\n        obj-\u003esize--;\n        Node* dnode = obj-\u003ehead-\u003enext;\n        obj-\u003ehead-\u003enext = dnode-\u003enext;\n        dnode-\u003enext-\u003epre = obj-\u003ehead;\n        free(dnode);\n    }\n    return obj-\u003esize;\n}\n\nvoid recentCounterFree(RecentCounter* obj) {\n    while (obj-\u003ehead-\u003enext != obj-\u003etail) {\n        Node* dnode = obj-\u003ehead-\u003enext;\n        obj-\u003ehead-\u003enext = dnode-\u003enext;\n        dnode-\u003enext-\u003epre = obj-\u003ehead;\n        free(dnode);\n    }\n    free(obj-\u003ehead);\n    free(obj-\u003etail);  \n    free(obj);\n}\n\n/**\n * Your RecentCounter struct will be instantiated and called as such:\n * RecentCounter* obj = recentCounterCreate();\n * int param_1 = recentCounterPing(obj, t);\n \n * recentCounterFree(obj);\n*/",
    "id": "263958560",
    "lang": "c",
    "memory": "40.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "969",
     "title": "Number of Recent Calls",
     "titleSlug": "number-of-recent-calls",
     "translatedTitle": "最近的请求次数"
    },
    "rawMemory": "41916000",
    "runtime": "148 ms",
    "sourceUrl": "/problems/number-of-recent-calls/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "c 语言实现",
     "flagType": "RED"
    },
    "timestamp": 1643624361,
    "totalTestCaseCnt": 68
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class RecentCounter {\npublic:\n    RecentCounter() {\n\n    }\n    \n    int ping(int t) {\n        t_queue_.push(t);\n        while (t - t_queue_.front() \u003e 3000) {\n            t_queue_.pop();\n        }\n        return t_queue_.size();\n    }\nprivate:\n    std::queue\u003cint\u003e t_queue_;\n};\n\n/**\n * Your RecentCounter object will be instantiated and called as such:\n * RecentCounter* obj = new RecentCounter();\n * int param_1 = obj-\u003eping(t);\n */",
    "id": "263939626",
    "lang": "cpp",
    "memory": "56 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "969",
     "title": "Number of Recent Calls",
     "titleSlug": "number-of-recent-calls",
     "translatedTitle": "最近的请求次数"
    },
    "rawMemory": "57372000",
    "runtime": "128 ms",
    "sourceUrl": "/problems/number-of-recent-calls/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "使用队列实现",
     "flagType": "RED"
    },
    "timestamp": 1643617111,
    "totalTestCaseCnt": 68
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "type RecentCounter struct {\n    slice []int\n}\n\n\nfunc Constructor() RecentCounter {\n    return RecentCounter {\n        slice : make([]int, 0, 30000),\n    }    \n}\n\n\nfunc (this *RecentCounter) Ping(t int) int {\n    this.slice = append(this.slice, t)\n    for this.slice[0] + 3000 \u003c t {\n        this.slice = this.slice[1:]\n    }\n    return len(this.slice)\n}\n\n\n/**\n * Your RecentCounter object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Ping(t);\n */",
    "id": "263950675",
    "lang": "golang",
    "memory": "8.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "969",
     "title": "Number of Recent Calls",
     "titleSlug": "number-of-recent-calls",
     "translatedTitle": "最近的请求次数"
    },
    "rawMemory": "8376000",
    "runtime": "96 ms",
    "sourceUrl": "/problems/number-of-recent-calls/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "golang",
     "flagType": "RED"
    },
    "timestamp": 1643621163,
    "totalTestCaseCnt": 68
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class RecentCounter:\n\n    def __init__(self):\n        from collections import deque\n        self.q = deque()\n\n    def ping(self, t: int) -\u003e int:\n        self.q.append(t)\n        while self.q[0] + 3000 \u003c t:\n            self.q.popleft()\n\n        return len(self.q)\n\n\n# Your RecentCounter object will be instantiated and called as such:\n# obj = RecentCounter()\n# param_1 = obj.ping(t)",
    "id": "263951528",
    "lang": "python3",
    "memory": "19.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 68,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "969",
     "title": "Number of Recent Calls",
     "titleSlug": "number-of-recent-calls",
     "translatedTitle": "最近的请求次数"
    },
    "rawMemory": "20428000",
    "runtime": "216 ms",
    "sourceUrl": "/problems/number-of-recent-calls/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "from collections import deque",
     "flagType": "RED"
    },
    "timestamp": 1643621565,
    "totalTestCaseCnt": 68
   }
  },
  "number-of-segments-in-a-string": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int countSegments(string s) {\n        int res = 0;\n        for (int i = 0; i \u003c s.size(); i++) \n            res += s[i] != ' ' \u0026\u0026 (i + 1 == s.size() || s[i + 1] == ' ');\n        return res;\n    }\n};\n\n",
    "id": "10118959",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 26,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "434",
     "title": "Number of Segments in a String",
     "titleSlug": "number-of-segments-in-a-string",
     "translatedTitle": "字符串中的单词数"
    },
    "rawMemory": "N/A",
    "runtime": "0 ms",
    "sourceUrl": "/problems/number-of-segments-in-a-string/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543983484,
    "totalTestCaseCnt": 27
   }
  },
  "occurrences-after-bigram": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cstring\u003e findOcurrences(string text, string first, string second) {\n        text.push_back(' ');\n        vector\u003cstring\u003e vRes;\n        string sFirst,sSecond,sTemp;\n        for(int i=0;i\u003ctext.size();i++){\n            if(text[i]!=' '){\n                sTemp.push_back(text[i]);\n            }else{\n                if(!sFirst.empty()\u0026\u0026!sSecond.empty()){\n                    if((sFirst==first)\u0026\u0026(sSecond==second)){\n                        vRes.push_back(sTemp);\n                    }\n                }\n                sFirst=sSecond;\n                sSecond=sTemp;\n                sTemp.clear();\n            }\n        }\n        return vRes;\n    }\n};",
    "id": "31919077",
    "lang": "cpp",
    "memory": "8.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 29,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1156",
     "title": "Occurrences After Bigram",
     "titleSlug": "occurrences-after-bigram",
     "translatedTitle": "Bigram 分词"
    },
    "rawMemory": "8740000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/occurrences-after-bigram/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1570081165,
    "totalTestCaseCnt": 30
   }
  },
  "odd-even-linked-list": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* oddEvenList(struct ListNode* head){\n    if (head == NULL) return NULL;\n    struct ListNode* odd = head;\n    struct ListNode* even = head-\u003enext;\n    struct ListNode* evenHead = even;\n    while (even != NULL \u0026\u0026 even-\u003enext != NULL) {\n        odd-\u003enext = odd-\u003enext-\u003enext;\n        even-\u003enext = even-\u003enext-\u003enext;\n        odd = odd-\u003enext;\n        even = even-\u003enext;\n    }\n    odd-\u003enext = evenHead;\n    return head;\n}",
    "id": "264417926",
    "lang": "c",
    "memory": "6.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "328",
     "title": "Odd Even Linked List",
     "titleSlug": "odd-even-linked-list",
     "translatedTitle": "奇偶链表"
    },
    "rawMemory": "6868000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/odd-even-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643859536,
    "totalTestCaseCnt": 70
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if (head == nullptr) {\n            return head;\n        }\n        ListNode* odd = head;\n        ListNode* evenHead = odd-\u003enext;\n        ListNode* even = evenHead;\n        while (even != nullptr \u0026\u0026 even-\u003enext != nullptr) {\n            odd-\u003enext = odd-\u003enext-\u003enext;\n            even-\u003enext = even-\u003enext-\u003enext;\n            even = even-\u003enext;\n            odd = odd-\u003enext;\n        }\n        odd-\u003enext = evenHead;\n        return head;\n    }\n};",
    "id": "264374649",
    "lang": "cpp",
    "memory": "10.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "328",
     "title": "Odd Even Linked List",
     "titleSlug": "odd-even-linked-list",
     "translatedTitle": "奇偶链表"
    },
    "rawMemory": "10436000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/odd-even-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643825390,
    "totalTestCaseCnt": 70
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def oddEvenList(self, head: ListNode) -\u003e ListNode:\n        if head == None:\n            return head\n        odd = head\n        even = head.next\n        even_head = even\n        while even and even.next and odd.next:\n            odd.next = odd.next.next\n            even.next = even.next.next\n            odd = odd.next\n            even = even.next\n        odd.next = even_head\n        return head        ",
    "id": "264447553",
    "lang": "python3",
    "memory": "16.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "328",
     "title": "Odd Even Linked List",
     "titleSlug": "odd-even-linked-list",
     "translatedTitle": "奇偶链表"
    },
    "rawMemory": "17336000",
    "runtime": "48 ms",
    "sourceUrl": "/problems/odd-even-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643869577,
    "totalTestCaseCnt": 70
   }
  },
  "one-edit-distance": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isOneEditDistance(string s, string t) {\n        // let len of s \u003e t\n        int distance = s.size() - t.size();\n        if (distance \u003c 0) {\n            return isOneEditDistance(t, s);\n        }\n        if (distance \u003e 1) {\n            return false;\n        }\n\n        int len = t.size();\n        for (int i = 0; i \u003c len; i++) {\n            if (s[i] != t[i]) {\n                if (distance \u003e 0) {\n                    return s.substr(i+1) == t.substr(i);\n                } else {\n                    return s.substr(i+1) == t.substr(i+1);\n                }\n            }\n        }\n        return distance \u003e 0;\n    }\n};",
    "id": "265065114",
    "lang": "cpp",
    "memory": "6.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 136,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "161",
     "title": "One Edit Distance",
     "titleSlug": "one-edit-distance",
     "translatedTitle": "相隔为 1 的编辑距离"
    },
    "rawMemory": "6748000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/one-edit-distance/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644082224,
    "totalTestCaseCnt": 136
   }
  },
  "opLdQZ": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool findTarget(TreeNode* root, int k) {\n        vector\u003cint\u003e res;\n        inorder(root, res);\n\n        int lo = 0, hi = res.size() - 1;\n        while (lo \u003c hi) {\n            int sum = res[lo] + res[hi];\n            if (sum \u003e k) {\n                hi--;\n            } else if (sum \u003c k) {\n                lo++;\n            } else return true;\n        }\n        return false;\n    }\n\n    void inorder(TreeNode* root, vector\u003cint\u003e\u0026 res) {\n        if (root == nullptr) return;\n        inorder(root-\u003eleft, res);\n        res.push_back(root-\u003eval);\n        inorder(root-\u003eright, res);\n    }\n\n};",
    "id": "277903320",
    "lang": "cpp",
    "memory": "35.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 424,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1000319",
     "title": "二叉搜索树中两个节点之和",
     "titleSlug": "opLdQZ",
     "translatedTitle": "二叉搜索树中两个节点之和"
    },
    "rawMemory": "36780000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/opLdQZ/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646490944,
    "totalTestCaseCnt": 424
   }
  },
  "palindrome-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        std::vector\u003cint\u003e vec;\n        while (head) {\n            vec.push_back(head-\u003eval);\n            head = head-\u003enext;\n        }\n        int i = 0, j = vec.size() - 1;\n        while (i \u003c j) {\n            if (vec[i++] != vec[j--]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
    "id": "264964659",
    "lang": "cpp",
    "memory": "125.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 86,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "234",
     "title": "Palindrome Linked List",
     "titleSlug": "palindrome-linked-list",
     "translatedTitle": "回文链表"
    },
    "rawMemory": "128280000",
    "runtime": "196 ms",
    "sourceUrl": "/problems/palindrome-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644056899,
    "totalTestCaseCnt": 85
   }
  },
  "palindrome-number": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        long long ret = 0;\n        long long y = x;\n        while (x != 0) {\n            ret = ret * 10 + x % 10;\n            x /= 10;\n        }\n        return y == ret \u0026\u0026 y \u003e= 0;\n    }\n};",
    "id": "9343602",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 11509,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "9",
     "title": "Palindrome Number",
     "titleSlug": "palindrome-number",
     "translatedTitle": "回文数"
    },
    "rawMemory": "N/A",
    "runtime": "116 ms",
    "sourceUrl": "/problems/palindrome-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1542122488,
    "totalTestCaseCnt": 11510
   }
  },
  "palindrome-permutation": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "bool canPermutePalindrome(char * s){\n    int seen[128] = {0,};\n    while (*s) seen[*s++]++;\n\n    int cnt = 0;\n    for (int i = 0; i \u003c sizeof(seen)/sizeof(seen[0]); i++) {\n        cnt += seen[i] % 2;\n        if (cnt \u003e 1) return false;\n    } \n    return true;\n}",
    "id": "264000886",
    "lang": "c",
    "memory": "5.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "266",
     "title": "Palindrome Permutation",
     "titleSlug": "palindrome-permutation",
     "translatedTitle": "回文排列"
    },
    "rawMemory": "5560000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/palindrome-permutation/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "okk",
     "flagType": "RED"
    },
    "timestamp": 1643657708,
    "totalTestCaseCnt": 24
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool canPermutePalindrome(string s) {\n        map\u003cchar, int\u003e smap;\n        for (auto\u0026 c : s) {\n            smap[c]++;\n        }\n        int ocnt = 0;\n        for (auto\u0026 p : smap) {\n            ocnt += p.second % 2;\n            if (ocnt \u003e 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
    "id": "264000317",
    "lang": "cpp",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "266",
     "title": "Palindrome Permutation",
     "titleSlug": "palindrome-permutation",
     "translatedTitle": "回文排列"
    },
    "rawMemory": "6124000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/palindrome-permutation/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643656134,
    "totalTestCaseCnt": 24
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def canPermutePalindrome(self, s: str) -\u003e bool:\n        seen = collections.defaultdict(int)\n        for c in s:\n            seen[c] += 1\n        cnt = 0\n        for v in seen.values():\n            cnt += v % 2\n            if cnt \u003e 1:\n                return False\n        return True",
    "id": "264000589",
    "lang": "python3",
    "memory": "15 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "266",
     "title": "Palindrome Permutation",
     "titleSlug": "palindrome-permutation",
     "translatedTitle": "回文排列"
    },
    "rawMemory": "15340000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/palindrome-permutation/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "有点慢",
     "flagType": "RED"
    },
    "timestamp": 1643657160,
    "totalTestCaseCnt": 24
   }
  },
  "partition-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        if (head == nullptr) return nullptr;\n        ListNode gHead, dummy;\n        dummy.next = head;\n        ListNode *curr = \u0026dummy, *g = \u0026gHead;\n        while (curr-\u003enext) {\n            if (curr-\u003enext-\u003eval \u003e= x) {\n                g-\u003enext = curr-\u003enext;\n                curr-\u003enext = curr-\u003enext-\u003enext;\n                g = g-\u003enext;\n            } else {\n                curr = curr-\u003enext;\n            }\n        }\n        g-\u003enext = nullptr;\n        curr-\u003enext = gHead.next;\n        return dummy.next;\n    }\n};",
    "id": "264535787",
    "lang": "cpp",
    "memory": "9.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 168,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "86",
     "title": "Partition List",
     "titleSlug": "partition-list",
     "translatedTitle": "分隔链表"
    },
    "rawMemory": "10112000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/partition-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "第一次没错对",
     "flagType": "GREEN"
    },
    "timestamp": 1643892682,
    "totalTestCaseCnt": 168
   }
  },
  "pascals-triangle": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e generate(int numRows) {\n        vector\u003cvector\u003cint\u003e\u003e yh_matrics;\n        \n        for (int i = 0; i \u003c numRows; i++) {\n            //初始化，全1.第一行，为1个\n            vector\u003cint\u003e row(i + 1, 1);\n            yh_matrics.push_back(row);\n        }\n        if (numRows \u003e 2) {\n            for (int i = 2; i \u003c numRows; i++) {\n                for (int j = 1; j \u003c i; j++) {\n                    //观察规律\n                    yh_matrics[i][j] = yh_matrics[i-1][j-1] + yh_matrics[i-1][j];\n                }\n            }\n        }\n        \n        return yh_matrics;\n    }\n};",
    "id": "8296378",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 15,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "118",
     "title": "Pascal's Triangle",
     "titleSlug": "pascals-triangle",
     "translatedTitle": "杨辉三角"
    },
    "rawMemory": "N/A",
    "runtime": "0 ms",
    "sourceUrl": "/problems/pascals-triangle/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539613994,
    "totalTestCaseCnt": 14
   }
  },
  "path-sum": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nbool hasPathSum(struct TreeNode* root, int targetSum){\n    if (root == NULL) return false;\n    if (!root-\u003eright \u0026\u0026 !root-\u003eleft \u0026\u0026 root-\u003eval == targetSum) return true;\n    int val = targetSum - root-\u003eval;\n    return hasPathSum(root-\u003eleft, val) || hasPathSum(root-\u003eright, val);\n}",
    "id": "265270694",
    "lang": "c",
    "memory": "8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 117,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "112",
     "title": "Path Sum",
     "titleSlug": "path-sum",
     "translatedTitle": "路径总和"
    },
    "rawMemory": "8224000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/path-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644150996,
    "totalTestCaseCnt": 117
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if (root == nullptr) {\n            return false;\n        } \n        if (!root-\u003eleft  \u0026\u0026 !root-\u003eright) {\n            return targetSum == root-\u003eval;\n        }\n        int nextSum = targetSum - root-\u003eval;\n        return hasPathSum(root-\u003eleft, nextSum) || hasPathSum(root-\u003eright, nextSum);\n    }\n};",
    "id": "263852298",
    "lang": "cpp",
    "memory": "20.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 117,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "112",
     "title": "Path Sum",
     "titleSlug": "path-sum",
     "translatedTitle": "路径总和"
    },
    "rawMemory": "21296000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/path-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "49% ???",
     "flagType": "RED"
    },
    "timestamp": 1643570055,
    "totalTestCaseCnt": 117
   }
  },
  "peak-index-in-a-mountain-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int peakIndexInMountainArray(vector\u003cint\u003e\u0026 arr) {\n        int lo = 0, hi = arr.size();\n        while (lo \u003c hi) {\n            int mid = (lo + hi) \u003e\u003e 1;\n            if (arr[mid] \u003c arr[mid+1]) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return hi;\n    }\n};",
    "id": "265692315",
    "lang": "cpp",
    "memory": "11.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 35,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "882",
     "title": "Peak Index in a Mountain Array",
     "titleSlug": "peak-index-in-a-mountain-array",
     "translatedTitle": "山脉数组的峰顶索引"
    },
    "rawMemory": "11504000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/peak-index-in-a-mountain-array/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这个才是对的。",
     "flagType": "PURPLE"
    },
    "timestamp": 1644263466,
    "totalTestCaseCnt": 34
   }
  },
  "perfect-squares": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\n\npublic:\n    int numSquares(int n) {\n\n        vector\u003cint\u003e mem(n + 1, -1);\n\n        return numSquares(n, mem);\n    }\n\nprivate:\n    int numSquares(int n, vector\u003cint\u003e\u0026 mem){\n\n        if(n == 0)\n            return 0;\n\n        if(mem[n] != -1)\n            return mem[n];\n\n        int res = INT_MAX;\n        for(int i = 1; n - i * i \u003e= 0; i ++ )\n            res = min(res, 1 + numSquares(n - i * i, mem));\n        return mem[n] = res;\n    }\n};",
    "id": "10556452",
    "lang": "cpp",
    "memory": "1.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 588,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "279",
     "title": "Perfect Squares",
     "titleSlug": "perfect-squares",
     "translatedTitle": "完全平方数"
    },
    "rawMemory": "1142784",
    "runtime": "96 ms",
    "sourceUrl": "/problems/perfect-squares/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545036710,
    "totalTestCaseCnt": 588
   }
  },
  "permutations": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e res;\n    vector\u003cbool\u003e vis;\n    vector\u003cvector\u003cint\u003e\u003e permute(vector\u003cint\u003e\u0026 nums) {\n        res.clear();\n        vis.resize(nums.size());\n\n        vector\u003cint\u003e tmp;\n        backtrack(nums, tmp, 0);\n        return res;\n    }\n\n    void backtrack(vector\u003cint\u003e\u0026 nums, vector\u003cint\u003e\u0026 tmp, int index) {\n        if (index == nums.size()) {\n            res.push_back(tmp);\n            return;\n        }\n        for (int i = 0; i \u003c nums.size(); i++) {\n            if (!vis[i]) {\n                vis[i] = true;\n                tmp.push_back(nums[i]);\n                backtrack(nums, tmp, index+1);\n                tmp.pop_back();\n                vis[i] = false;\n            }\n        }\n    }\n};",
    "id": "277607110",
    "lang": "cpp",
    "memory": "7.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 26,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "46",
     "title": "Permutations",
     "titleSlug": "permutations",
     "translatedTitle": "全排列"
    },
    "rawMemory": "7892000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/permutations/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646459700,
    "totalTestCaseCnt": 26
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def permute(self, nums: List[int]) -\u003e List[List[int]]:\n        res = []\n        def backtrack(nums, tmp):\n            if not nums:\n                res.append(tmp)\n                return \n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]])\n                \n        backtrack(nums, [])\n        return res\n",
    "id": "285586060",
    "lang": "python3",
    "memory": "15.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 26,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "46",
     "title": "Permutations",
     "titleSlug": "permutations",
     "translatedTitle": "全排列"
    },
    "rawMemory": "15500000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/permutations/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1647637194,
    "totalTestCaseCnt": 26
   }
  },
  "plus-one": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e plusOne(vector\u003cint\u003e\u0026 digits) {\n        bool carry = false;\n        for (auto i = digits.size(); i \u003e 0; i--) {\n            digits[i - 1] += 1;\n            if (digits[i - 1] == 10) {\n                digits[i - 1] = 0;\n                carry = true;\n            } else {\n                carry = false;\n                break;\n            }\n        }\n        \n        if (carry) {\n            digits.insert(digits.begin(), 1);\n        }\n        return digits;\n    }\n};",
    "id": "8299832",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 109,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "66",
     "title": "Plus One",
     "titleSlug": "plus-one",
     "translatedTitle": "加一"
    },
    "rawMemory": "N/A",
    "runtime": "0 ms",
    "sourceUrl": "/problems/plus-one/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539619931,
    "totalTestCaseCnt": 111
   }
  },
  "plus-one-linked-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* plusOne(ListNode* head) {\n        std::stack\u003cListNode*\u003e stack;\n        ListNode* head2 = head;\n        while (head) {\n            stack.push(head);\n            head = head-\u003enext;\n        }\n        int add = 1;\n        while (!stack.empty()) {\n            int tmp = stack.top()-\u003eval + add; \n            add = tmp / 10;\n            stack.top()-\u003eval = tmp % 10;\n            stack.pop();\n        }\n        if (add) {\n            auto newHead = new ListNode(add, head2);\n            return newHead;\n        }\n\n        return head2;\n    }\n};",
    "id": "264592727",
    "lang": "cpp",
    "memory": "8.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 108,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "369",
     "title": "Plus One Linked List",
     "titleSlug": "plus-one-linked-list",
     "translatedTitle": "给单链表加一"
    },
    "rawMemory": "8692000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/plus-one-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643909115,
    "totalTestCaseCnt": 108
   }
  },
  "populating-next-right-pointers-in-each-node": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a Node.\n * struct Node {\n *     int val;\n *     struct Node *left;\n *     struct Node *right;\n *     struct Node *next;\n * };\n */\n\nstruct Node* connect(struct Node* root) {\n    if (root == NULL) return NULL;\n    // 只有非叶子节点才可以这样做。\n    if (root-\u003eleft) {\n        root-\u003eleft-\u003enext = root-\u003eright;\n        if (root-\u003enext) {\n            root-\u003eright-\u003enext = root-\u003enext-\u003eleft;\n        }\n    }\n    connect(root-\u003eleft);\n    connect(root-\u003eright);\n    return root;\n}",
    "id": "264813415",
    "lang": "c",
    "memory": "8.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 59,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "116",
     "title": "Populating Next Right Pointers in Each Node",
     "titleSlug": "populating-next-right-pointers-in-each-node",
     "translatedTitle": "填充每个节点的下一个右侧节点指针"
    },
    "rawMemory": "9016000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/populating-next-right-pointers-in-each-node/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "只有非叶子几点可以这样做啊。",
     "flagType": "ORANGE"
    },
    "timestamp": 1643991094,
    "totalTestCaseCnt": 59
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if (root == nullptr) return nullptr;\n        queue\u003cNode*\u003e q;\n        q.push(root);\n        while (!q.empty()) {\n            int n = q.size();\n            for (int i = 0; i \u003c n; i++) {\n                Node* node = q.front();\n                q.pop();\n                if (i \u003c n - 1) {\n                    node-\u003enext = q.front();\n                }\n\n                if (node-\u003eleft) q.push(node-\u003eleft);\n                if (node-\u003eright) q.push(node-\u003eright);\n            }\n        }\n        return root;\n    }\n};",
    "id": "264814156",
    "lang": "cpp",
    "memory": "16.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 59,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "116",
     "title": "Populating Next Right Pointers in Each Node",
     "titleSlug": "populating-next-right-pointers-in-each-node",
     "translatedTitle": "填充每个节点的下一个右侧节点指针"
    },
    "rawMemory": "16988000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/populating-next-right-pointers-in-each-node/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "层序遍历。 bfs",
     "flagType": "RED"
    },
    "timestamp": 1643991450,
    "totalTestCaseCnt": 59
   }
  },
  "populating-next-right-pointers-in-each-node-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if (root == nullptr) return nullptr;\n        queue\u003cNode*\u003e q;\n        q.push(root);\n        while (!q.empty()) {\n            int len = q.size();\n            for (int i = 0; i \u003c len; i++) {\n                Node* n = q.front();\n                q.pop();\n                if (i \u003c len - 1) {\n                    n-\u003enext = q.front();\n                }\n                if (n-\u003eleft) q.push(n-\u003eleft);\n                if (n-\u003eright) q.push(n-\u003eright);\n            }\n        }\n        return root;\n    }\n};",
    "id": "264815363",
    "lang": "cpp",
    "memory": "17.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 55,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "117",
     "title": "Populating Next Right Pointers in Each Node II",
     "titleSlug": "populating-next-right-pointers-in-each-node-ii",
     "translatedTitle": "填充每个节点的下一个右侧节点指针 II"
    },
    "rawMemory": "17560000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/populating-next-right-pointers-in-each-node-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643991975,
    "totalTestCaseCnt": 55
   }
  },
  "power-of-three": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "\n\nbool isPowerOfThree(int n){\n    long t = 1;\n    while (t \u003c n) {\n        t *= 3;\n    }\n    return n == t;\n}",
    "id": "265687385",
    "lang": "c",
    "memory": "6.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21038,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "326",
     "title": "Power of Three",
     "titleSlug": "power-of-three",
     "translatedTitle": "3 的幂"
    },
    "rawMemory": "6340000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/power-of-three/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644255858,
    "totalTestCaseCnt": 21038
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if (n == 0) return false;\n        #define log3(n)  log(n)/log(3)\n        \n        double x = log3(n);\n        return abs(x - round(x)) \u003c 1e-10;\n    }\n};\n\n",
    "id": "265689527",
    "lang": "cpp",
    "memory": "6.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21038,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "326",
     "title": "Power of Three",
     "titleSlug": "power-of-three",
     "translatedTitle": "3 的幂"
    },
    "rawMemory": "6220000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/power-of-three/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644258621,
    "totalTestCaseCnt": 21038
   }
  },
  "power-of-two": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        return n \u003e 0 \u0026\u0026 (n \u0026 (n - 1)) == 0;\n    }\n};",
    "id": "266366891",
    "lang": "cpp",
    "memory": "5.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1108,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "231",
     "title": "Power of Two",
     "titleSlug": "power-of-two",
     "translatedTitle": "2 的幂"
    },
    "rawMemory": "5824000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/power-of-two/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "n \u0026 n-1 ",
     "flagType": "BLUE"
    },
    "timestamp": 1644411397,
    "totalTestCaseCnt": 1108
   }
  },
  "powx-n": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    double quickMul(double x, long long N) {\n        if (N == 0) {\n            return 1.0;\n        }\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    }\n\n    double myPow(double x, int n) {\n        long long N = n;\n        return N \u003e= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    }\n};",
    "id": "266457108",
    "lang": "cpp",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 305,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "50",
     "title": "Pow(x, n)",
     "titleSlug": "powx-n",
     "translatedTitle": "Pow(x, n)"
    },
    "rawMemory": "5960000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/powx-n/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "官方题解。",
     "flagType": "BLUE"
    },
    "timestamp": 1644427811,
    "totalTestCaseCnt": 305
   }
  },
  "print-foobar-alternately": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class FooBar {\nprivate:\n    int n;\n    int foo_cnt_;\n    int bar_cnt_;\n    std::mutex mu_;\n    std::condition_variable cv_;\npublic:\n    FooBar(int n) {\n        this-\u003en = n;\n        this-\u003efoo_cnt_ = 0;\n        this-\u003ebar_cnt_ = 0;\n    }\n\n    void foo(function\u003cvoid()\u003e printFoo) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        for (int i = 0; i \u003c n; i++) {\n          if (i \u003e 0) lk.lock();\n          cv_.wait(lk, [this]{\n            return foo_cnt_ == bar_cnt_;\n          });\n        \t// printFoo() outputs \"foo\". Do not change or remove this line.\n        \tprintFoo();\n          foo_cnt_++;\n          lk.unlock();\n          cv_.notify_one();\n        }\n    }\n\n    void bar(function\u003cvoid()\u003e printBar) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        for (int i = 0; i \u003c n; i++) {\n          if (i \u003e 0) lk.lock();\n          cv_.wait(lk, [this]{\n            return foo_cnt_ == bar_cnt_ + 1;\n          });\n        \t// printBar() outputs \"bar\". Do not change or remove this line.\n        \tprintBar();\n          bar_cnt_++;\n          lk.unlock();\n          cv_.notify_one();\n        }\n    }\n};",
    "id": "266886957",
    "lang": "cpp",
    "memory": "8.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 144,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1187",
     "title": "Print FooBar Alternately",
     "titleSlug": "print-foobar-alternately",
     "translatedTitle": "交替打印 FooBar"
    },
    "rawMemory": "8312000",
    "runtime": "456 ms",
    "sourceUrl": "/problems/print-foobar-alternately/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644517999,
    "totalTestCaseCnt": 144
   }
  },
  "print-in-order": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "typedef struct {\n    // User defined data may be declared here.\n    pthread_mutex_t mutex;\n    pthread_cond_t cond;\n    bool first_ok;\n    bool second_ok;\n} Foo;\n\nFoo* fooCreate() {\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\n    \n\n    // Initialize user defined data here.\n    obj-\u003efirst_ok = false;\n    obj-\u003esecond_ok = false;\n    pthread_mutex_init(\u0026obj-\u003emutex, NULL);\n    pthread_cond_init(\u0026obj-\u003econd, NULL);\n    return obj;\n}\n\nvoid first(Foo* obj) {\n    \n    // printFirst() outputs \"first\". Do not change or remove this line.\n    printFirst();\n\n    \n    obj-\u003efirst_ok = true;\n    pthread_cond_broadcast(\u0026obj-\u003econd);\n}\n\nvoid second(Foo* obj) {\n    pthread_mutex_lock(\u0026obj-\u003emutex);\n    while (!obj-\u003efirst_ok) {\n        pthread_cond_wait(\u0026obj-\u003econd, \u0026obj-\u003emutex);\n    }\n    // printSecond() outputs \"second\". Do not change or remove this line.\n    printSecond();\n\n    obj-\u003esecond_ok = true;\n    pthread_mutex_unlock(\u0026obj-\u003emutex);\n    pthread_cond_signal(\u0026obj-\u003econd);\n}\n\nvoid third(Foo* obj) {\n    pthread_mutex_lock(\u0026obj-\u003emutex);\n    while (!obj-\u003esecond_ok) {\n        pthread_cond_wait(\u0026obj-\u003econd, \u0026obj-\u003emutex);\n    }\n    // printThird() outputs \"third\". Do not change or remove this line.\n    printThird();\n    pthread_mutex_unlock(\u0026obj-\u003emutex);\n\n}\n\nvoid fooFree(Foo* obj) {\n    // User defined data may be cleaned up here.\n    if (obj != NULL) {\n        pthread_mutex_destroy(\u0026obj-\u003emutex);\n        pthread_cond_destroy(\u0026obj-\u003econd);\n        free(obj);\n    }\n}",
    "id": "266792436",
    "lang": "c",
    "memory": "6.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1203",
     "title": "Print in Order",
     "titleSlug": "print-in-order",
     "translatedTitle": "按序打印"
    },
    "rawMemory": "6576000",
    "runtime": "156 ms",
    "sourceUrl": "/problems/print-in-order/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644498793,
    "totalTestCaseCnt": 36
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Foo {\npublic:\n    Foo() {\n        \n    }\n\n    void first(function\u003cvoid()\u003e printFirst) {\n        // printFirst() outputs \"first\". Do not change or remove this line.\n        printFirst();\n        first_ok_ = true;\n        cv_.notify_all();\n    }\n\n    void second(function\u003cvoid()\u003e printSecond) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        cv_.wait(lk, [this](){ return first_ok_; });\n        // printSecond() outputs \"second\". Do not change or remove this line.\n        printSecond();\n        second_ok_ = true;\n        lk.unlock();\n        cv_.notify_one();\n    }\n\n    void third(function\u003cvoid()\u003e printThird) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        cv_.wait(lk, [this](){ return second_ok_; });\n        // printThird() outputs \"third\". Do not change or remove this line.\n        printThird();\n    }\nprivate:\n    bool first_ok_ = false;\n    bool second_ok_ = false;\n    std::mutex mu_;\n    std::condition_variable cv_;\n};",
    "id": "276910385",
    "lang": "cpp",
    "memory": "7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1203",
     "title": "Print in Order",
     "titleSlug": "print-in-order",
     "translatedTitle": "按序打印"
    },
    "rawMemory": "7136000",
    "runtime": "84 ms",
    "sourceUrl": "/problems/print-in-order/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646328967,
    "totalTestCaseCnt": 36
   }
  },
  "print-zero-even-odd": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class ZeroEvenOdd {\nprivate:\n    int n;\n    int next;\n    std::mutex mu_;\n    std::condition_variable cv_;\n\npublic:\n    ZeroEvenOdd(int n) {\n        this-\u003en = n;\n        this-\u003enext = 0;\n    }\n\n    // printNumber(x) outputs \"x\", where x is an integer.\n    void zero(function\u003cvoid(int)\u003e printNumber) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        for (int i = 1; i \u003c= n; i++) {\n          if (i \u003e 1) lk.lock();\n          cv_.wait(lk, [this]{ return next == 0;});\n          printNumber(0);\n          next = 2 - (i)%2;\n          cv_.notify_all();\n          lk.unlock();\n        }\n    }\n\n    void even(function\u003cvoid(int)\u003e printNumber) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        for (int i = 2; i \u003c= n; i += 2) {\n          if (i \u003e 2) lk.lock();\n          cv_.wait(lk, [this]{ return next \u0026 2; });\n          printNumber(i);\n          next = 0;\n          cv_.notify_all();\n          lk.unlock();\n        }       \n    }\n\n    void odd(function\u003cvoid(int)\u003e printNumber) {\n        std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n        for (int i = 1; i \u003c= n; i += 2) {\n          if (i \u003e 1) lk.lock();\n          cv_.wait(lk, [this]{ return next \u0026 1;});\n          printNumber(i);\n          next = 0;\n          lk.unlock();\n          cv_.notify_all();\n        }   \n    }\n};",
    "id": "267408727",
    "lang": "cpp",
    "memory": "6.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 14,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1216",
     "title": "Print Zero Even Odd",
     "titleSlug": "print-zero-even-odd",
     "translatedTitle": "打印零与奇偶数"
    },
    "rawMemory": "6932000",
    "runtime": "60 ms",
    "sourceUrl": "/problems/print-zero-even-odd/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644650997,
    "totalTestCaseCnt": 14
   }
  },
  "product-of-array-except-self": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e productExceptSelf(vector\u003cint\u003e\u0026 nums) {\n        const int kN = nums.size();\n        vector\u003cint\u003e res(kN);\n        vector\u003cint\u003e p1(kN), p2(kN);\n\n        for (int i = 0, sum1 = 1, sum2 = 1; i \u003c kN; i++) {\n            p1[i] = sum1;\n            p2[i] = sum2;\n            sum1 *= nums[i];\n            sum2 *= nums[kN - i - 1];\n        }\n\n        for (int i = 0; i \u003c kN; i++) {\n            res[i] = (p1[i] * p2[kN - i -1]);\n        }\n        return res;\n    }\n};",
    "id": "266404121",
    "lang": "cpp",
    "memory": "24.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 20,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "238",
     "title": "Product of Array Except Self",
     "titleSlug": "product-of-array-except-self",
     "translatedTitle": "除自身以外数组的乘积"
    },
    "rawMemory": "25060000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/product-of-array-except-self/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "交叉相乘。可以优化。\n以 a,b,c,d 序列为例；\n1,       a,    ab,    abc\ndcb   dc    d      1\n1, d,   dc,  dcb",
     "flagType": "BLUE"
    },
    "timestamp": 1644416666,
    "totalTestCaseCnt": 20
   }
  },
  "que-shi-de-shu-zi-lcof": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int missingNumber(int* nums, int numsSize){\n    int i = 0; \n    for (; i \u003c numsSize; i++) {\n        if (nums[i] != i) {\n            return i;\n        }\n    }\n    return i;\n}",
    "id": "265431387",
    "lang": "c",
    "memory": "6.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 122,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100331",
     "title": "缺失的数字  LCOF",
     "titleSlug": "que-shi-de-shu-zi-lcof",
     "translatedTitle": "0～n-1中缺失的数字"
    },
    "rawMemory": "6612000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/que-shi-de-shu-zi-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644208392,
    "totalTestCaseCnt": 122
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int missingNumber(vector\u003cint\u003e\u0026 nums) {\n        int lo = 0, hi = nums.size();\n        while (lo \u003c hi) {\n            int mid = (lo + hi) /2;\n            if (nums[mid] == mid) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return hi;\n    }\n};",
    "id": "265727078",
    "lang": "cpp",
    "memory": "16.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 122,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100331",
     "title": "缺失的数字  LCOF",
     "titleSlug": "que-shi-de-shu-zi-lcof",
     "translatedTitle": "0～n-1中缺失的数字"
    },
    "rawMemory": "17040000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/que-shi-de-shu-zi-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644287360,
    "totalTestCaseCnt": 122
   }
  },
  "range-sum-of-bst": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nint rangeSumBST(struct TreeNode* root, int low, int high){\n    if (root == NULL) return 0;\n    if (root-\u003eval \u003c low) {\n        return rangeSumBST(root-\u003eright, low, high);\n    } else if (root-\u003eval \u003e high) {\n        return rangeSumBST(root-\u003eleft, low, high);\n    }\n    return root-\u003eval + rangeSumBST(root-\u003eleft, low, high) + rangeSumBST(root-\u003eright, low, high);\n}",
    "id": "264824928",
    "lang": "c",
    "memory": "41.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 41,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "975",
     "title": "Range Sum of BST",
     "titleSlug": "range-sum-of-bst",
     "translatedTitle": "二叉搜索树的范围和"
    },
    "rawMemory": "42420000",
    "runtime": "76 ms",
    "sourceUrl": "/problems/range-sum-of-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这个是标准的写法。",
     "flagType": "ORANGE"
    },
    "timestamp": 1644001629,
    "totalTestCaseCnt": 41
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        int res = 0;\n        dfs(root, low, high, res);\n        return res;\n    }\n\n    void dfs(TreeNode* root, int low, int high, int\u0026 res) {\n        if (root == nullptr) return;\n        if (root-\u003eval \u003e= low \u0026\u0026 root-\u003eval \u003c= high) {\n            res += root-\u003eval;\n            dfs(root-\u003eleft, low, high, res);\n            dfs(root-\u003eright, low, high, res);\n        } else if (root-\u003eval \u003c low) {\n            dfs(root-\u003eright, low, high, res);\n        } else {\n            dfs(root-\u003eleft, low, high, res);\n        }\n    }\n};",
    "id": "264824809",
    "lang": "cpp",
    "memory": "63.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 41,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "975",
     "title": "Range Sum of BST",
     "titleSlug": "range-sum-of-bst",
     "translatedTitle": "二叉搜索树的范围和"
    },
    "rawMemory": "64604000",
    "runtime": "104 ms",
    "sourceUrl": "/problems/range-sum-of-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644001351,
    "totalTestCaseCnt": 41
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc rangeSumBST(root *TreeNode, low int, high int) int {\n    res := 0\n    stack := []*TreeNode{}\n    for root != nil || len(stack) \u003e 0 {\n        for root != nil {\n            stack = append(stack, root)\n            root = root.Left\n        }\n        root = stack[len(stack) - 1]\n        stack = stack[:len(stack) - 1]\n        if (root.Val \u003e= low \u0026\u0026 root.Val \u003c= high) {\n            res += root.Val\n        } else if (root.Val \u003e high) {\n            // 可以提前退出\n            break;\n        }\n        root = root.Right\n    }\n    return res\n}",
    "id": "264825320",
    "lang": "golang",
    "memory": "8.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 41,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "975",
     "title": "Range Sum of BST",
     "titleSlug": "range-sum-of-bst",
     "translatedTitle": "二叉搜索树的范围和"
    },
    "rawMemory": "8612000",
    "runtime": "56 ms",
    "sourceUrl": "/problems/range-sum-of-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644002807,
    "totalTestCaseCnt": 41
   }
  },
  "ransom-note": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        map\u003cchar, int\u003e cmap;\n        for (auto c : magazine) {\n            cmap[c]++;\n        }\n        for (auto c : ransomNote) {\n            auto it = cmap.find(c);\n            if (it == cmap.end() || it-\u003esecond == 0) {\n                return false;\n            }\n            it-\u003esecond--;\n        }\n        return true;\n    }\n};",
    "id": "263593764",
    "lang": "cpp",
    "memory": "8.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 126,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "383",
     "title": "Ransom Note",
     "titleSlug": "ransom-note",
     "translatedTitle": "赎金信"
    },
    "rawMemory": "8956000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/ransom-note/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643476526,
    "totalTestCaseCnt": 126
   }
  },
  "recover-binary-search-tree": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode *prev;\nstruct TreeNode *first;\nstruct TreeNode *last;\n\nvoid inorder(struct TreeNode* root) {\n    if (root == NULL) {\n        return root;\n    }\n    inorder(root-\u003eleft);\n    if (prev != NULL) {\n        if (prev-\u003eval \u003e root-\u003eval) {\n            if (first == NULL) {\n                first = prev;\n            }\n            last = root;\n        }\n    }\n    prev = root;\n    inorder(root-\u003eright);\n}\n\nvoid recoverTree(struct TreeNode* root){\n    if (root == NULL) {\n        return;\n    }\n    prev = NULL, first = NULL, last = NULL;\n    inorder(root);\n    if (first != NULL \u0026\u0026 last != NULL) {\n        int val = first-\u003eval;\n        first-\u003eval = last-\u003eval;\n        last-\u003eval = val;\n    }\n}\n",
    "id": "275591112",
    "lang": "c",
    "memory": "10.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1919,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "99",
     "title": "Recover Binary Search Tree",
     "titleSlug": "recover-binary-search-tree",
     "translatedTitle": "恢复二叉搜索树"
    },
    "rawMemory": "10504000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/recover-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646145486,
    "totalTestCaseCnt": 1919
   }
  },
  "redundant-connection": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e findRedundantConnection(vector\u003cvector\u003cint\u003e\u003e\u0026 edges) {\n        vector\u003cint\u003e root(2000, -1);\n        for (auto \u0026edge : edges) {\n            int x = find(root, edge[0]);\n            int y = find(root, edge[1]);\n            if (x == y) {\n                return edge;\n            }\n            root[x] = y;\n        }\n        return {};\n    }\n\n    int find(vector\u003cint\u003e\u0026 root, int p) {\n        while (root[p] != -1) {\n            p = root[p];\n        }\n        return p;\n    }\n};",
    "id": "262030643",
    "lang": "cpp",
    "memory": "8.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "684",
     "title": "Redundant Connection",
     "titleSlug": "redundant-connection",
     "translatedTitle": "冗余连接"
    },
    "rawMemory": "9068000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/redundant-connection/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "使用简化并查集",
     "flagType": "RED"
    },
    "timestamp": 1643037274,
    "totalTestCaseCnt": 39
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func findRedundantConnection(edges [][]int) []int {\n    p := make([]int, len(edges) + 1)\n    for i := 0; i \u003c len(edges) + 1; i++ {\n        p[i] = i\n    }\n\n    for _, edge := range edges {\n        if find(p, edge[0]) ==  find(p , edge[1]) {\n            return edge\n        }\n        union(p, edge[0], edge[1])\n    }\n    return []int{}\n}\n\nfunc union(p []int, a, b int) {\n    rootA := find(p, a)\n    rootB := find(p, b)\n    if rootA != rootB {\n        p[rootA] = rootB\n    }\n}\n\nfunc find(p []int, a int) int {\n    if a != p[a] {\n        p[a] = find(p, p[a])\n    }\n    return p[a]\n}",
    "id": "262022520",
    "lang": "golang",
    "memory": "2.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "684",
     "title": "Redundant Connection",
     "titleSlug": "redundant-connection",
     "translatedTitle": "冗余连接"
    },
    "rawMemory": "2984000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/redundant-connection/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "使用并查集",
     "flagType": "RED"
    },
    "timestamp": 1643035865,
    "totalTestCaseCnt": 39
   }
  },
  "remove-duplicates-from-sorted-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int removeDuplicates(vector\u003cint\u003e\u0026 nums) {\n        int j = 1;\n        if (nums.size() == 0) {\n            return 0;\n        }\n        for (int i = 0; i \u003c nums.size(); i++) {\n            if (nums[i] != nums[j - 1]) {\n                nums[j++] = nums[i];\n            }\n        }\n        return j;\n    }\n};\n",
    "id": "9829458",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 161,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "26",
     "title": "Remove Duplicates from Sorted Array",
     "titleSlug": "remove-duplicates-from-sorted-array",
     "translatedTitle": "删除有序数组中的重复项"
    },
    "rawMemory": "N/A",
    "runtime": "20 ms",
    "sourceUrl": "/problems/remove-duplicates-from-sorted-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543318229,
    "totalTestCaseCnt": 361
   }
  },
  "remove-duplicates-from-sorted-array-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int removeDuplicates(vector\u003cint\u003e\u0026 nums) {\n        int i = 0;\n        for (int n : nums)\n            if (i \u003c 2 || n \u003e nums[i-2])\n                nums[i++] = n;\n        return i;\n    }\n};",
    "id": "9833014",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 165,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "80",
     "title": "Remove Duplicates from Sorted Array II",
     "titleSlug": "remove-duplicates-from-sorted-array-ii",
     "translatedTitle": "删除有序数组中的重复项 II"
    },
    "rawMemory": "N/A",
    "runtime": "12 ms",
    "sourceUrl": "/problems/remove-duplicates-from-sorted-array-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543322149,
    "totalTestCaseCnt": 164
   }
  },
  "remove-duplicates-from-sorted-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* curr = head;\n        while (curr) {\n            if (curr-\u003enext == nullptr) break;\n\n            if (curr-\u003eval == curr-\u003enext-\u003eval) {\n                ListNode* d = curr-\u003enext;\n                curr-\u003enext = curr-\u003enext-\u003enext;\n                delete d;\n            } else {\n                curr = curr-\u003enext;\n            }\n        }\n        return head;\n    }\n};",
    "id": "10197123",
    "lang": "cpp",
    "memory": "839.7 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 165,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "83",
     "title": "Remove Duplicates from Sorted List",
     "titleSlug": "remove-duplicates-from-sorted-list",
     "translatedTitle": "删除排序链表中的重复元素"
    },
    "rawMemory": "839680",
    "runtime": "8 ms",
    "sourceUrl": "/problems/remove-duplicates-from-sorted-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544113369,
    "totalTestCaseCnt": 166
   }
  },
  "remove-duplicates-from-sorted-list-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode *pre = \u0026dummy, *curr = head;\n\n        while (curr) {\n            ListNode* next = curr-\u003enext;\n            if (next == NULL) break;\n            if (curr-\u003eval == next-\u003eval) {\n                while (next \u0026\u0026 curr-\u003eval == next-\u003eval) {\n                    next = next-\u003enext;\n                }\n                pre-\u003enext = next;\n                curr = next;\n            } else {\n                pre = curr;\n                curr = next;\n            }\n        }\n        return dummy.next;\n    }\n};",
    "id": "10706662",
    "lang": "cpp",
    "memory": "1.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 168,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "82",
     "title": "Remove Duplicates from Sorted List II",
     "titleSlug": "remove-duplicates-from-sorted-list-ii",
     "translatedTitle": "删除排序链表中的重复元素 II"
    },
    "rawMemory": "1204224",
    "runtime": "4 ms",
    "sourceUrl": "/problems/remove-duplicates-from-sorted-list-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545320650,
    "totalTestCaseCnt": 166
   }
  },
  "remove-element": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int removeElement(vector\u003cint\u003e\u0026 nums, int val) {\n        int j = 0, k = nums.size();\n        while (j \u003c k) {\n            if (nums[j] == val) {\n                nums[j] = nums[--k];\n            } else {\n                // 注意这里是 else，避免重复的val之间移动的问题\n                j++;\n            }\n        }\n\n        return k;\n    }\n};",
    "id": "262698769",
    "lang": "cpp",
    "memory": "8.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 113,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "27",
     "title": "Remove Element",
     "titleSlug": "remove-element",
     "translatedTitle": "移除元素"
    },
    "rawMemory": "8864000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/remove-element/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643214379,
    "totalTestCaseCnt": 113
   }
  },
  "remove-linked-list-elements": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeElements(struct ListNode* head, int val) {\n    struct ListNode **list = \u0026head;\n    while (*list != NULL) {\n        if ((*list)-\u003eval == val) {\n            *list = (*list)-\u003enext;\n        } else {\n            list = \u0026(*list)-\u003enext;\n        }\n    }\n    return head;\n}",
    "id": "8386582",
    "lang": "c",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 65,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "203",
     "title": "Remove Linked List Elements",
     "titleSlug": "remove-linked-list-elements",
     "translatedTitle": "移除链表元素"
    },
    "rawMemory": "N/A",
    "runtime": "8 ms",
    "sourceUrl": "/problems/remove-linked-list-elements/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539792156,
    "totalTestCaseCnt": 66
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode *curr = head;\n        ListNode *pre = NULL;\n        while (curr) {\n            if (curr-\u003eval == val) {\n                if (pre != NULL)\n                    pre-\u003enext = curr-\u003enext;\n                else \n                    head = head-\u003enext;\n            } else {\n                pre = curr;\n            }\n            curr = curr-\u003enext;\n        }\n        return head;\n    }\n};",
    "id": "8562451",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 65,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "203",
     "title": "Remove Linked List Elements",
     "titleSlug": "remove-linked-list-elements",
     "translatedTitle": "移除链表元素"
    },
    "rawMemory": "N/A",
    "runtime": "40 ms",
    "sourceUrl": "/problems/remove-linked-list-elements/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1540217715,
    "totalTestCaseCnt": 66
   }
  },
  "remove-nth-node-from-end-of-list": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n    struct ListNode* fast = head;\n    struct ListNode dummy = {.next = head};\n    for (int i = 0; i \u003c n; i++) {\n        fast = fast-\u003enext;\n    }\n    struct ListNode* pre = \u0026dummy;\n    while (fast) {\n        fast = fast-\u003enext;\n        pre = head;\n        head = head-\u003enext;\n    }\n    pre-\u003enext = head-\u003enext;\n    free(head);\n    return dummy.next;\n}",
    "id": "264086649",
    "lang": "c",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "19",
     "title": "Remove Nth Node From End of List",
     "titleSlug": "remove-nth-node-from-end-of-list",
     "translatedTitle": "删除链表的倒数第 N 个结点"
    },
    "rawMemory": "5924000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/remove-nth-node-from-end-of-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "ok!!!",
     "flagType": "RED"
    },
    "timestamp": 1643708751,
    "totalTestCaseCnt": 208
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* fast = head;\n        ListNode dummy;\n        dummy.next = head;\n\n        for (int i = 0; i \u003c n; i++) {\n            if (fast == nullptr) \n                return nullptr;\n            fast = fast-\u003enext; \n        }\n        ListNode* pre = \u0026dummy;\n        while (fast) {\n            fast = fast-\u003enext;\n            pre = head;\n            head = head-\u003enext;\n        }\n        pre-\u003enext = head-\u003enext;\n        delete head;\n\n        return dummy.next;\n    }\n};",
    "id": "263420330",
    "lang": "cpp",
    "memory": "10.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 208,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "19",
     "title": "Remove Nth Node From End of List",
     "titleSlug": "remove-nth-node-from-end-of-list",
     "translatedTitle": "删除链表的倒数第 N 个结点"
    },
    "rawMemory": "10700000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/remove-nth-node-from-end-of-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "快慢指针",
     "flagType": "RED"
    },
    "timestamp": 1643435755,
    "totalTestCaseCnt": 208
   }
  },
  "reorder-list": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nvoid reorderList(struct ListNode* head){\n    // 1 分一半\n    // 2 逆序\n    // 3 合并\n    if (head == NULL || head-\u003enext == NULL) return head;\n    // 1\n    struct ListNode *fast = head, *slow = head;\n    while (fast \u0026\u0026 fast-\u003enext) {\n        fast = fast-\u003enext-\u003enext;\n        slow = slow-\u003enext;\n    }\n    struct ListNode *l2 = slow-\u003enext, *l1 = head;\n    slow-\u003enext = NULL;\n    // 2\n    struct ListNode *prev = NULL, *next = NULL;\n    while (l2) {\n        next = l2-\u003enext;\n        l2-\u003enext = prev;\n        prev = l2;\n        l2 = next;\n    }\n    l2 = prev;\n    // 3\n    while (l1 \u0026\u0026 l2) {\n        struct ListNode* l1next = l1-\u003enext;\n        struct ListNode* l2next = l2-\u003enext;\n\n        l2-\u003enext = l1next;\n        l1-\u003enext = l2;\n        l1 = l1next;\n        l2 = l2next;\n    }\n    return head;\n}",
    "id": "265017271",
    "lang": "c",
    "memory": "8.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 12,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "143",
     "title": "Reorder List",
     "titleSlug": "reorder-list",
     "translatedTitle": "重排链表"
    },
    "rawMemory": "8916000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/reorder-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644070950,
    "totalTestCaseCnt": 12
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if (head == nullptr) return;\n        vector\u003cListNode*\u003e vec;\n        while (head) {\n            vec.push_back(head);\n            head = head-\u003enext;\n        }\n        int i = 0, j = vec.size() - 1;\n        while (i \u003c j) {\n            vec[i++]-\u003enext = vec[j];\n            if (i == j) break;\n            vec[j--]-\u003enext = vec[i];\n        }\n        //这一步不能忘啊。\n        vec[i]-\u003enext = nullptr;\n    }\n};",
    "id": "264819527",
    "lang": "cpp",
    "memory": "18.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 12,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "143",
     "title": "Reorder List",
     "titleSlug": "reorder-list",
     "translatedTitle": "重排链表"
    },
    "rawMemory": "19040000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/reorder-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643994523,
    "totalTestCaseCnt": 12
   }
  },
  "repeated-substring-pattern": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool repeatedSubstringPattern(string str) {\n        string nextStr = str;\n        int len = str.length();\n        if(len \u003c 1) return false;\n        for(int i = 1; i \u003c= len / 2; i++){\n            if(len % i == 0){\n                nextStr = leftShift(str, i);\n                if(nextStr == str) return true;\n            }\n        }\n        return false;\n    }\n    \n    string leftShift(string \u0026str, int l){\n        string ret = str.substr(l);\n        ret += str.substr(0, l);\n        return ret;\n    }\n};",
    "id": "10117336",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 120,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "459",
     "title": "Repeated Substring Pattern",
     "titleSlug": "repeated-substring-pattern",
     "translatedTitle": "重复的子字符串"
    },
    "rawMemory": "N/A",
    "runtime": "28 ms",
    "sourceUrl": "/problems/repeated-substring-pattern/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543980532,
    "totalTestCaseCnt": 129
   }
  },
  "restore-ip-addresses": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cstring\u003e restoreIpAddresses(string s) {\n        vector\u003cstring\u003e res;\n        vector\u003cstring\u003e ip;\n        if (s.size() \u003c 4 || s.size() \u003e 12) return res;\n        solve(s, 0, ip, res);\n        return res;\n    }\n\nprivate:\n    void solve(string s, int index, vector\u003cstring\u003e \u0026ip, vector\u003cstring\u003e \u0026res) {\n        if (index == s.size()) {\n            if (ip.size() == 4) {\n                string ip_addr = ip[0] + \".\" + ip[1] + \".\" + ip[2] + \".\" + ip[3];\n                res.push_back(ip_addr);\n            }\n            return;\n        }\n        for (int step = 1; step \u003c= 3; step++) {\n            //s.size() - index is the lefted chars count,  the rule :\n            //e.g.\n            //have restored 1 of 4 ip number, the lefted chars count must less than 9 \"3*(4 - 1)\"\n            if (3 * (4 - ip.size())  \u003c s.size() - index) {\n                //cout \u003c\u003c \"\\U0001f602\\U0001f602\\U0001f602\\U0001f602\" \u003c\u003c endl;\n                break;\n            }\n            if (index + step \u003e s.size()) {\n                break;\n            }\n            //first byte can't be 0, if string size longer than 1\n            if (step \u003e 1 \u0026\u0026 s[index] == '0') {\n                continue;\n            }\n            string tmp = s.substr(index, step);\n            int num = stoi(tmp);\n            if (num \u003e= 0 \u0026\u0026 num \u003c= 255) {\n                ip.push_back(tmp);\n                solve(s, index + step, ip, res);\n                ip.pop_back();\n            }\n        }\n    }\n};",
    "id": "10577645",
    "lang": "cpp",
    "memory": "815.1 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 147,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "93",
     "title": "Restore IP Addresses",
     "titleSlug": "restore-ip-addresses",
     "translatedTitle": "复原 IP 地址"
    },
    "rawMemory": "815104",
    "runtime": "0 ms",
    "sourceUrl": "/problems/restore-ip-addresses/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545067909,
    "totalTestCaseCnt": 145
   }
  },
  "reverse-bits": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t ret = 0;\n        for (int i = 0; i \u003c 32 \u0026\u0026 n \u003e 0; i++) {\n            ret |=  (n \u0026 1) \u003c\u003c (31-i);\n            n \u003e\u003e= 1;\n        }\n        return ret;\n    }\n};",
    "id": "234489703",
    "lang": "cpp",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 600,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "190",
     "title": "Reverse Bits",
     "titleSlug": "reverse-bits",
     "translatedTitle": "颠倒二进制位"
    },
    "rawMemory": "6020000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/reverse-bits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635774237,
    "totalTestCaseCnt": 600
   }
  },
  "reverse-integer": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int reverse(int x) {\n        int ret = 0;\n        while (x != 0) {\n            // 这里不用判断取余了，因为 x 也是 int\n            if (ret \u003e INT_MAX/10 || ret  \u003c INT_MIN/10) {\n                return 0;\n            }\n            ret = ret * 10 + x%10;\n            x /= 10;\n        }\n        return ret;\n    }\n};",
    "id": "234507065",
    "lang": "cpp",
    "memory": "5.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1032,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "7",
     "title": "Reverse Integer",
     "titleSlug": "reverse-integer",
     "translatedTitle": "整数反转"
    },
    "rawMemory": "5828000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/reverse-integer/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635776816,
    "totalTestCaseCnt": 1032
   }
  },
  "reverse-linked-list": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* reverseList(struct ListNode* head){\n    if (head == NULL || head-\u003enext == NULL) {\n        return head;\n    }\n    struct ListNode* new_head = reverseList(head-\u003enext);\n    head-\u003enext-\u003enext = head;\n    head-\u003enext = NULL;\n    return new_head;\n}",
    "id": "264051501",
    "lang": "c",
    "memory": "6.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "206",
     "title": "Reverse Linked List",
     "titleSlug": "reverse-linked-list",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "6492000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/reverse-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "递归写错了吗？",
     "flagType": "RED"
    },
    "timestamp": 1643697923,
    "totalTestCaseCnt": 28
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* curr = head;\n        ListNode* prev = nullptr;\n        while (curr) {\n            auto next = curr-\u003enext;\n            curr-\u003enext = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};",
    "id": "276880987",
    "lang": "cpp",
    "memory": "8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "206",
     "title": "Reverse Linked List",
     "titleSlug": "reverse-linked-list",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "8172000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/reverse-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646321759,
    "totalTestCaseCnt": 28
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseList(head *ListNode) *ListNode {\n    var pre, next *ListNode = nil, nil\n    for head != nil {\n        next, head.Next = head.Next, pre\n        pre , head = head, next\n    }\n    return pre\n}",
    "id": "264053863",
    "lang": "golang",
    "memory": "2.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "206",
     "title": "Reverse Linked List",
     "titleSlug": "reverse-linked-list",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "2452000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/reverse-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "简单",
     "flagType": "RED"
    },
    "timestamp": 1643698861,
    "totalTestCaseCnt": 28
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null, next = null;\n        while (head != null) {\n            next = head.next;\n            head.next = pre;\n            pre = head;\n            head = next;\n        }\n        return pre;\n    }\n}",
    "id": "264055176",
    "lang": "java",
    "memory": "41.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "206",
     "title": "Reverse Linked List",
     "titleSlug": "reverse-linked-list",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "42240000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/reverse-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643699391,
    "totalTestCaseCnt": 28
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: ListNode) -\u003e ListNode:\n        if head == None or head.next == None :\n            return head\n        new_head = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return new_head ",
    "id": "264052386",
    "lang": "python3",
    "memory": "20.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "206",
     "title": "Reverse Linked List",
     "titleSlug": "reverse-linked-list",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "21284000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/reverse-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643698276,
    "totalTestCaseCnt": 28
   },
   "rust": {
    "__typename": "GeneralSubmissionNode",
    "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option\u003cBox\u003cListNode\u003e\u003e\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -\u003e Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_list(head: Option\u003cBox\u003cListNode\u003e\u003e) -\u003e Option\u003cBox\u003cListNode\u003e\u003e {\n        if head.is_none() { return None; }\n        let mut prev = None;\n        let mut current = head;\n        while let Some(mut tmp) = current.take() {\n\t        let next = tmp.next.take();\n\t        tmp.next = prev.take();\n\t        prev = Some(tmp);\n\t        current = next;\n        }\n        prev\n    }\n}",
    "id": "264056297",
    "lang": "rust",
    "memory": "2.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "206",
     "title": "Reverse Linked List",
     "titleSlug": "reverse-linked-list",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "2452000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/reverse-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643699840,
    "totalTestCaseCnt": 28
   },
   "typescript": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction reverseList(head: ListNode | null): ListNode | null {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    let newNode = reverseList(head.next)\n    head.next.next = head\n    head.next = null\n    return newNode\n};",
    "id": "264054701",
    "lang": "typescript",
    "memory": "44.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "206",
     "title": "Reverse Linked List",
     "titleSlug": "reverse-linked-list",
     "translatedTitle": "反转链表"
    },
    "rawMemory": "45196000",
    "runtime": "72 ms",
    "sourceUrl": "/problems/reverse-linked-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643699192,
    "totalTestCaseCnt": 28
   }
  },
  "reverse-linked-list-ii": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\n    struct ListNode dummy = {.next = head};\n    struct ListNode *curr = head, *pre = \u0026dummy, *next;\n    int index = 0;\n    while (curr) {\n        if (++index \u003e= left \u0026\u0026 index \u003c right) {\n            next = curr-\u003enext;\n            curr-\u003enext = next-\u003enext;\n            next-\u003enext = pre-\u003enext;\n            pre-\u003enext = next;\n        } else {\n            pre = curr;\n            curr = curr-\u003enext;\n        }\n    }\n    return dummy.next;\n}",
    "id": "264504262",
    "lang": "c",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 44,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "92",
     "title": "Reverse Linked List II",
     "titleSlug": "reverse-linked-list-ii",
     "translatedTitle": "反转链表 II"
    },
    "rawMemory": "6008000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/reverse-linked-list-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643883031,
    "totalTestCaseCnt": 44
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        ListNode *dummy = new ListNode(-1), *pre = dummy;\n        dummy-\u003enext = head;\n\n        for (int i = 0; i \u003c left - 1; ++i) {\n            pre = pre-\u003enext;\n        }\n        ListNode *curr = pre-\u003enext;\n        for (int i = left; i \u003c right; ++i) {\n            ListNode *t = curr-\u003enext;\n            curr-\u003enext = t-\u003enext;\n            t-\u003enext = pre-\u003enext;\n            pre-\u003enext = t;\n        }\n        return dummy-\u003enext;\n    }\n};",
    "id": "263018770",
    "lang": "cpp",
    "memory": "7.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 44,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "92",
     "title": "Reverse Linked List II",
     "titleSlug": "reverse-linked-list-ii",
     "translatedTitle": "反转链表 II"
    },
    "rawMemory": "7512000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/reverse-linked-list-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "经典答案",
     "flagType": "RED"
    },
    "timestamp": 1643299334,
    "totalTestCaseCnt": 44
   }
  },
  "reverse-nodes-in-k-group": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        int list_len = 0;\n        ListNode dummy;\n        dummy.next = head;\n        while (head) {\n            head = head-\u003enext;\n            list_len++;\n        }\n\n        ListNode* pre = \u0026dummy;\n        head = dummy.next;\n        for (int i = 0; i \u003c list_len / k; i++) {\n            for (int j = 1; j \u003c k; j++) {\n                auto next = head-\u003enext;\n                head-\u003enext = head-\u003enext-\u003enext;\n                next-\u003enext = pre-\u003enext;\n                pre-\u003enext = next;\n            }\n            pre = head;\n            head = head-\u003enext;\n        }\n\n        return dummy.next;\n    }\n};",
    "id": "264582098",
    "lang": "cpp",
    "memory": "11.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 62,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "25",
     "title": "Reverse Nodes in k-Group",
     "titleSlug": "reverse-nodes-in-k-group",
     "translatedTitle": "K 个一组翻转链表"
    },
    "rawMemory": "11440000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/reverse-nodes-in-k-group/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643903903,
    "totalTestCaseCnt": 62
   }
  },
  "reverse-only-letters": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string reverseOnlyLetters(string s) {\n        int i = 0, j = s.size() - 1;\n        while (i \u003c j) {\n            if (!isalpha(s[i])) {\n                i++;\n                continue;\n            }\n            if (!isalpha(s[j])) {\n                j--;\n                continue;\n            }\n            std::swap(s[i++], s[j--]);\n        }\n        return s;\n    }\n};",
    "id": "272028757",
    "lang": "cpp",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 115,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "953",
     "title": "Reverse Only Letters",
     "titleSlug": "reverse-only-letters",
     "translatedTitle": "仅仅反转字母"
    },
    "rawMemory": "6132000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/reverse-only-letters/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1645581931,
    "totalTestCaseCnt": 115
   }
  },
  "reverse-string": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string reverseString(string s) {\n        int l = 0, r = s.size() - 1;\n        while (l \u003c r) {\n            std::swap(s[l++], s[r--]);\n        }\n        return s;\n    }\n};",
    "id": "9873862",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 476,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "344",
     "title": "Reverse String",
     "titleSlug": "reverse-string",
     "translatedTitle": "反转字符串"
    },
    "rawMemory": "N/A",
    "runtime": "12 ms",
    "sourceUrl": "/problems/reverse-string/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543408058,
    "totalTestCaseCnt": 477
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def reverseString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        return s[::-1]\n        ",
    "id": "8412507",
    "lang": "python3",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 476,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "344",
     "title": "Reverse String",
     "titleSlug": "reverse-string",
     "translatedTitle": "反转字符串"
    },
    "rawMemory": "N/A",
    "runtime": "60 ms",
    "sourceUrl": "/problems/reverse-string/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539854928,
    "totalTestCaseCnt": 477
   }
  },
  "reverse-string-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string reverseStr(string s, int k) {\n        int k2 = 2*k;\n        int r = 0, l = 0, m = 0; //[l,m) [m, r)\n        for (int i = 0; i \u003c s.size(); i = r) {\n            int last = s.size() - i;\n            if (last \u003e= k) {\n                m = i + k;\n                r = i + min(k2, last);\n            } else {\n                m = i + last;\n                r = i + last;\n            }\n            l = i;\n            while (l + 1 \u003c m) {\n                swap(s[l++], s[--m]);\n            }\n        }\n        return s;\n    }\n};",
    "id": "10499823",
    "lang": "cpp",
    "memory": "1.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "541",
     "title": "Reverse String II",
     "titleSlug": "reverse-string-ii",
     "translatedTitle": "反转字符串 II"
    },
    "rawMemory": "1134592",
    "runtime": "8 ms",
    "sourceUrl": "/problems/reverse-string-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544871217,
    "totalTestCaseCnt": 60
   }
  },
  "reverse-vowels-of-a-string": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        int dict[256] = {0};\n        dict['a'] = 1, dict['A'] = 1;\n        dict['e'] = 1, dict['E'] = 1;\n        dict['i'] = 1, dict['I'] = 1;\n        dict['o'] = 1, dict['O'] = 1;\n        dict['u'] = 1, dict['U'] = 1;\n        int start = 0, end = s.size() - 1;\n        while (start \u003c end) {\n            while (start \u003c end \u0026\u0026 !dict[s[start]]) start++;\n            while (start \u003c end \u0026\u0026 !dict[s[end]]) end--;\n            swap(s[start], s[end]);\n            start++;\n            end--;\n        }\n        return s;\n    }\n};\n\n",
    "id": "9875753",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 481,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "345",
     "title": "Reverse Vowels of a String",
     "titleSlug": "reverse-vowels-of-a-string",
     "translatedTitle": "反转字符串中的元音字母"
    },
    "rawMemory": "N/A",
    "runtime": "12 ms",
    "sourceUrl": "/problems/reverse-vowels-of-a-string/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543410095,
    "totalTestCaseCnt": 480
   }
  },
  "reverse-words-in-a-string": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void reverseWords(string \u0026s) {\n        vector\u003cstring\u003e elems = split(s);\n        if (elems.size() == 0) {\n            s = \"\";\n            return ;\n        }\n        vector\u003cstring\u003e::reverse_iterator r_iter;\n        for (r_iter = elems.rbegin(); r_iter != elems.rend(); r_iter++) {\n            if (r_iter != elems.rbegin())\n                s += \" \" + *r_iter;\n            else s = *r_iter;\n        }\n    }\n\nprivate:\n    vector\u003cstring\u003e split(const string \u0026s) {\n        vector\u003cstring\u003e res;\n        int start = nextNonSpace(s, 0);\n        for (int i = start + 1; i \u003c= s.size();)\n            if (i == s.size() || s[i] == ' ') {\n                res.push_back(s.substr(start, i - start));\n                start = nextNonSpace(s, i);\n                i = start + 1;\n            } else\n                i++;\n        return res;\n    }\n\n    int nextNonSpace(const string \u0026s, int start) {\n        int i = start;\n        for (; i \u003c s.size(); i++)\n            if (s[i] != ' ')\n                return i;\n        return i;\n    };\n};",
    "id": "9991379",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 23,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "151",
     "title": "Reverse Words in a String",
     "titleSlug": "reverse-words-in-a-string",
     "translatedTitle": "颠倒字符串中的单词"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/reverse-words-in-a-string/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543686915,
    "totalTestCaseCnt": 58
   }
  },
  "reverse-words-in-a-string-iii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\nprivate:\n    void reverse(string\u0026 s, int l, int r) {\n        //[l, r]\n        while (l \u003c r) {\n            swap(s[l++], s[r--]);\n        }\n    }\n\npublic:\n    string reverseWords(string s) {\n        int b = 0, e = 0;\n        for (int i = 0; i \u003c s.size(); i++) {\n            while (isblank(s[i])) {\n                i++;\n                b = i;\n            }\n            if (i + 1 == s.size() || isblank(s[i + 1])) {\n                e = i;\n                reverse(s, b, e);\n            }\n        }\n        return s;\n    }\n};",
    "id": "10507823",
    "lang": "cpp",
    "memory": "1.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 30,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "557",
     "title": "Reverse Words in a String III",
     "titleSlug": "reverse-words-in-a-string-iii",
     "translatedTitle": "反转字符串中的单词 III"
    },
    "rawMemory": "1249280",
    "runtime": "20 ms",
    "sourceUrl": "/problems/reverse-words-in-a-string-iii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544887882,
    "totalTestCaseCnt": 29
   }
  },
  "richest-customer-wealth": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int maximumWealth(int** accounts, int accountsSize, int* accountsColSize){\n    int maxW = 0;\n    for (int i = 0; i \u003c accountsSize; i++) {\n        int wealthOneAccount = 0;\n        for (int j = 0; j \u003c accountsColSize[i]; j++) {\n            wealthOneAccount += accounts[i][j];\n        }\n        if (maxW \u003c wealthOneAccount) {\n            maxW = wealthOneAccount;\n        } \n    }\n    return maxW;\n}",
    "id": "232972174",
    "lang": "c",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1791",
     "title": "Richest Customer Wealth",
     "titleSlug": "richest-customer-wealth",
     "translatedTitle": "最富有客户的资产总量"
    },
    "rawMemory": "6184000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/richest-customer-wealth/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635341300,
    "totalTestCaseCnt": 34
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int maximumWealth(vector\u003cvector\u003cint\u003e\u003e\u0026 accounts) {\n        vector\u003cint\u003e res;\n        for (auto \u0026v : accounts) {\n            res.push_back(accumulate(v.begin(), v.end(), 0));\n        }\n        sort(res.begin(), res.end());\n        return res.back();\n    }\n};",
    "id": "232967645",
    "lang": "cpp",
    "memory": "7.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1791",
     "title": "Richest Customer Wealth",
     "titleSlug": "richest-customer-wealth",
     "translatedTitle": "最富有客户的资产总量"
    },
    "rawMemory": "7916000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/richest-customer-wealth/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635340583,
    "totalTestCaseCnt": 34
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func maximumWealth(accounts [][]int) int {\n    // 原地操作\n    for i := 0; i \u003c len(accounts); i++ {\n        for j := 1; j \u003c len(accounts[0]); j++ {\n            accounts[i][0] += accounts[i][j]\n        }\n        if accounts[0][0] \u003c accounts[i][0] {\n            accounts[0][0] = accounts[i][0]\n        }\n    }\n    return accounts[0][0]\n}",
    "id": "232993235",
    "lang": "golang",
    "memory": "3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1791",
     "title": "Richest Customer Wealth",
     "titleSlug": "richest-customer-wealth",
     "translatedTitle": "最富有客户的资产总量"
    },
    "rawMemory": "3092000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/richest-customer-wealth/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635344623,
    "totalTestCaseCnt": 34
   },
   "python": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution(object):\n    def maximumWealth(self, accounts):\n        \"\"\"\n        :type accounts: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return max([sum(account) for account in accounts])",
    "id": "232975881",
    "lang": "python",
    "memory": "13.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1791",
     "title": "Richest Customer Wealth",
     "titleSlug": "richest-customer-wealth",
     "translatedTitle": "最富有客户的资产总量"
    },
    "rawMemory": "13388000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/richest-customer-wealth/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635341843,
    "totalTestCaseCnt": 34
   },
   "rust": {
    "__typename": "GeneralSubmissionNode",
    "code": "impl Solution {\n    pub fn maximum_wealth(accounts: Vec\u003cVec\u003ci32\u003e\u003e) -\u003e i32 {\n        accounts.iter()\n            .map(|v|v.iter().sum())\n            .max()\n            .unwrap()\n    }\n}",
    "id": "232965290",
    "lang": "rust",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1791",
     "title": "Richest Customer Wealth",
     "titleSlug": "richest-customer-wealth",
     "translatedTitle": "最富有客户的资产总量"
    },
    "rawMemory": "2068000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/richest-customer-wealth/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635340204,
    "totalTestCaseCnt": 34
   }
  },
  "roman-to-integer": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\n\npublic:\n    int ToNum(char c, char l) {\n        if (c == 'I') return 1;\n        else if (c == 'V' \u0026\u0026 l == 'I') return 3;\n        else if (c == 'V') return 5;\n        else if (c == 'X' \u0026\u0026 l == 'I') return 8;\n        else if (c == 'X') return 10;\n        else if (c == 'L' \u0026\u0026 l == 'X') return 30;\n        else if (c == 'L') return 50;\n        else if (c == 'C' \u0026\u0026 l == 'X') return 80;\n        else if (c == 'C') return 100;\n        else if (c == 'D' \u0026\u0026 l == 'C') return 300;\n        else if (c == 'D') return 500;\n        else if (c == 'M' \u0026\u0026 l == 'C') return 800;\n        else if (c == 'M') return 1000;\n        else return 0;\n    }\n\n    int romanToInt(string s) {\n        int b = 0, n = 0;\n        char l = 0;\n        for (auto c : s) {\n            b = ToNum(c, l);\n            n = n + b;\n            l = c;\n        }\n        return n;\n    }\n};\n\n",
    "id": "9344974",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 3999,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "13",
     "title": "Roman to Integer",
     "titleSlug": "roman-to-integer",
     "translatedTitle": "罗马数字转整数"
    },
    "rawMemory": "N/A",
    "runtime": "48 ms",
    "sourceUrl": "/problems/roman-to-integer/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1542125344,
    "totalTestCaseCnt": 3999
   }
  },
  "rotate-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void rotate(vector\u003cint\u003e\u0026 nums, int k) {\n        auto size = nums.size();\n        if (size == 1) {\n            return ;\n        }\n        for (auto i = 0; i \u003c k; i++) {\n            auto f = nums[0];\n            auto e = nums[size - 1];\n            for (auto j = size - 1; j \u003e 1; j--) {\n                nums[j] = nums[j - 1]; \n            }\n            nums[1] = f;\n            nums[0] = e;\n            //auto new_index = (i + k) % size;\n        }\n    }\n};",
    "id": "8326168",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 34,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "189",
     "title": "Rotate Array",
     "titleSlug": "rotate-array",
     "translatedTitle": "轮转数组"
    },
    "rawMemory": "N/A",
    "runtime": "332 ms",
    "sourceUrl": "/problems/rotate-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539683163,
    "totalTestCaseCnt": 38
   }
  },
  "rotate-image": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void rotate(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) {\n        int rowSize = matrix.size();\n        int colSize = matrix[0].size();\n\n        // assert(rowSize, colSize);\n\n        for (int i = 0; i \u003c rowSize / 2; i++) {\n            for (int j = 0; j \u003c colSize; j++) {\n                std::swap(matrix[i][j], matrix[rowSize - i - 1][j]);\n            }\n        }\n\n        for (int i = 0; i \u003c rowSize; i++) {\n            for (int j = 0; j \u003c i; j++) {\n                if (i != j)\n                    std::swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n    }\n};",
    "id": "261320864",
    "lang": "cpp",
    "memory": "6.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "48",
     "title": "Rotate Image",
     "titleSlug": "rotate-image",
     "translatedTitle": "旋转图像"
    },
    "rawMemory": "6888000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/rotate-image/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OK\n",
     "flagType": "RED"
    },
    "timestamp": 1642858650,
    "totalTestCaseCnt": 21
   }
  },
  "rotate-list": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* rotateRight(struct ListNode* head, int k){\n    if (head == NULL) return NULL;\n    struct ListNode *last = head;\n    int list_len = 1;\n    while (last-\u003enext) {\n        list_len++;\n        last = last-\u003enext;\n    }\n    last-\u003enext = head;\n    for (int i = 0; i \u003c list_len - (k % list_len); i++) {\n        last = last-\u003enext;\n    }\n    head = last-\u003enext;\n    last-\u003enext = NULL;\n    return head;\n}",
    "id": "264509440",
    "lang": "c",
    "memory": "6.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 231,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "61",
     "title": "Rotate List",
     "titleSlug": "rotate-list",
     "translatedTitle": "旋转链表"
    },
    "rawMemory": "6264000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/rotate-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OK",
     "flagType": "RED"
    },
    "timestamp": 1643884848,
    "totalTestCaseCnt": 231
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr) return nullptr;\n        ListNode* last = head;\n        int list_len = 1;\n        for (; last-\u003enext; list_len++, last = last-\u003enext );\n        last-\u003enext = head;\n\n        for (int i = 0; i \u003c list_len - (k % list_len); i++) {\n            last = last-\u003enext;\n        }\n        head = last-\u003enext;\n        last-\u003enext = nullptr;\n        return head;\n    }\n};",
    "id": "264517602",
    "lang": "cpp",
    "memory": "11.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 231,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "61",
     "title": "Rotate List",
     "titleSlug": "rotate-list",
     "translatedTitle": "旋转链表"
    },
    "rawMemory": "11796000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/rotate-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643887751,
    "totalTestCaseCnt": 231
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    last := head\n    if last == nil {\n        return nil\n    }\n    listLen := 1\n    for last.Next != nil {\n        listLen++\n        last = last.Next;\n    }\n    last.Next = head;\n    for i := 0; i \u003c listLen - (k % listLen); i++ {\n        last = last.Next\n    }\n    head = last.Next\n    last.Next = nil\n    return head \n}",
    "id": "264510567",
    "lang": "golang",
    "memory": "2.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 231,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "61",
     "title": "Rotate List",
     "titleSlug": "rotate-list",
     "translatedTitle": "旋转链表"
    },
    "rawMemory": "2492000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/rotate-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "注意长度。",
     "flagType": "PURPLE"
    },
    "timestamp": 1643885268,
    "totalTestCaseCnt": 231
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -\u003e Optional[ListNode]:\n        if head == None:\n            return head\n        last = head\n        list_len = 1\n        while last.next:\n            last = last.next\n            list_len += 1\n        # link to head\n        last.next = head\n        for _ in range(0, list_len - (k % list_len)):\n            last = last.next\n        head = last.next\n        last.next = None\n        return head",
    "id": "264518218",
    "lang": "python3",
    "memory": "15 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 231,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "61",
     "title": "Rotate List",
     "titleSlug": "rotate-list",
     "translatedTitle": "旋转链表"
    },
    "rawMemory": "15360000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/rotate-list/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643887955,
    "totalTestCaseCnt": 231
   }
  },
  "rotate-string": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool rotateString(string A, string B) {\n        if (A.size() != B.size()) return false;\n        \n        return (A + A).find(B) != string::npos;\n    }\n};",
    "id": "10366662",
    "lang": "cpp",
    "memory": "1011.7 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 44,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "812",
     "title": "Rotate String",
     "titleSlug": "rotate-string",
     "translatedTitle": "旋转字符串"
    },
    "rawMemory": "1011712",
    "runtime": "0 ms",
    "sourceUrl": "/problems/rotate-string/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544532970,
    "totalTestCaseCnt": 45
   }
  },
  "rotated-digits": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int check_Digit(int n) {\n        int rotate_map[10] = {0,1,5,-1,-1,2,9,-1,8,6};\n        int n1 = 0;\n        int n2 = 0;\n        while (n) {\n            int mod = n % 10;\n            if (rotate_map[mod] \u003c 0) return 0;\n            n1 += n1 * 10 + mod;\n            n2 += n2 * 10 + rotate_map[mod];\n            n /= 10;\n        }\n        return (int)n1 != n2;\n    }\n    \n    int rotatedDigits(int N) {\n        int res = 0;\n        while (N) {\n            int x = check_Digit(N);\n            res += x;\n            N--;\n        }\n        return res;\n    }\n};",
    "id": "10503751",
    "lang": "cpp",
    "memory": "1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 50,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "804",
     "title": "Rotated Digits",
     "titleSlug": "rotated-digits",
     "translatedTitle": "旋转数字"
    },
    "rawMemory": "1036288",
    "runtime": "4 ms",
    "sourceUrl": "/problems/rotated-digits/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544879439,
    "totalTestCaseCnt": 50
   }
  },
  "same-tree": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\n    if (p == NULL \u0026\u0026 q == NULL) return true;\n    if (p == NULL || q ==  NULL) return false;\n    if (p-\u003eval != q-\u003eval) return false;\n    return isSameTree(p-\u003eleft, q-\u003eleft) \u0026\u0026 isSameTree(p-\u003eright, q-\u003eright);\n}",
    "id": "263343509",
    "lang": "c",
    "memory": "5.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100",
     "title": "Same Tree",
     "titleSlug": "same-tree",
     "translatedTitle": "相同的树"
    },
    "rawMemory": "5852000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/same-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643398180,
    "totalTestCaseCnt": 60
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr \u0026\u0026 q == nullptr) {\n            return true;\n        }\n        if (p == nullptr ^ q ==  nullptr) {\n            return false;\n        }\n        if (p-\u003eval != q-\u003eval) {\n            return false;\n        }\n\n        return isSameTree(p-\u003eleft, q-\u003eleft) \u0026\u0026 isSameTree(p-\u003eright, q-\u003eright);\n    }\n};",
    "id": "275415507",
    "lang": "cpp",
    "memory": "9.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100",
     "title": "Same Tree",
     "titleSlug": "same-tree",
     "translatedTitle": "相同的树"
    },
    "rawMemory": "9976000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/same-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646129549,
    "totalTestCaseCnt": 60
   }
  },
  "search-a-2d-matrix": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) {\n        // select raw\n        int j = 0, k = matrix.size() - 1;\n        while (j \u003c= k) {\n            int m = (j+k) \u003e\u003e 1;\n            if (matrix[m].front() \u003e target) {\n                k = m - 1;\n            } else if (matrix[m].back() \u003c target) {\n                j = m + 1;\n            } else {\n                int i = 0, h = matrix[m].size();\n                while (i \u003c h) {\n                    int mm = (i+h) \u003e\u003e 1;\n                    if (matrix[m][mm] \u003c target) {\n                        i = mm + 1;\n                    } else if (matrix[m][mm] \u003e target) {\n                        h = mm;\n                    } else {\n                        return true;\n                    }\n                }\n                break;\n            }\n        }\n        return false;\n    }\n};",
    "id": "264325372",
    "lang": "cpp",
    "memory": "9.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 133,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "74",
     "title": "Search a 2D Matrix",
     "titleSlug": "search-a-2d-matrix",
     "translatedTitle": "搜索二维矩阵"
    },
    "rawMemory": "9436000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/search-a-2d-matrix/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "okk",
     "flagType": "RED"
    },
    "timestamp": 1643807822,
    "totalTestCaseCnt": 133
   }
  },
  "search-in-a-binary-search-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        queue\u003cTreeNode*\u003e _q;\n        _q.push(root);\n\n        TreeNode* node = nullptr;\n        while (!_q.empty()) {\n            node = _q.front();\n            _q.pop();\n            if (node == nullptr || node-\u003eval == val) {\n                return node;\n            } else if (node-\u003eval \u003c val) {\n                _q.push(node-\u003eright);\n            } else {\n                _q.push(node-\u003eleft);\n            }\n        }\n\n        return nullptr;\n    }\n};",
    "id": "262903547",
    "lang": "cpp",
    "memory": "34 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "783",
     "title": "Search in a Binary Search Tree",
     "titleSlug": "search-in-a-binary-search-tree",
     "translatedTitle": "二叉搜索树中的搜索"
    },
    "rawMemory": "34808000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/search-in-a-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "队列",
     "flagType": "RED"
    },
    "timestamp": 1643274914,
    "totalTestCaseCnt": 36
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc searchBST(root *TreeNode, val int) *TreeNode {\n\tqueue := list.New()\n\tnode := queue.PushBack(root).Value.(*TreeNode)\n\n\tfor queue.Len() != 0 {\n\t\tnode = queue.Remove(queue.Front()).(*TreeNode)\n\t\tif node == nil || node.Val == val {\n\t\t\tbreak\n\t\t} else if val \u003e node.Val {\n\t\t\tqueue.PushBack(node.Right)\n\t\t} else {\n\t\t\tqueue.PushBack(node.Left)\n\t\t}\n\t}\n\treturn node\n}",
    "id": "180137078",
    "lang": "golang",
    "memory": "7.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "783",
     "title": "Search in a Binary Search Tree",
     "titleSlug": "search-in-a-binary-search-tree",
     "translatedTitle": "二叉搜索树中的搜索"
    },
    "rawMemory": "7288000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/search-in-a-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621764453,
    "totalTestCaseCnt": 36
   }
  },
  "search-in-a-sorted-array-of-unknown-size": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * *********************************************************************\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * *********************************************************************\n *\n * int getElement(ArrayReader *, int index);\n */\n\nint search(struct ArrayReader* reader, int target) {\n    int i = 0, j = 10e4+1;\n\n    while (i \u003c j) {\n        int m = (i+j)\u003e\u003e1;\n        int res = getElement(reader, m);\n        if (res \u003e target) {\n            j = m;\n        } else if (res \u003c target) {\n            i = m + 1;\n        } else {\n            return m;\n        }\n    }\n\n    return -1;    \n}",
    "id": "264320381",
    "lang": "c",
    "memory": "7.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "786",
     "title": "Search in a Sorted Array of Unknown Size",
     "titleSlug": "search-in-a-sorted-array-of-unknown-size",
     "translatedTitle": "搜索长度未知的有序数组"
    },
    "rawMemory": "7248000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/search-in-a-sorted-array-of-unknown-size/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643806591,
    "totalTestCaseCnt": 47
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * class ArrayReader {\n *   public:\n *     int get(int index);\n * };\n */\n\nclass Solution {\npublic:\n    int search(const ArrayReader\u0026 reader, int target) {\n        int i = 0, j = 10e4;\n        while (i \u003c j) {\n            int m = i + (j - i)/2;\n            if (reader.get(m) == INT_MAX) {\n                j = m;\n            } else {\n                i = m + 1;\n            }\n        }\n        \n        j = 0;\n\n        while (j \u003c i) {\n            int m = j + (i - i)/2;\n            if ((reader.get(m) \u003c target)) {\n                j = m + 1;\n            } else if ((reader.get(m) \u003e target)) {\n                i = m;\n            } else {\n                return m;\n            }\n        }\n        return -1;\n    }\n};",
    "id": "262391722",
    "lang": "cpp",
    "memory": "9.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 47,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "786",
     "title": "Search in a Sorted Array of Unknown Size",
     "titleSlug": "search-in-a-sorted-array-of-unknown-size",
     "translatedTitle": "搜索长度未知的有序数组"
    },
    "rawMemory": "9944000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/search-in-a-sorted-array-of-unknown-size/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643135347,
    "totalTestCaseCnt": 47
   }
  },
  "search-in-rotated-sorted-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int search(vector\u003cint\u003e\u0026 nums, int target) {\n        int lo = 0, hi = nums.size() - 1;\n\n        while (lo \u003c= hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n\n            if (nums[mid] \u003c nums[hi]) {\n                if (nums[mid] \u003c target \u0026\u0026 target \u003c= nums[hi]) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            } else {\n                if (nums[lo] \u003c= target \u0026\u0026 target \u003c nums[mid]) {\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            }\n\n        }\n        return -1;\n    }\n};",
    "id": "266296130",
    "lang": "cpp",
    "memory": "10.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 195,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "33",
     "title": "Search in Rotated Sorted Array",
     "titleSlug": "search-in-rotated-sorted-array",
     "translatedTitle": "搜索旋转排序数组"
    },
    "rawMemory": "10960000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/search-in-rotated-sorted-array/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644399400,
    "totalTestCaseCnt": 195
   }
  },
  "search-insert-position": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int searchInsert(vector\u003cint\u003e\u0026 nums, int target) {\n        int j = 0, k = nums.size();\n        while (j \u003c k) {\n            int m = j + (k -j )/2;\n            if (nums[m] \u003c target) {\n                j = m + 1;\n            } else  {\n                k = m; \n            }\n        }\n        return k;\n    }\n};",
    "id": "265692188",
    "lang": "cpp",
    "memory": "9.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 64,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "35",
     "title": "Search Insert Position",
     "titleSlug": "search-insert-position",
     "translatedTitle": "搜索插入位置"
    },
    "rawMemory": "9636000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/search-insert-position/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这个是对的。",
     "flagType": "RED"
    },
    "timestamp": 1644263071,
    "totalTestCaseCnt": 64
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func searchInsert(nums []int, target int) int {\n    j, k := 0, len(nums)-1\n    for j \u003c= k {\n        m := j + (k - j)/2\n        if nums[m] == target {\n            return m\n        } else if nums[m] \u003c target {\n            j = m + 1\n        } else {\n            k = m - 1\n        }\n    }\n    return j;\n}",
    "id": "262384716",
    "lang": "golang",
    "memory": "2.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 64,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "35",
     "title": "Search Insert Position",
     "titleSlug": "search-insert-position",
     "translatedTitle": "搜索插入位置"
    },
    "rawMemory": "2896000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/search-insert-position/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643129196,
    "totalTestCaseCnt": 64
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -\u003e int:\n        i, j = 0, len(nums)\n        while i \u003c j:\n            m = (i + j)//2\n            if nums[m] \u003c target:\n                i = m + 1\n            else:\n                j = m\n        \n        return i",
    "id": "262386862",
    "lang": "python3",
    "memory": "15.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 64,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "35",
     "title": "Search Insert Position",
     "titleSlug": "search-insert-position",
     "translatedTitle": "搜索插入位置"
    },
    "rawMemory": "16088000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/search-insert-position/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643130427,
    "totalTestCaseCnt": 64
   }
  },
  "second-highest-salary": {
   "mysql": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Write your MySQL query statement below\nselect (select DISTINCT  Salary from Employee ORDER BY Salary DESC limit 1, 1) as SecondHighestSalary;",
    "id": "10335866",
    "lang": "mysql",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 7,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "176",
     "title": "Second Highest Salary",
     "titleSlug": "second-highest-salary",
     "translatedTitle": "第二高的薪水"
    },
    "rawMemory": "N/A",
    "runtime": "191 ms",
    "sourceUrl": "/problems/second-highest-salary/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544458946,
    "totalTestCaseCnt": 7
   }
  },
  "second-minimum-node-in-a-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findSecondMinimumValue(TreeNode* root) {\n        int second = -1;\n        std::function\u003cvoid(TreeNode*)\u003e dfs = [\u0026](TreeNode* node) {\n            if (node == nullptr) {\n                return;\n            }\n            if (second != -1 \u0026\u0026 second \u003c= node-\u003eval) {\n                return;\n            }\n            if (node-\u003eval \u003e root-\u003eval) {\n                second = node-\u003eval;\n            }\n\n            dfs(node-\u003eleft);\n            dfs(node-\u003eright);\n        };\n        dfs(root);\n        return second;\n    }\n};\n",
    "id": "263722889",
    "lang": "cpp",
    "memory": "6.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 39,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "671",
     "title": "Second Minimum Node In a Binary Tree",
     "titleSlug": "second-minimum-node-in-a-binary-tree",
     "translatedTitle": "二叉树中第二小的节点"
    },
    "rawMemory": "6936000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/second-minimum-node-in-a-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "okk",
     "flagType": "RED"
    },
    "timestamp": 1643527341,
    "totalTestCaseCnt": 39
   }
  },
  "serialize-and-deserialize-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    void serializeTree(TreeNode* root, ostringstream\u0026 out) {\n        if (root == nullptr) {\n            out \u003c\u003c \"null \";\n            return;\n        }\n        out \u003c\u003c std::to_string(root-\u003eval) \u003c\u003c \" \";\n        serializeTree(root-\u003eleft, out);\n        serializeTree(root-\u003eright, out);\n    };\n    \n    TreeNode* deserializeTree(istringstream\u0026 in) {\n        string str;\n        in \u003e\u003e str;\n        if (str == \"null\") return nullptr;\n        TreeNode* node = new TreeNode(stoi(str));\n        node-\u003eleft = deserializeTree(in);\n        node-\u003eright = deserializeTree(in);\n        return node;\n    };\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        ostringstream out_stream;\n        serializeTree(root, out_stream);\n        return out_stream.str();\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        istringstream in(data);\n        return deserializeTree(in);\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));",
    "id": "265621209",
    "lang": "cpp",
    "memory": "30.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 52,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "297",
     "title": "Serialize and Deserialize Binary Tree",
     "titleSlug": "serialize-and-deserialize-binary-tree",
     "translatedTitle": "二叉树的序列化与反序列化"
    },
    "rawMemory": "31388000",
    "runtime": "48 ms",
    "sourceUrl": "/problems/serialize-and-deserialize-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "前序遍历。istringstream 和 ostringstream ",
     "flagType": "GREEN"
    },
    "timestamp": 1644240707,
    "totalTestCaseCnt": 52
   }
  },
  "set-matrix-zeroes": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void setZeroes(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) {\n        int m = matrix.size(), n = matrix.front().size();\n        vector\u003cpair\u003cint,int\u003e\u003e zeroPoints;\n        for (int i = 0; i \u003c m; i++) {\n            for (int j = 0; j \u003c n; j++) {\n                if (matrix[i][j] == 0) {\n                    zeroPoints.push_back({i, j});\n                }\n            }\n        }\n        for (auto \u0026p : zeroPoints) {\n            for (int i = 0; i \u003c m; i++) {\n                for (int j = 0; j \u003c n; j++) {\n                    if (i == p.first || j == p.second) {\n                        matrix[i][j] = 0;\n                    }\n                }\n            }\n        }\n    }\n};",
    "id": "275603293",
    "lang": "cpp",
    "memory": "12.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 164,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "73",
     "title": "Set Matrix Zeroes",
     "titleSlug": "set-matrix-zeroes",
     "translatedTitle": "矩阵置零"
    },
    "rawMemory": "13192000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/set-matrix-zeroes/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646146588,
    "totalTestCaseCnt": 164
   }
  },
  "shan-chu-lian-biao-de-jie-dian-lcof": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* deleteNode(struct ListNode* head, int val){\n    struct ListNode dummy = {.next = head};\n    struct ListNode* prev = \u0026dummy;\n    while (head) {\n        if (head-\u003eval == val) {\n            prev-\u003enext = head-\u003enext;\n            free(head);\n            head = prev-\u003enext;\n        } else {\n            prev = head;\n            head = head-\u003enext;\n        }\n    }\n    return dummy.next;\n}",
    "id": "264820302",
    "lang": "c",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 37,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100299",
     "title": "删除链表的节点 LCOF",
     "titleSlug": "shan-chu-lian-biao-de-jie-dian-lcof",
     "translatedTitle": "删除链表的节点"
    },
    "rawMemory": "6160000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/shan-chu-lian-biao-de-jie-dian-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "秒杀吗",
     "flagType": "RED"
    },
    "timestamp": 1643995157,
    "totalTestCaseCnt": 37
   }
  },
  "shu-zu-zhong-zhong-fu-de-shu-zi-lcof": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "int findRepeatNumber(int* nums, int numsSize){\n    for (int i = 0; i \u003c numsSize; i++) {\n        int idx = nums[i] % numsSize;\n        if (nums[idx] \u003e= numsSize) {\n            return idx;\n        }\n        nums[idx] += numsSize;\n    }\n    return -1;\n}",
    "id": "197327905",
    "lang": "c",
    "memory": "10.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100275",
     "title": "数组中重复的数字 LCOF",
     "titleSlug": "shu-zu-zhong-zhong-fu-de-shu-zi-lcof",
     "translatedTitle": "数组中重复的数字"
    },
    "rawMemory": "10392000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626671865,
    "totalTestCaseCnt": 25
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int findRepeatNumber(vector\u003cint\u003e\u0026 nums) {\n        auto len = nums.size();\n        for (auto i = 0; i \u003c len; i++) {\n            auto idx = nums[i] % len;\n            if (nums[idx] \u003e= len ) {\n                return idx;\n            }\n            nums[idx] += len;\n        }\n        return -1;\n    }\n};",
    "id": "197325010",
    "lang": "cpp",
    "memory": "22.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100275",
     "title": "数组中重复的数字 LCOF",
     "titleSlug": "shu-zu-zhong-zhong-fu-de-shu-zi-lcof",
     "translatedTitle": "数组中重复的数字"
    },
    "rawMemory": "22880000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626670948,
    "totalTestCaseCnt": 25
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func findRepeatNumber(nums []int) int {\n    seen := make(map[int]struct{})\n    for _, n := range nums {\n        if _, e := seen[n]; e {\n            return n\n        }\n        seen[n] = struct{}{}\n    }\n    return -1\n}",
    "id": "197326965",
    "lang": "golang",
    "memory": "8.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100275",
     "title": "数组中重复的数字 LCOF",
     "titleSlug": "shu-zu-zhong-zhong-fu-de-shu-zi-lcof",
     "translatedTitle": "数组中重复的数字"
    },
    "rawMemory": "8620000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626671577,
    "totalTestCaseCnt": 25
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def findRepeatNumber(self, nums: List[int]) -\u003e int:\n        seen = set()\n        for n in nums:\n            if n in seen:\n                return n\n            seen.add(n)\n        return -1",
    "id": "197327415",
    "lang": "python3",
    "memory": "23.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100275",
     "title": "数组中重复的数字 LCOF",
     "titleSlug": "shu-zu-zhong-zhong-fu-de-shu-zi-lcof",
     "translatedTitle": "数组中重复的数字"
    },
    "rawMemory": "24024000",
    "runtime": "36 ms",
    "sourceUrl": "/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626671719,
    "totalTestCaseCnt": 25
   }
  },
  "simplify-path": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cstring\u003e split(const string \u0026s, char delim) {\n        string item;\n        stringstream ss(s);\n        vector\u003cstring\u003e elems;\n        while (getline(ss, item, delim)) {\n            if (item == \"\" || item == \".\") {\n                continue;\n            } else if (item == \"..\") {\n                if (elems.size() \u003e 0)\n                    elems.pop_back();\n            } else {\n                elems.push_back(item);\n            }\n        }\n        return elems;\n    }\n\n\n    string simplifyPath(string path) {\n        string result;\n        vector\u003cstring\u003e elems = split(path, '/');\n\n        for (int i = elems.size() - 1; i \u003e= 0; i--) {\n            if (result.size() == 0) {\n                result = \"/\" + elems[i];\n            } else {\n                result = \"/\" + elems[i] + result;\n            }\n        }\n\n        return result.size() ? result : \"/\";\n    }\n};",
    "id": "10335664",
    "lang": "cpp",
    "memory": "1.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 252,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "71",
     "title": "Simplify Path",
     "titleSlug": "simplify-path",
     "translatedTitle": "简化路径"
    },
    "rawMemory": "1871872",
    "runtime": "8 ms",
    "sourceUrl": "/problems/simplify-path/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544458093,
    "totalTestCaseCnt": 257
   }
  },
  "single-element-in-a-sorted-array": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int singleNonDuplicate(vector\u003cint\u003e\u0026 nums) {\n        int lo = 0, hi = nums.size()-1;\n        while (lo \u003c hi) {\n            int mid = (lo + hi) \u003e\u003e 1;\n            if (mid % 2) mid--;\n            if (nums[mid] == nums[mid + 1]) {\n                lo += 2;\n            } else {\n                hi = mid;\n            }\n        }\n        return nums[hi];\n    }\n};",
    "id": "268016299",
    "lang": "cpp",
    "memory": "21.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 15,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "540",
     "title": "Single Element in a Sorted Array",
     "titleSlug": "single-element-in-a-sorted-array",
     "translatedTitle": "有序数组中的单一元素"
    },
    "rawMemory": "22416000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/single-element-in-a-sorted-array/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "二分查找",
     "flagType": "RED"
    },
    "timestamp": 1644774565,
    "totalTestCaseCnt": 14
   }
  },
  "single-number": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int singleNumber(vector\u003cint\u003e\u0026 nums) {\n        int yh = 0;\n        int i = 0;\n        for (; i + 3 \u003c nums.size(); i += 4) {\n            yh ^= nums[i];\n            yh ^= nums[i+1];\n            yh ^= nums[i+2];\n            yh ^= nums[i+3];\n        }\n\n        for (; i \u003c nums.size(); i++) {\n            yh ^= nums[i];\n        }\n        return yh;\n    }\n};",
    "id": "262396509",
    "lang": "cpp",
    "memory": "16.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "136",
     "title": "Single Number",
     "titleSlug": "single-number",
     "translatedTitle": "只出现一次的数字"
    },
    "rawMemory": "16764000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/single-number/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "异或",
     "flagType": "RED"
    },
    "timestamp": 1643143015,
    "totalTestCaseCnt": 61
   }
  },
  "sliding-window-maximum": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e maxSlidingWindow(vector\u003cint\u003e\u0026 nums, int k) {\n        priority_queue\u003cstd::pair\u003cint, int\u003e\u003e pq;\n        for (int i = 0; i \u003c k; i++) {\n            pq.push({nums[i], i});\n        }\n        vector\u003cint\u003e res = {pq.top().first};\n\n        // [l, r] window\n        int l = 1, r = k;\n        while (r \u003c nums.size()) {\n            while (!pq.empty() \u0026\u0026 pq.top().second \u003c l) {\n                pq.pop();\n            }\n            pq.push({nums[r], r});\n            res.push_back(pq.top().first);\n            l++;\n            r++;\n        }\n        return res;\n    }\n};",
    "id": "261304824",
    "lang": "cpp",
    "memory": "142.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 61,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "239",
     "title": "Sliding Window Maximum",
     "titleSlug": "sliding-window-maximum",
     "translatedTitle": "滑动窗口最大值"
    },
    "rawMemory": "145572000",
    "runtime": "252 ms",
    "sourceUrl": "/problems/sliding-window-maximum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1642855672,
    "totalTestCaseCnt": 61
   }
  },
  "sort-array-by-parity": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e sortArrayByParity(vector\u003cint\u003e\u0026 nums) {\n        int j = 0;\n        for (int i = 0; i \u003c nums.size(); i++) {\n            if (nums[i] % 2 == 0) {\n                swap(nums[i], nums[j++]);\n            }\n        }\n        return nums;\n    }\n};",
    "id": "264963706",
    "lang": "cpp",
    "memory": "15.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 285,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "941",
     "title": "Sort Array By Parity",
     "titleSlug": "sort-array-by-parity",
     "translatedTitle": "按奇偶排序数组"
    },
    "rawMemory": "16152000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/sort-array-by-parity/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644056561,
    "totalTestCaseCnt": 285
   },
   "java": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\n    public int[] sortArrayByParity(int[] A) {\n        int i = 0, j = A.length - 1;\n        while (i \u003c j) {\n            if (A[i] % 2 \u003e A[j] % 2) {\n                int tmp = A[i];\n                A[i] = A[j];\n                A[j] = tmp;\n            }\n\n            if (A[i] % 2 == 0) i++;\n            if (A[j] % 2 == 1) j--;\n        }\n\n        return A;\n    }\n}\n",
    "id": "264896723",
    "lang": "java",
    "memory": "41.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 285,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "941",
     "title": "Sort Array By Parity",
     "titleSlug": "sort-array-by-parity",
     "translatedTitle": "按奇偶排序数组"
    },
    "rawMemory": "42752000",
    "runtime": "1 ms",
    "sourceUrl": "/problems/sort-array-by-parity/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644042327,
    "totalTestCaseCnt": 285
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def sortArrayByParity(self, nums: List[int]) -\u003e List[int]:\n        j = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                j += 1\n        return nums",
    "id": "264903942",
    "lang": "python3",
    "memory": "15.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 285,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "941",
     "title": "Sort Array By Parity",
     "titleSlug": "sort-array-by-parity",
     "translatedTitle": "按奇偶排序数组"
    },
    "rawMemory": "16044000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/sort-array-by-parity/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644043977,
    "totalTestCaseCnt": 285
   }
  },
  "sort-characters-by-frequency": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string frequencySort(string s) {\n        unordered_map\u003cchar, int\u003e cmap;\n        for (auto \u0026c : s) {\n            cmap[c]++; \n        }\n        priority_queue\u003c pair\u003cint, char\u003e \u003e pq; \n        for (auto \u0026it :cmap) {\n            pq.push(make_pair(it.second, it.first));\n        }\n        string res;\n        while (pq.size() \u003e 0) {\n            auto top = pq.top();\n            res.append(top.first, top.second);\n            pq.pop();\n        }\n        return res;\n    }\n};",
    "id": "196830617",
    "lang": "cpp",
    "memory": "8.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 32,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "451",
     "title": "Sort Characters By Frequency",
     "titleSlug": "sort-characters-by-frequency",
     "translatedTitle": "根据字符出现频率排序"
    },
    "rawMemory": "8520000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/sort-characters-by-frequency/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626526021,
    "totalTestCaseCnt": 33
   }
  },
  "sort-colors": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void sortColors(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cint\u003e cnt(3);\n        for (int i = 0; i \u003c nums.size(); i++) {\n            cnt[nums[i]]++;\n        }\n\n        int k = 0;\n        for (int i = 0; i \u003c 3; i++) {\n            for (int j = 0; j \u003c cnt[i]; j++) {\n                nums[k++] = i;\n            }\n        }\n    }\n};",
    "id": "9834548",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 87,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "75",
     "title": "Sort Colors",
     "titleSlug": "sort-colors",
     "translatedTitle": "颜色分类"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/sort-colors/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543323821,
    "totalTestCaseCnt": 87
   }
  },
  "sort-list": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        return sortList(head, nullptr);\n    }\n\n    ListNode* sortList(ListNode* head, ListNode* tail) {\n        if (head == NULL) {\n            return head;\n        }\n        if (head-\u003enext == tail) {\n            // set to nullptr\n            head-\u003enext = nullptr;\n            return head;\n        }\n        ListNode *fast = head, *slow = head;\n        while (fast != tail \u0026\u0026 fast-\u003enext != tail) {\n            fast = fast-\u003enext-\u003enext;\n            slow = slow-\u003enext;\n        }\n\n        auto l1 = sortList(head, slow);\n        auto l2 = sortList(slow, tail);\n        return merge(l1, l2);\n    }\n\n    ListNode* merge(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* l3 = \u0026dummy;\n        while (l1 \u0026\u0026 l2) {\n            if (l1-\u003eval \u003e l2-\u003eval) {\n                l3-\u003enext = l2;\n                l2 = l2-\u003enext;\n            } else {\n                l3-\u003enext = l1;\n                l1 = l1-\u003enext;\n            }\n            l3 = l3-\u003enext;\n        }\n        if (l1) {\n            l3-\u003enext = l1;\n        } else {\n            l3-\u003enext = l2;\n        }\n\n        return dummy.next;\n    }\n};",
    "id": "264595130",
    "lang": "cpp",
    "memory": "28.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "148",
     "title": "Sort List",
     "titleSlug": "sort-list",
     "translatedTitle": "排序链表"
    },
    "rawMemory": "29048000",
    "runtime": "60 ms",
    "sourceUrl": "/problems/sort-list/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "可以。\n归并排序要注意，把 head-\u003enext 设置为 null。",
     "flagType": "RED"
    },
    "timestamp": 1643911060,
    "totalTestCaseCnt": 28
   }
  },
  "spiral-matrix": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e spiralOrder(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) {\n        int up = 0, down = matrix.size() - 1;\n        int left = 0, right = matrix.front().size() - 1;\n        vector\u003cint\u003e res;\n        for (;;) {\n            for (int i = left; i \u003c= right; i++) res.push_back(matrix[up][i]);\n            if (++up \u003e down) break;\n            \n            for (int i = up; i \u003c= down;i++) res.push_back(matrix[i][right]);\n            if (--right \u003c left) break;\n            \n            for (int i = right; i \u003e= left; i--) res.push_back(matrix[down][i]);\n            if (--down \u003c up) break;\n            \n            for (int i = down; i \u003e= up; i--) res.push_back(matrix[i][left]);\n            if (++left \u003e right) break;\n        }\n        return res;\n    }\n};",
    "id": "266199990",
    "lang": "cpp",
    "memory": "6.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 23,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "54",
     "title": "Spiral Matrix",
     "titleSlug": "spiral-matrix",
     "translatedTitle": "螺旋矩阵"
    },
    "rawMemory": "6872000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/spiral-matrix/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "容易出错啊。",
     "flagType": "ORANGE"
    },
    "timestamp": 1644388709,
    "totalTestCaseCnt": 23
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -\u003e List[int]:\n        res = []\n        while matrix:\n            res += matrix.pop(0)\n            # zip * 解包运算符. like zip(a, b)\n            matrix = list(zip(*matrix))[::-1]\n        return res",
    "id": "264332260",
    "lang": "python3",
    "memory": "15.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 23,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "54",
     "title": "Spiral Matrix",
     "titleSlug": "spiral-matrix",
     "translatedTitle": "螺旋矩阵"
    },
    "rawMemory": "15424000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/spiral-matrix/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643809491,
    "totalTestCaseCnt": 23
   }
  },
  "spiral-matrix-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e generateMatrix(int n) {\n        vector\u003cvector\u003cint\u003e\u003e res(n, vector\u003cint\u003e(n));\n        vector\u003cvector\u003cint\u003e\u003e directions = {{0, 1}, {1,0}, {0, -1}, {-1, 0}};\n        int curr = 1, total = n*n;\n\n        int i = 0, j = 0;\n        int directionIndex = 0;\n        while (curr \u003c= total) {\n            res[i][j] = curr++;\n    \n            int x = i + directions[directionIndex][0];\n            int y = j + directions[directionIndex][1];\n            if ((x == n ^ x \u003c 0) || (y == n ^ y \u003c 0) || res[x][y] != 0) {\n                directionIndex = ++directionIndex % 4;\n            }\n            i += directions[directionIndex][0];\n            j += directions[directionIndex][1];\n        }\n\n        return res;\n    }\n};",
    "id": "266239270",
    "lang": "cpp",
    "memory": "6.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 20,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "59",
     "title": "Spiral Matrix II",
     "titleSlug": "spiral-matrix-ii",
     "translatedTitle": "螺旋矩阵 II"
    },
    "rawMemory": "6676000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/spiral-matrix-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "模拟。",
     "flagType": "BLUE"
    },
    "timestamp": 1644393218,
    "totalTestCaseCnt": 20
   }
  },
  "split-linked-list-in-parts": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector\u003cListNode*\u003e splitListToParts(ListNode* head, int k) {\n        vector\u003cListNode*\u003e res(k);\n        if (head == nullptr) return res;\n        int llen = 0;\n        ListNode* curr = head;\n        while (curr) {\n            curr = curr-\u003enext;\n            llen++;\n        }\n        \n        ListNode* h = head;\n        int plen = llen / k, rlen = llen % k;\n        for (int i = 0; i \u003c k; i++) {\n            res[i] = h;\n            for (int j = 1; j \u003c plen +(i \u003crlen) \u0026\u0026 h; j++) {\n                h = h-\u003enext;\n            }\n            if (h == nullptr) break;\n            auto n = h-\u003enext;\n            h-\u003enext = nullptr;\n            h = n;\n        }\n        return res;\n    }\n};",
    "id": "264537973",
    "lang": "cpp",
    "memory": "8.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 43,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "725",
     "title": "Split Linked List in Parts",
     "titleSlug": "split-linked-list-in-parts",
     "translatedTitle": "分隔链表"
    },
    "rawMemory": "8748000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/split-linked-list-in-parts/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "ok",
     "flagType": "GREEN"
    },
    "timestamp": 1643893179,
    "totalTestCaseCnt": 43
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: ListNode, k: int) -\u003e List[ListNode]:\n        res = [None for _ in range(k)]\n        if head == None:\n            return res\n\n        list_len = 0\n        curr = head\n        while curr:\n            curr = curr.next\n            list_len += 1\n        psize = list_len // k\n        rsize = list_len % k\n\n        curr = head\n        for i in range(k):\n            if curr == None:\n                break\n\n            res[i] = curr        \n            j = 1\n            while j \u003c psize + (1 if i \u003c rsize else 0):\n                curr = curr.next\n                j += 1\n            \n            if curr:\n                next_node = curr.next\n                curr.next = None\n                curr = next_node\n        \n        return res",
    "id": "264479464",
    "lang": "python3",
    "memory": "15.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 43,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "725",
     "title": "Split Linked List in Parts",
     "titleSlug": "split-linked-list-in-parts",
     "translatedTitle": "分隔链表"
    },
    "rawMemory": "15796000",
    "runtime": "44 ms",
    "sourceUrl": "/problems/split-linked-list-in-parts/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "python ok",
     "flagType": "ORANGE"
    },
    "timestamp": 1643877008,
    "totalTestCaseCnt": 43
   }
  },
  "sqrtx": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x \u003c= 1) return x;\n        int l = 0, r = x;\n        while (l \u003c r) {\n            long long mid  = (l + r) / 2;\n            if (mid * mid \u003c= (long long)x) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return r-1;\n    }\n};",
    "id": "265721010",
    "lang": "cpp",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1017,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "69",
     "title": "Sqrt(x)",
     "titleSlug": "sqrtx",
     "translatedTitle": "x 的平方根 "
    },
    "rawMemory": "5996000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/sqrtx/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644286428,
    "totalTestCaseCnt": 1017
   }
  },
  "string-compression": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int compress(vector\u003cchar\u003e\u0026 chars) {\n        char prev = 0;\n        int cnt = 0;\n        int k = 0;\n        for (auto c : chars) {\n            if (c == prev) {\n                cnt++;\n            } else {\n                if (cnt \u003e 0) {\n                    string ss = to_string(cnt + 1);\n                    for (auto s : ss) {\n                        chars[k++] = s;\n                    }\n                }\n                chars[k++] = c;\n                cnt = 0;\n            }\n            prev = c;\n        }\n        if (cnt \u003e 0) {\n            string ss = to_string(cnt + 1);\n            for (auto s : ss) {\n                chars[k++] = s;\n            }\n        }      \n        return k;\n    }\n};",
    "id": "266443014",
    "lang": "cpp",
    "memory": "8.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 72,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "443",
     "title": "String Compression",
     "titleSlug": "string-compression",
     "translatedTitle": "压缩字符串"
    },
    "rawMemory": "9008000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/string-compression/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644422678,
    "totalTestCaseCnt": 72
   }
  },
  "string-to-integer-atoi": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        auto begin_pos = s.find_first_not_of(\" \\t\\n\\r\");\n        if (begin_pos == string::npos) return 0;\n\n        int neg = 1;\n        if (s[begin_pos] == '-') {\n            neg = -1;\n            begin_pos++;\n        } else if (s[begin_pos] == '+') {\n            neg = 1;\n            begin_pos++;\n        }\n\n        int ret = 0;\n        for (auto i = begin_pos; i \u003c s.size(); i++) {\n            int n = s[i];\n            if (n \u003c '0' || n \u003e '9') break;\n\n            if (ret \u003e INT_MAX / 10 || (ret == INT_MAX /10 \u0026\u0026 (n - '0') \u003e INT_MAX %10 )) return INT_MAX;\n            if (ret \u003c INT_MIN / 10 || (ret == INT_MIN /10 \u0026\u0026 ('0' - n) \u003c INT_MIN %10)) return INT_MIN;\n            \n            ret = ret * 10 + neg * (n - '0');\n        }\n\n        return ret;\n    }\n};",
    "id": "234509016",
    "lang": "cpp",
    "memory": "7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1082,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "8",
     "title": "String to Integer (atoi)",
     "titleSlug": "string-to-integer-atoi",
     "translatedTitle": "字符串转换整数 (atoi)"
    },
    "rawMemory": "7188000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/string-to-integer-atoi/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635777120,
    "totalTestCaseCnt": 1082
   }
  },
  "student-attendance-record-i": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool checkRecord(string s) {\n        int record[256] = {0, };\n\n        for (int i = 0; i \u003c s.size(); i++) {\n            char c = s[i];\n            record[c] += 1;\n            if (c == 'L') {\n                if (record[c] \u003e 2) return false;\n                if (c != s[i + 1]) record[c] = 0;\n            } else if (c == 'A') {\n                if (record[c] \u003e 1) return false;\n            }\n        }\n        return true;\n    }\n};",
    "id": "10501111",
    "lang": "cpp",
    "memory": "1.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 113,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "551",
     "title": "Student Attendance Record I",
     "titleSlug": "student-attendance-record-i",
     "translatedTitle": "学生出勤记录 I"
    },
    "rawMemory": "1298432",
    "runtime": "4 ms",
    "sourceUrl": "/problems/student-attendance-record-i/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544874299,
    "totalTestCaseCnt": 113
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func checkRecord(s string) bool {\n    l, a := 0, 0\n    for i := 0; i \u003c len(s); i++ {\n        if (s[i] == 'L') {\n            l += 1\n        } else if (s[i] == 'A') {\n            l = 0;\n            a += 1\n        } else {\n            l = 0;\n        }\n        \n        if l \u003e 2 || a \u003e 1 {\n            return false\n        }\n    }\n    return true\n}",
    "id": "10505039",
    "lang": "golang",
    "memory": "897 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 113,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "551",
     "title": "Student Attendance Record I",
     "titleSlug": "student-attendance-record-i",
     "translatedTitle": "学生出勤记录 I"
    },
    "rawMemory": "897024",
    "runtime": "0 ms",
    "sourceUrl": "/problems/student-attendance-record-i/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544882026,
    "totalTestCaseCnt": 113
   }
  },
  "subarray-sum-equals-k": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int subarraySum(vector\u003cint\u003e\u0026 nums, int k) {\n        unordered_map\u003cint,int\u003e map{{0, 1}};\n        int res = 0, sum = 0;\n        for (auto num : nums) {\n            sum += num;\n            auto it = map.find(sum - k);\n            if (it != map.end()) {\n                res += it-\u003esecond;\n            }\n            ++map[sum];\n        }\n        return res;   \n    }\n};",
    "id": "268256177",
    "lang": "cpp",
    "memory": "36.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 89,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "560",
     "title": "Subarray Sum Equals K",
     "titleSlug": "subarray-sum-equals-k",
     "translatedTitle": "和为 K 的子数组"
    },
    "rawMemory": "37060000",
    "runtime": "52 ms",
    "sourceUrl": "/problems/subarray-sum-equals-k/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "前缀和",
     "flagType": "BLUE"
    },
    "timestamp": 1644830993,
    "totalTestCaseCnt": 90
   }
  },
  "subdomain-visit-count": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    \n    vector\u003cstring\u003e subdomainVisits(vector\u003cstring\u003e\u0026 cpdomains) {\n        unordered_map\u003cstd::string, long\u003e domain_table;\n        for (auto\u0026 record : cpdomains) {\n            auto space_index = record.find(\" \");\n            long count = std::stol(record.substr(0, space_index));\n            std::string domain = record.substr(space_index + 1);\n            domain_table[domain] += count;\n            \n            size_t pos = std::string::npos;\n            while ((pos = domain.find(\".\")) != std::string::npos) {\n                std::string sub_domain = domain.substr(pos + 1);\n                domain = sub_domain;\n                domain_table[domain] += count;\n            }\n        }\n        \n        vector\u003cstring\u003e res;\n        for (auto\u0026 kv : domain_table) {\n            std::string r = std::to_string(kv.second) + \" \" + kv.first;\n            res.emplace_back(r);\n        }\n        return res;\n    }\n};",
    "id": "31917674",
    "lang": "cpp",
    "memory": "12.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 52,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "829",
     "title": "Subdomain Visit Count",
     "titleSlug": "subdomain-visit-count",
     "translatedTitle": "子域名访问计数"
    },
    "rawMemory": "13016000",
    "runtime": "20 ms",
    "sourceUrl": "/problems/subdomain-visit-count/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1570079303,
    "totalTestCaseCnt": 52
   }
  },
  "subsets": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e subsets(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cvector\u003cint\u003e\u003e res;\n        vector\u003cint\u003e one;\n        FindSubsets(nums, 0, one, res);\n        return res;\n    }\n\nprivate:\n    void FindSubsets(vector\u003cint\u003e\u0026 nums, int index, vector\u003cint\u003e\u0026 one, vector\u003cvector\u003cint\u003e\u003e\u0026 res) {\n        res.push_back(one);\n        for (int i = index; i \u003c nums.size(); i++) {\n            one.push_back(nums[i]);\n            FindSubsets(nums, i + 1, one, res);\n            one.pop_back();\n        }\n    }\n};",
    "id": "10704881",
    "lang": "cpp",
    "memory": "978.9 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 10,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "78",
     "title": "Subsets",
     "titleSlug": "subsets",
     "translatedTitle": "子集"
    },
    "rawMemory": "978944",
    "runtime": "4 ms",
    "sourceUrl": "/problems/subsets/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545317216,
    "totalTestCaseCnt": 10
   }
  },
  "subsets-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e subsetsWithDup(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cvector\u003cint\u003e\u003e res;\n        vector\u003cint\u003e tmp;\n        std::sort(nums.begin(), nums.end());\n        backtrace(res, 0, nums, tmp);\n        return res;          \n    }\n\n    void backtrace(vector\u003cvector\u003cint\u003e\u003e\u0026 res, int index, vector\u003cint\u003e\u0026 nums, vector\u003cint\u003e\u0026 tmp) {\n        res.push_back(tmp);\n        for (int i = index; i \u003c nums.size(); i++) {\n            tmp.push_back(nums[i]);\n            backtrace(res, i+1, nums, tmp);\n            tmp.pop_back();\n            while (i+1 \u003c nums.size() \u0026\u0026 nums[i] == nums[i+1]) i++;\n        }\n    }\n};",
    "id": "278130346",
    "lang": "cpp",
    "memory": "7.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 20,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "90",
     "title": "Subsets II",
     "titleSlug": "subsets-ii",
     "translatedTitle": "子集 II"
    },
    "rawMemory": "7272000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/subsets-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646539605,
    "totalTestCaseCnt": 20
   }
  },
  "sum-lists-lcci": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int add = 0, val1 = 0, val2 = 0;\n        ListNode dummy;\n        ListNode* l3 = \u0026dummy;\n        while (l1 || l2 || add) {\n            val1 = 0, val2 = 0;\n            if (l1) {\n                val1 = l1-\u003eval;\n                l1 = l1-\u003enext;\n            }\n            if (l2) {\n                val2 = l2-\u003eval;\n                l2 = l2-\u003enext;\n            }\n\n            add += val1 + val2;\n            l3-\u003enext = new ListNode(add %10), l3 = l3-\u003enext;\n            add /= 10;\n        }\n        return dummy.next;\n    }\n};",
    "id": "264576830",
    "lang": "cpp",
    "memory": "69.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1563,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100188",
     "title": "Sum Lists LCCI",
     "titleSlug": "sum-lists-lcci",
     "translatedTitle": "链表求和"
    },
    "rawMemory": "70976000",
    "runtime": "40 ms",
    "sourceUrl": "/problems/sum-lists-lcci/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1643902222,
    "totalTestCaseCnt": 1563
   }
  },
  "sum-of-square-numbers": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        int max = (int)sqrt(c) + 1;\n        for (int i = 0; i \u003c max; i++) {\n            int square = i*i;\n            int sub_sqrt = sqrt(c - square);\n            if (sub_sqrt*sub_sqrt + square == c) return true;\n        }\n        return false;\n    }\n};",
    "id": "10190256",
    "lang": "cpp",
    "memory": "1.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 124,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "633",
     "title": "Sum of Square Numbers",
     "titleSlug": "sum-of-square-numbers",
     "translatedTitle": "平方数之和"
    },
    "rawMemory": "1343488",
    "runtime": "8 ms",
    "sourceUrl": "/problems/sum-of-square-numbers/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544102792,
    "totalTestCaseCnt": 127
   }
  },
  "sum-of-two-integers": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int getSum(int a, int b) {\n        //使用符号了\n        //return a + b;\n        int sum = a;\n        while (b != 0) {\n            sum = a ^ b;//calculate sum of a and b without thinking the carry \n            b = (a \u0026 b) \u003c\u003c 1;//calculate the carry\n            a = sum;//add sum(without carry) and carry\n        }\n        return sum;\n    }\n};",
    "id": "8406896",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 13,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "371",
     "title": "Sum of Two Integers",
     "titleSlug": "sum-of-two-integers",
     "translatedTitle": "两整数之和"
    },
    "rawMemory": "N/A",
    "runtime": "0 ms",
    "sourceUrl": "/problems/sum-of-two-integers/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539849202,
    "totalTestCaseCnt": 25
   }
  },
  "sum-root-to-leaf-numbers": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nvoid sumNumbersDfs(struct TreeNode* root, int sumPrev, int *total) {\n    if (root == NULL) return;\n    int num = sumPrev*10 + root-\u003eval;\n    if (root-\u003eleft == NULL \u0026\u0026 root-\u003eright == NULL) {\n        *total += num;\n        return;\n    }\n    if (root-\u003eleft) sumNumbersDfs(root-\u003eleft, num, total);\n    if (root-\u003eright) sumNumbersDfs(root-\u003eright, num, total);\n}\n\nint sumNumbers(struct TreeNode* root){\n    int sum = 0;\n    sumNumbersDfs(root, 0, \u0026sum);\n    return sum;\n}",
    "id": "265300368",
    "lang": "c",
    "memory": "5.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 108,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "129",
     "title": "Sum Root to Leaf Numbers",
     "titleSlug": "sum-root-to-leaf-numbers",
     "translatedTitle": "求根节点到叶节点数字之和"
    },
    "rawMemory": "5892000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/sum-root-to-leaf-numbers/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644157187,
    "totalTestCaseCnt": 108
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\n\nfunc sumNumbers(root *TreeNode) int {\n    return helper(root, 0)\n}\n\nfunc helper(root *TreeNode, prev int) int {\n    if root == nil {\n        return 0\n    }\n    sum := 10*prev + root.Val\n    if root.Left == nil \u0026\u0026 root.Right == nil {\n        return sum\n    }\n    return helper(root.Left, sum) + helper(root.Right, sum)\n}",
    "id": "265299679",
    "lang": "golang",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 108,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "129",
     "title": "Sum Root to Leaf Numbers",
     "titleSlug": "sum-root-to-leaf-numbers",
     "translatedTitle": "求根节点到叶节点数字之和"
    },
    "rawMemory": "2056000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/sum-root-to-leaf-numbers/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "思路是：\n分治的思想。\n总和 = 左边和 + 右边和",
     "flagType": "BLUE"
    },
    "timestamp": 1644157043,
    "totalTestCaseCnt": 108
   }
  },
  "summary-ranges": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cstring\u003e summaryRanges(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cstring\u003e res;\n        if (nums.size() == 0) return res;\n\n        int left = 0;\n        for (int i = 0; i \u003c nums.size(); i++) {\n            if (i + 1 == nums.size() || nums[i] + 1 != nums[i+1]) {\n                string tmp_str;\n                if (i == left) {\n                    tmp_str = std::to_string(nums[i]); \n                } else {\n                    tmp_str = to_string(nums[left]) + \"-\u003e\" + to_string(nums[i]);\n                }\n                res.emplace_back(tmp_str);\n                left = i + 1;\n            }\n        }\n        return res;\n    }\n};",
    "id": "265686464",
    "lang": "cpp",
    "memory": "6.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 28,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "228",
     "title": "Summary Ranges",
     "titleSlug": "summary-ranges",
     "translatedTitle": "汇总区间"
    },
    "rawMemory": "6880000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/summary-ranges/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "代码的写法不错。",
     "flagType": "ORANGE"
    },
    "timestamp": 1644254985,
    "totalTestCaseCnt": 29
   }
  },
  "surrounded-regions": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void solve(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) {\n        int m = board.size(), n = board.front().size();\n        vector\u003cvector\u003cbool\u003e\u003e visO(m, vector(n, false));\n        queue\u003cpair\u003cint,int\u003e\u003e q;\n\n        function\u003cvoid(int, int)\u003e pushQ = [\u0026](int i, int j) {\n            if (i \u003e= 0 \u0026\u0026 i \u003c m \u0026\u0026 j \u003e=0 \u0026\u0026 j \u003c n \u0026\u0026 board[i][j] == 'O') {\n                q.push({i, j});\n            }\n        };\n\n        for (int i = 0; i \u003c m; i++) {\n            pushQ(i, 0), pushQ(i, n-1);\n        }\n        for (int i = 0; i \u003c n; i++) {\n            pushQ(0, i), pushQ(m-1, i);\n        }\n        \n        while (!q.empty()) {\n            int i = q.front().first, j = q.front().second; q.pop();\n            if (!visO[i][j]) {\n                visO[i][j] = true;\n                pushQ(i, j-1), pushQ(i-1, j), pushQ(i, j+1), pushQ(i+1, j);\n            }\n        }\n\n        for (int i = 0; i \u003c m; i++) {\n            for (int j = 0; j \u003c n; j++) {\n                if (board[i][j] == 'O' \u0026\u0026 !visO[i][j]) {\n                    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n};",
    "id": "267502854",
    "lang": "cpp",
    "memory": "10.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 58,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "130",
     "title": "Surrounded Regions",
     "titleSlug": "surrounded-regions",
     "translatedTitle": "被围绕的区域"
    },
    "rawMemory": "10372000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/surrounded-regions/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "bfs",
     "flagType": "BLUE"
    },
    "timestamp": 1644666023,
    "totalTestCaseCnt": 58
   }
  },
  "swap-nodes-in-pairs": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr) return nullptr;\n        ListNode dummy(0);\n        dummy.next = head;\n\n        ListNode* pre = \u0026dummy;\n        ListNode* curr = pre-\u003enext;\n        while (curr) {\n            ListNode* next = curr-\u003enext;\n            if (next) {\n                pre-\u003enext = next;\n                curr-\u003enext = next-\u003enext;\n                next-\u003enext = curr;\n\n                pre = curr;\n                curr = curr-\u003enext;\n            } else {\n                break;\n            }\n        }\n        return dummy.next;\n    }\n};",
    "id": "10356953",
    "lang": "cpp",
    "memory": "1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 55,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "24",
     "title": "Swap Nodes in Pairs",
     "titleSlug": "swap-nodes-in-pairs",
     "translatedTitle": "两两交换链表中的节点"
    },
    "rawMemory": "1044480",
    "runtime": "4 ms",
    "sourceUrl": "/problems/swap-nodes-in-pairs/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544518493,
    "totalTestCaseCnt": 55
   }
  },
  "symmetric-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {    \npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) {\n            return true;\n        }\n        return  issym(root-\u003eleft, root-\u003eright);\n    }\n    \nprivate:\n    bool issym(TreeNode* l, TreeNode* r) {\n        if (l == NULL \u0026\u0026 r == NULL) {\n            return true;\n        }\n        \n        if (l == NULL || r == NULL) {\n            return false;\n        }\n        \n        if (l-\u003eval == r-\u003eval) {\n            return issym(l-\u003eleft, r-\u003eright) \u0026\u0026 issym(l-\u003eright, r-\u003eleft);\n        } else {\n            return false;\n        }\n\n    }\n};",
    "id": "8465894",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 193,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "101",
     "title": "Symmetric Tree",
     "titleSlug": "symmetric-tree",
     "translatedTitle": "对称二叉树"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/symmetric-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539958097,
    "totalTestCaseCnt": 198
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSymmetric(root *TreeNode) bool {\n    if root == nil {\n        return true\n    }\n    return isSym(root.Left, root.Right)\n}\n\nfunc isSym(left, right *TreeNode) bool {\n    if left == nil \u0026\u0026 right ==  nil {\n        return true\n    } \n\n    if left == nil || right == nil  {\n        return false\n    }\n\n    if left.Val != right.Val {\n        return false\n    } else {\n        return isSym(left.Left, right.Right) \u0026\u0026 isSym(left.Right, right.Left)\n    }\n}",
    "id": "199060063",
    "lang": "golang",
    "memory": "2.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 197,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "101",
     "title": "Symmetric Tree",
     "titleSlug": "symmetric-tree",
     "translatedTitle": "对称二叉树"
    },
    "rawMemory": "2948000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/symmetric-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1627036782,
    "totalTestCaseCnt": 198
   }
  },
  "tenth-line": {
   "bash": {
    "__typename": "GeneralSubmissionNode",
    "code": "# Read from the file file.txt and output the tenth line to stdout.\nawk 'NR==10{print $0}' file.txt\n\n",
    "id": "11362321",
    "lang": "bash",
    "memory": "27.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 7,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "195",
     "title": "Tenth Line",
     "titleSlug": "tenth-line",
     "translatedTitle": "第十行"
    },
    "rawMemory": "28299264",
    "runtime": "8 ms",
    "sourceUrl": "/problems/tenth-line/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1546876361,
    "totalTestCaseCnt": 7
   }
  },
  "the-dining-philosophers": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class DiningPhilosophers {\npublic:\n    DiningPhilosophers() {\n    }\n    \n    void wantsToEat(int philosopher,\n                    function\u003cvoid()\u003e pickLeftFork,\n                    function\u003cvoid()\u003e pickRightFork,\n                    function\u003cvoid()\u003e eat,\n                    function\u003cvoid()\u003e putLeftFork,\n                    function\u003cvoid()\u003e putRightFork) {\n\n        int l = philosopher, r = (philosopher + 1) % 5;\n        if (philosopher %2 == 0){\n            lock[r].lock();\n            lock[l].lock();\n            pickLeftFork();\n            pickRightFork();\n        } else {\n            lock[l].lock();\n            lock[r].lock();\n            pickLeftFork();\n            pickRightFork();\n        }\n        \n        eat();\n        putLeftFork();\n        putRightFork();\n        lock[l].unlock();\n        lock[r].unlock();\n    }\nprivate:\n    std::mutex lock[5];\n};\n",
    "id": "266783742",
    "lang": "cpp",
    "memory": "10.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 24,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1340",
     "title": "The Dining Philosophers",
     "titleSlug": "the-dining-philosophers",
     "translatedTitle": "哲学家进餐"
    },
    "rawMemory": "11108000",
    "runtime": "204 ms",
    "sourceUrl": "/problems/the-dining-philosophers/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644497559,
    "totalTestCaseCnt": 24
   }
  },
  "ti-huan-kong-ge-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string replaceSpace(string s) {\n        int cnt = 0, len = s.size();\n        for (auto \u0026c : s) {\n            if (c == ' ') {\n                cnt++;\n            }\n        }\n        s.resize(len + 2*cnt);\n        for (int i = s.size() - 1, j = len - 1;  i != j; i--, j-- ) {\n            if (s[j] != ' ') {\n                s[i] = s[j];\n            } else {\n                s[i] = '0';\n                s[i - 1] = '2';\n                s[i - 2] = '%';\n                i -= 2;\n            }\n        }\n\n        return s;\n    }\n};",
    "id": "198900610",
    "lang": "cpp",
    "memory": "6.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 27,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100280",
     "title": "替换空格 LCOF",
     "titleSlug": "ti-huan-kong-ge-lcof",
     "translatedTitle": "替换空格"
    },
    "rawMemory": "6240000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/ti-huan-kong-ge-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1627015186,
    "totalTestCaseCnt": 27
   }
  },
  "to-lower-case": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    string toLowerCase(string str) {\n        for (auto \u0026c : str) {\n            c = tolower(c);\n        }\n        return str;\n    }\n};",
    "id": "8384709",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 8,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "742",
     "title": "To Lower Case",
     "titleSlug": "to-lower-case",
     "translatedTitle": "转换成小写字母"
    },
    "rawMemory": "N/A",
    "runtime": "8 ms",
    "sourceUrl": "/problems/to-lower-case/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1539788597,
    "totalTestCaseCnt": 114
   }
  },
  "top-k-frequent-elements": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void qsort(vector\u003cpair\u003cint, int\u003e\u003e\u0026 v, int start, int end, vector\u003cint\u003e\u0026 ret, int k) {\n        int picked = rand() % (end - start + 1) + start;\n        swap(v[picked], v[start]);\n\n        int pivot = v[start].second;\n        int index = start;\n        for (int i = start + 1; i \u003c= end; i++) {\n            if (v[i].second \u003e= pivot) {\n                swap(v[++index], v[i]);\n            }\n        }\n        swap(v[start], v[index]);\n\n        if (k \u003c= index - start) {\n            // have TOP(index-start+1), big then K\n            qsort(v, start, index - 1, ret, k);\n        } else {\n            // have TOP(index-start+1), but small than K, take them all\n            for (int i = start; i \u003c= index; i++) {\n                ret.push_back(v[i].first);\n            }\n            if (k \u003e index - start + 1) {\n                qsort(v, index + 1, end, ret, k - (index - start + 1));\n            }\n        }\n    }\n\n    vector\u003cint\u003e topKFrequent(vector\u003cint\u003e\u0026 nums, int k) {\n        unordered_map\u003cint, int\u003e freqs;\n        for (auto\u0026 v: nums) {\n            freqs[v]++;\n        }\n\n        vector\u003cint\u003e ret;\n        vector\u003cpair\u003cint, int\u003e\u003e values(freqs.begin(), freqs.end());\n        qsort(values, 0, values.size() - 1, ret, k);\n        return ret;\n    }\n};\n",
    "id": "265315252",
    "lang": "cpp",
    "memory": "13.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "347",
     "title": "Top K Frequent Elements",
     "titleSlug": "top-k-frequent-elements",
     "translatedTitle": "前 K 个高频元素"
    },
    "rawMemory": "13448000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/top-k-frequent-elements/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "快排后的 L，R  边界问题有点难\n",
     "flagType": "BLUE"
    },
    "timestamp": 1644160607,
    "totalTestCaseCnt": 21
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func topKFrequent(nums []int, k int) []int {\n\tvar res []int\n\tpq := PriorityQueue{}\n\theap.Init(\u0026pq)\n\n\tm := make(map[int]int)\n\tfor _, n := range nums {\n\t\tm[n]++\n\t}\n\n\tfor k, v := range m {\n\t\theap.Push(\u0026pq, \u0026Item{\n\t\t\tkey:   k,\n\t\t\tvalue: v,\n\t\t})\n\t}\n\n\tfor len(res) != k {\n\t\tt := heap.Pop(\u0026pq)\n\t\tif t == nil {\n\t\t\tbreak\n\t\t}\n\t\titem := t.(*Item)\n\t\tres = append(res, item.key)\n\t}\n\treturn res\n}\n\ntype Item struct {\n\tkey   int\n\tvalue int\n}\n\n// PriorityQueue 实现堆接口\ntype PriorityQueue []*Item\n\nfunc (p *PriorityQueue) Push(x interface{}) {\n\t*p = append(*p, x.(*Item))\n}\n\nfunc (p *PriorityQueue) Pop() interface{} {\n\tl := len(*p)\n\tif l == 0 {\n\t\treturn nil\n\t}\n\titem := (*p)[l-1]\n\t*p = (*p)[:l-1]\n\treturn item\n}\n\nfunc (p PriorityQueue) Len() int {\n\treturn len(p)\n}\n\nfunc (p PriorityQueue) Swap(i, j int) {\n\tp[i], p[j] = p[j], p[i]\n}\n\nfunc (p PriorityQueue) Less(i, j int) bool {\n\treturn p[i].value \u003e p[j].value\n}\n",
    "id": "179221370",
    "lang": "golang",
    "memory": "5.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 21,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "347",
     "title": "Top K Frequent Elements",
     "titleSlug": "top-k-frequent-elements",
     "translatedTitle": "前 K 个高频元素"
    },
    "rawMemory": "5580000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/top-k-frequent-elements/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "heap",
     "flagType": "RED"
    },
    "timestamp": 1621491535,
    "totalTestCaseCnt": 21
   }
  },
  "top-k-frequent-words": {
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "// 升序\nfunc insertSortAppend(array []string, key string) []string {\n\tarray = append(array, key)\n\tfor i := 0; i \u003c len(array)-1; i++ {\n\t\tif array[i] \u003e key {\n\t\t\tfor j := len(array) - 1; j != i; j-- {\n\t\t\t\tarray[j] = array[j-1]\n\t\t\t}\n\t\t\tarray[i] = key\n\t\t\treturn array\n\t\t}\n\t}\n\treturn array\n}\n\nfunc topKFrequent(words []string, k int) []string {\n\tvar res []string\n\twordsLen := len(words)\n\tif wordsLen == 0 {\n\t\treturn res\n\t}\n\tm := make(map[string]int)\n\tb := make([][]string, wordsLen + 1)\n\tfor _, w := range words {\n\t\tm[w]++\n\t}\n\n\tfor k, v := range m {\n\t\tb[v] = insertSortAppend(b[v], k)\n\t}\n\n\tfor i := wordsLen; i != 0; i-- {\n\t\tfor _, word := range b[i] {\n\t\t\tres = append(res, word)\n\t\t\tif len(res) == k {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n",
    "id": "179237844",
    "lang": "golang",
    "memory": "4.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 110,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "692",
     "title": "Top K Frequent Words",
     "titleSlug": "top-k-frequent-words",
     "translatedTitle": "前K个高频单词"
    },
    "rawMemory": "4772000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/top-k-frequent-words/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621494524,
    "totalTestCaseCnt": 110
   }
  },
  "traffic-light-controlled-intersection": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class TrafficLight {\npublic:\n    TrafficLight() {\n      road1_is_green_ = true;\n    }\n\n    void carArrived(\n        int carId,                   // ID of the car\n        int roadId,                  // ID of the road the car travels on. Can be 1 (road A) or 2 (road B)\n        int direction,               // Direction of the car\n        function\u003cvoid()\u003e turnGreen,  // Use turnGreen() to turn light to green on current road\n        function\u003cvoid()\u003e crossCar    // Use crossCar() to make car cross the intersection\n    ) {\n        if (road1_is_green_ ^ (roadId == 2)) {\n          crossCar();\n        } else {\n          std::unique_lock\u003cstd::mutex\u003e lk(mu_);\n          road1_is_green_ = !road1_is_green_;\n          turnGreen();\n          lk.unlock();\n          crossCar();\n        }\n    }\nprivate:\n  bool road1_is_green_;\n  std::mutex mu_;\n};",
    "id": "266891607",
    "lang": "cpp",
    "memory": "8.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 14,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1410",
     "title": "Traffic Light Controlled Intersection",
     "titleSlug": "traffic-light-controlled-intersection",
     "translatedTitle": "红绿灯路口"
    },
    "rawMemory": "9064000",
    "runtime": "124 ms",
    "sourceUrl": "/problems/traffic-light-controlled-intersection/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644521915,
    "totalTestCaseCnt": 14
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class TrafficLight:\n    def __init__(self):\n        from threading import Lock\n        self.lock = Lock()\n        self.green_road_id = 1\n\n    def carArrived(\n        self,\n        carId: int,                      # ID of the car\n        roadId: int,                     # ID of the road the car travels on. Can be 1 (road A) or 2 (road B)\n        direction: int,                  # Direction of the car\n        turnGreen: 'Callable[[], None]', # Use turnGreen() to turn light to green on current road\n        crossCar: 'Callable[[], None]'   # Use crossCar() to make car cross the intersection\n    ) -\u003e None:\n        \n        if self.green_road_id == roadId:\n          crossCar()\n        else:\n          self.lock.acquire()\n          self.green_road_id = roadId\n          turnGreen()\n          crossCar()\n          self.lock.release()",
    "id": "266891886",
    "lang": "python3",
    "memory": "16 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 14,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1410",
     "title": "Traffic Light Controlled Intersection",
     "titleSlug": "traffic-light-controlled-intersection",
     "translatedTitle": "红绿灯路口"
    },
    "rawMemory": "16360000",
    "runtime": "48 ms",
    "sourceUrl": "/problems/traffic-light-controlled-intersection/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "python3.  add lock",
     "flagType": "BLUE"
    },
    "timestamp": 1644522665,
    "totalTestCaseCnt": 14
   }
  },
  "transpose-matrix": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e transpose(vector\u003cvector\u003cint\u003e\u003e\u0026 A) {\n        int row_num = A.size();\n        int col_num = A[0].size();\n        vector\u003cvector\u003cint\u003e\u003e T(col_num);\n\n        for (int i = 0; i \u003c row_num; i++) {\n            for (int j = 0; j \u003c col_num; j++) {\n                T[j].push_back(A[i][j]);\n            }\n        }\n        return T;\n    }\n};",
    "id": "9698520",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "898",
     "title": "Transpose Matrix",
     "titleSlug": "transpose-matrix",
     "translatedTitle": "转置矩阵"
    },
    "rawMemory": "N/A",
    "runtime": "24 ms",
    "sourceUrl": "/problems/transpose-matrix/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1542968786,
    "totalTestCaseCnt": 36
   }
  },
  "trapping-rain-water": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int trap(vector\u003cint\u003e\u0026 height) {\n        int left = 0, right = height.size()-1;\n        int maxLeft = height[0];\n        int maxRight = height[height.size()-1];\n\n        int res = 0;\n        while (left \u003c right) {\n            maxLeft = std::max(maxLeft, height[left]);\n            maxRight = std::max(maxRight, height[right]);\n            if (height[left] \u003c height[right]) {\n                res += maxLeft - height[left];\n                left++;\n            } else {\n                res += maxRight - height[right];\n                right--;\n            }\n        }\n        return res;\n    }\n};",
    "id": "262267433",
    "lang": "cpp",
    "memory": "15.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 320,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "42",
     "title": "Trapping Rain Water",
     "titleSlug": "trapping-rain-water",
     "translatedTitle": "接雨水"
    },
    "rawMemory": "15548000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/trapping-rain-water/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "双指针\n是动态优化方法的优化。",
     "flagType": "RED"
    },
    "timestamp": 1643103626,
    "totalTestCaseCnt": 320
   }
  },
  "triangle": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int minimumTotal(vector\u003cvector\u003cint\u003e\u003e\u0026 triangle) {\n//         int n = triangle.size();\n//         for(int i = 1 ; i \u003c n ; i ++){\n\n//             triangle[i][0] += triangle[i-1][0];\n//             triangle[i][i] += triangle[i-1][i-1];\n//             for(int j = 1 ; j \u003c i ; j ++)\n//                 triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]);\n//         }\n//         return *min_element(triangle[n-1].begin(), triangle[n-1].end());\n        \n        vector\u003cint\u003e res(triangle.size(), triangle[0][0]);\n        for (unsigned int i = 1; i \u003c triangle.size(); i++) \n            for (int j = i; j \u003e= 0; j--) {\n                if (j == 0)\n                    res[0] += triangle[i][j];\n                else if (j == i)\n                    res[j] = triangle[i][j] + res[j-1];\n                else \n                    res[j] = triangle[i][j] + min(res[j-1], res[j]);\n            }\n        return *min_element(res.begin(), res.end());\n    }\n};",
    "id": "8606860",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 43,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "120",
     "title": "Triangle",
     "titleSlug": "triangle",
     "translatedTitle": "三角形最小路径和"
    },
    "rawMemory": "N/A",
    "runtime": "4 ms",
    "sourceUrl": "/problems/triangle/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1540306673,
    "totalTestCaseCnt": 44
   }
  },
  "two-sum": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) {\n        unordered_map\u003cint, int\u003e seen;\n        for (int i = 0; i \u003c nums.size(); i++) {\n            auto it = seen.find(target - nums[i]);\n            if (it != seen.end()) {\n                return {it-\u003esecond, i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {-1, -1};\n    }\n};",
    "id": "266258614",
    "lang": "cpp",
    "memory": "10.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 57,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1",
     "title": "Two Sum",
     "titleSlug": "two-sum",
     "translatedTitle": "两数之和"
    },
    "rawMemory": "10736000",
    "runtime": "12 ms",
    "sourceUrl": "/problems/two-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644395191,
    "totalTestCaseCnt": 57
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func twoSum(nums []int, target int) []int {\n    seen := make(map[int]int)\n    for i, num := range nums {\n        if val, e := seen[target - num]; e {\n            return []int{val, i}\n        }\n        seen[num] = i\n    }\n    return []int{-1, -1}\n}",
    "id": "266263577",
    "lang": "golang",
    "memory": "4.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 57,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1",
     "title": "Two Sum",
     "titleSlug": "two-sum",
     "translatedTitle": "两数之和"
    },
    "rawMemory": "4216000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/two-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644395749,
    "totalTestCaseCnt": 57
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        check_dict = dict()\n        for i, n in enumerate(nums):\n            c = target - n\n            if c in check_dict:\n                return [check_dict[c], i]\n            check_dict[n] = i",
    "id": "232131131",
    "lang": "python3",
    "memory": "15.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 55,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1",
     "title": "Two Sum",
     "titleSlug": "two-sum",
     "translatedTitle": "两数之和"
    },
    "rawMemory": "16272000",
    "runtime": "24 ms",
    "sourceUrl": "/problems/two-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1635141801,
    "totalTestCaseCnt": 57
   },
   "rust": {
    "__typename": "GeneralSubmissionNode",
    "code": "\nuse std::collections::HashMap;\n\nimpl Solution {\n    pub fn two_sum(nums: Vec\u003ci32\u003e, target: i32) -\u003e Vec\u003ci32\u003e {\n        let mut seen: HashMap\u003ci32 ,i32\u003e = HashMap::new();\n        for (i, v) in nums.iter().enumerate() {\n            match seen.get(v) {\n                Some(index) =\u003e {\n                    return vec![*index, i as i32];\n                }\n                None =\u003e {\n                    seen.insert(target - v, i as i32); \n                }\n            }\n        }\n        vec![]\n    }\n}",
    "id": "294909022",
    "lang": "rust",
    "memory": "2.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 57,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1",
     "title": "Two Sum",
     "titleSlug": "two-sum",
     "translatedTitle": "两数之和"
    },
    "rawMemory": "2544000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/two-sum/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1649102210,
    "totalTestCaseCnt": 57
   }
  },
  "two-sum-ii-input-array-is-sorted": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 numbers, int target) {\n        int l = 0, r = numbers.size() - 1;\n        if (numbers.size() \u003c 2) return {};\n        while (l \u003c r) {\n            if (numbers[l] + numbers[r] == target) {\n                return {l + 1, r + 1};\n            } else if (numbers[l] + numbers[r] \u003e target) {\n                r--;\n            } else {\n                l++;\n            }\n        }\n        return {};\n    }\n};",
    "id": "10651335",
    "lang": "cpp",
    "memory": "1.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 17,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "167",
     "title": "Two Sum II - Input Array Is Sorted",
     "titleSlug": "two-sum-ii-input-array-is-sorted",
     "translatedTitle": "两数之和 II - 输入有序数组"
    },
    "rawMemory": "1654784",
    "runtime": "4 ms",
    "sourceUrl": "/problems/two-sum-ii-input-array-is-sorted/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545222460,
    "totalTestCaseCnt": 21
   }
  },
  "two-sum-iv-input-is-a-bst": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool findTarget(TreeNode* root, int k) {\n        unordered_set\u003cint\u003e seen;\n        return preorderFind(root, k, seen);\n    }\n    \n    bool preorderFind(TreeNode* root, int k, unordered_set\u003cint\u003e\u0026 seen) {\n        if (root == NULL) {\n            return false;\n        }\n        if (seen.find(k - root-\u003eval) != seen.end()) {\n            return true;\n        }\n        seen.insert(root-\u003eval);\n        return preorderFind(root-\u003eleft, k, seen) || preorderFind(root-\u003eright, k, seen);\n    }\n};",
    "id": "10651967",
    "lang": "cpp",
    "memory": "3.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 421,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "653",
     "title": "Two Sum IV - Input is a BST",
     "titleSlug": "two-sum-iv-input-is-a-bst",
     "translatedTitle": "两数之和 IV - 输入 BST"
    },
    "rawMemory": "3657728",
    "runtime": "32 ms",
    "sourceUrl": "/problems/two-sum-iv-input-is-a-bst/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545223046,
    "totalTestCaseCnt": 422
   }
  },
  "two-sum-less-than-k": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int twoSumLessThanK(vector\u003cint\u003e\u0026 nums, int k) {\n        int res = -1;\n        for (int i = 0; i \u003c nums.size(); i++) {\n            for (int j = i + 1; j \u003c nums.size(); j++) {\n                int tmp = nums[i] + nums[j];\n                if (tmp \u003c k) {\n                    res = max(res, tmp);\n                }\n            }\n        }\n        return res;\n    }\n};",
    "id": "265667310",
    "lang": "cpp",
    "memory": "8.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 125,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1083",
     "title": "Two Sum Less Than K",
     "titleSlug": "two-sum-less-than-k",
     "translatedTitle": "小于 K 的两数之和"
    },
    "rawMemory": "9016000",
    "runtime": "8 ms",
    "sourceUrl": "/problems/two-sum-less-than-k/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1644248175,
    "totalTestCaseCnt": 125
   }
  },
  "ugly-number": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isUgly(int num) {\n        if (num \u003c 1) return false;\n            while (num %2 == 0) num \u003e\u003e= 1;\n            while (num%3 == 0) num /= 3;\n            while (num%5 == 0 ) num /= 5;\n        return num == 1;\n    }\n};",
    "id": "10577759",
    "lang": "cpp",
    "memory": "827.4 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1012,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "263",
     "title": "Ugly Number",
     "titleSlug": "ugly-number",
     "translatedTitle": "丑数"
    },
    "rawMemory": "827392",
    "runtime": "4 ms",
    "sourceUrl": "/problems/ugly-number/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545069923,
    "totalTestCaseCnt": 1013
   }
  },
  "ugly-number-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector\u003cint\u003e res(1, 1);\n        int i2 = 0, i3 = 0, i5 = 0;\n        while (res.size() \u003c n) {\n            int m2 = res[i2] * 2, m3 = res[i3] * 3, m5 = res[i5] * 5;\n            int mn = min(m2, min(m3, m5));\n            if (mn == m2) ++i2;\n            if (mn == m3) ++i3;\n            if (mn == m5) ++i5;\n            res.push_back(mn);\n        }\n        return res.back();\n    }\n};",
    "id": "10618186",
    "lang": "cpp",
    "memory": "831.5 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 596,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "264",
     "title": "Ugly Number II",
     "titleSlug": "ugly-number-ii",
     "translatedTitle": "丑数 II"
    },
    "rawMemory": "831488",
    "runtime": "4 ms",
    "sourceUrl": "/problems/ugly-number-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1545150981,
    "totalTestCaseCnt": 596
   }
  },
  "unique-binary-search-trees": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector\u003cint\u003e g(n+1);\n        g[0] = 1, g[1] = 1;\n        // [1 .... n], g(i) \n        // f(i,n) = g(i - 1) * g(n - i), i is root\n        // g(n) = \\sum\\limits_{i=1}^{n} f(i, n) \n        for (int i = 2; i \u003c= n; i++) {\n            for (int j = 1; j \u003c= i; j++) {\n                g[i] += g[j - 1] * g[i - j];\n            }\n        }\n\n        return g[n];\n    }\n};",
    "id": "263849439",
    "lang": "cpp",
    "memory": "6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 19,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "96",
     "title": "Unique Binary Search Trees",
     "titleSlug": "unique-binary-search-trees",
     "translatedTitle": "不同的二叉搜索树"
    },
    "rawMemory": "6096000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/unique-binary-search-trees/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "动态规划问题。",
     "flagType": "RED"
    },
    "timestamp": 1643565042,
    "totalTestCaseCnt": 19
   }
  },
  "unique-email-addresses": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int numUniqueEmails(vector\u003cstring\u003e\u0026 emails) {\n        unordered_set\u003cstring\u003e rd;\n        for (string email : emails) {\n            auto at = email.find(\"@\");\n            if (at == string::npos) {\n                continue;\n            }\n            string name = email.substr(0, at);\n            auto plus = name.find('+');\n            if (plus != string::npos) {\n                name = name.substr(0, plus);\n            }\n            string res = \"\";\n            for (char c: name)\n                if (c != '.')\n                    res += c;\n            res += email.substr(at);\n            rd.insert(res);\n        }\n        return rd.size();\n    }\n};",
    "id": "10384017",
    "lang": "cpp",
    "memory": "1.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 173,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "965",
     "title": "Unique Email Addresses",
     "titleSlug": "unique-email-addresses",
     "translatedTitle": "独特的电子邮件地址"
    },
    "rawMemory": "1556480",
    "runtime": "28 ms",
    "sourceUrl": "/problems/unique-email-addresses/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544589437,
    "totalTestCaseCnt": 185
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func numUniqueEmails(emails []string) int {\n\tseen := make(map[string]bool)\n\tfor _, email := range emails {\n\t\tcomp := strings.Split(email, \"@\")\n\t\tif len(comp) == 2 {\n\t\t\tcomp[0] = strings.Split(comp[0], \"+\")[0]\n\t\t\tcomp[0] = strings.Replace(comp[0], \".\", \"\", -1)\n\t\t\tfinalEmail := strings.Join(comp, \"@\")\n\t\t\tfmt.Println(finalEmail)\n\t\t\tseen[finalEmail] = true\n\t\t}\n\t}\n\treturn len(seen)\n}",
    "id": "10389733",
    "lang": "golang",
    "memory": "5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 173,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "965",
     "title": "Unique Email Addresses",
     "titleSlug": "unique-email-addresses",
     "translatedTitle": "独特的电子邮件地址"
    },
    "rawMemory": "5083136",
    "runtime": "36 ms",
    "sourceUrl": "/problems/unique-email-addresses/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544599678,
    "totalTestCaseCnt": 185
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def numUniqueEmails(self, emails):\n        \"\"\"\n        :type emails: List[str]\n        :rtype: int\n        \"\"\"\n        seen = set()\n        for email in emails:\n            sep = email.split(\"@\")\n            sep[0] = sep[0].split(\"+\")[0]\n            sep[0] = sep[0].replace(\".\", \"\")\n\n            seen.add(\"@\".join(sep))\n        return len(seen)",
    "id": "10390589",
    "lang": "python3",
    "memory": "7.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 173,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "965",
     "title": "Unique Email Addresses",
     "titleSlug": "unique-email-addresses",
     "translatedTitle": "独特的电子邮件地址"
    },
    "rawMemory": "7376896",
    "runtime": "60 ms",
    "sourceUrl": "/problems/unique-email-addresses/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544600611,
    "totalTestCaseCnt": 185
   }
  },
  "unique-morse-code-words": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int uniqueMorseRepresentations(vector\u003cstring\u003e\u0026 words) {\n        string morse_code[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n        unordered_set\u003cstring\u003e unique_ms;\n        for (string\u0026 word : words) {\n            string morse_string = \"\";\n            for (int i = 0; i \u003c word.size(); i++) {\n                morse_string += morse_code[word[i] - 'a'];\n            }\n            unique_ms.insert(morse_string);\n        }\n        \n        return unique_ms.size();\n    }\n};",
    "id": "10491829",
    "lang": "cpp",
    "memory": "1.2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 83,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "822",
     "title": "Unique Morse Code Words",
     "titleSlug": "unique-morse-code-words",
     "translatedTitle": "唯一摩尔斯密码词"
    },
    "rawMemory": "1191936",
    "runtime": "4 ms",
    "sourceUrl": "/problems/unique-morse-code-words/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544854983,
    "totalTestCaseCnt": 82
   }
  },
  "unique-paths": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    //n行， m列\n    int uniquePaths(int m, int n) {\n        vector\u003cvector\u003cint\u003e\u003e paths;\n        vector\u003cint\u003e row(m + 1, 1);\n        for (int i = 0; i \u003c= n; i++) {\n            paths.push_back(row);\n        }\n\n        for (int i = 2; i \u003c= n; i++) {\n            for (int j = 2; j \u003c=m; j++) {\n                paths[i][j] = paths[i][j - 1] + paths[i - 1][j];\n            }\n        }\n        return paths[n][m];\n    }\n};",
    "id": "10331258",
    "lang": "cpp",
    "memory": "843.8 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 62,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "62",
     "title": "Unique Paths",
     "titleSlug": "unique-paths",
     "translatedTitle": "不同路径"
    },
    "rawMemory": "843776",
    "runtime": "0 ms",
    "sourceUrl": "/problems/unique-paths/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544450760,
    "totalTestCaseCnt": 62
   }
  },
  "unique-paths-ii": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector\u003cvector\u003cint\u003e\u003e \u0026obstacleGrid) {\n        int m = obstacleGrid.size();\n        if (!m) return 0;\n\n        int n = obstacleGrid[0].size();\n        if (!n || obstacleGrid[0][0])\n            return 0;\n\n        vector\u003cvector\u003cint\u003e\u003e dp(m, vector\u003cint\u003e(n, -1));\n        dp[0][0] = 1;\n        for (int j = 1; j \u003c n; j++)\n            if (obstacleGrid[0][j])\n                dp[0][j] = 0;\n            else\n                dp[0][j] = dp[0][j - 1];\n\n        for (int i = 1; i \u003c m; i++)\n            if (obstacleGrid[i][0])\n                dp[i][0] = 0;\n            else\n                dp[i][0] = dp[i - 1][0];\n\n        for (int i = 1; i \u003c m; i++)\n            for (int j = 1; j \u003c n; j++)\n                if (obstacleGrid[i][j])\n                    dp[i][j] = 0;\n                else\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        return dp[m - 1][n - 1];\n    }\n};\n",
    "id": "10333836",
    "lang": "cpp",
    "memory": "892.9 KB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 43,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "63",
     "title": "Unique Paths II",
     "titleSlug": "unique-paths-ii",
     "translatedTitle": "不同路径 II"
    },
    "rawMemory": "892928",
    "runtime": "0 ms",
    "sourceUrl": "/problems/unique-paths-ii/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544454283,
    "totalTestCaseCnt": 41
   }
  },
  "univalued-binary-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isUnivalTree(TreeNode* root) {\n        if (root == nullptr) {\n            return true;\n        }\n        std::stack\u003cTreeNode*\u003e stk;\n        int target = root-\u003eval;\n        while (root || !stk.empty()) {\n            while (root) {\n                stk.push(root);\n                root = root-\u003eleft;\n            }\n            root = stk.top();\n            stk.pop();\n            if (root-\u003eval != target) {\n                return false;\n            }\n            root = root-\u003eright;\n        }\n        return true;\n    }\n};",
    "id": "275408391",
    "lang": "cpp",
    "memory": "9.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 72,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1005",
     "title": "Univalued Binary Tree",
     "titleSlug": "univalued-binary-tree",
     "translatedTitle": "单值二叉树"
    },
    "rawMemory": "9840000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/univalued-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646128606,
    "totalTestCaseCnt": 72
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isUnivalTree(root *TreeNode) bool {\n    if root == nil {\n        return true\n    }\n    return dfsCheck(root, root.Val)\n}\n\nfunc dfsCheck(root *TreeNode, val int) bool {\n    if root == nil {\n        return true\n    }\n    if root.Val != val {\n        return false\n    }\n    return dfsCheck(root.Left, val) \u0026\u0026 dfsCheck(root.Right, val)\n}",
    "id": "275420581",
    "lang": "golang",
    "memory": "2.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 72,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1005",
     "title": "Univalued Binary Tree",
     "titleSlug": "univalued-binary-tree",
     "translatedTitle": "单值二叉树"
    },
    "rawMemory": "2200000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/univalued-binary-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646130325,
    "totalTestCaseCnt": 72
   }
  },
  "utf-8-validation": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "\nclass Solution {\npublic:\n\n    \n\nbool validUtf8(vector\u003cint\u003e\u0026 data) {\nint i = 0;\n  while (i \u003c data.size()) {\n    if ((data[i] \u0026 0x80) == 0){\n      i++;\n      continue;\n    }\n    \n    int len = 0;\n    if ((data[i] \u0026 0xE0) == 0xC0 ) { // checking 110xxxxx\n      len = 2;\n    }else if ( (data[i] \u0026 0xF0) == 0xE0) { // checking 1110xxxx\n      len = 3;\n    }else if ( (data[i] \u0026 0xF8) == 0xF0) { // checking 11110xxx\n      len = 4;\n    }else {\n      return false;\n    }\n    \n    for (int j = i + 1; j \u003c i + len; j++) { //checking 10xxxxxx\n      if (j \u003e= data.size()) {\n        return false;\n      }\n      if ((data[j] \u0026 0xC0) != 0x80) {\n        return false;\n      }\n    }\n    i += len;\n  }\n  return true;\n}\n};",
    "id": "33285232",
    "lang": "cpp",
    "memory": "9.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 49,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "393",
     "title": "UTF-8 Validation",
     "titleSlug": "utf-8-validation",
     "translatedTitle": "UTF-8 编码验证"
    },
    "rawMemory": "9480000",
    "runtime": "16 ms",
    "sourceUrl": "/problems/utf-8-validation/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1571216060,
    "totalTestCaseCnt": 49
   }
  },
  "valid-anagram": {
   "c": {
    "__typename": "GeneralSubmissionNode",
    "code": "bool is_all_zero(int *array, int len) {\n    for (int i = 0; i \u003c len; i++) {\n        if (array[i] != 0) return false;\n    }\n    return true;\n}\n\nbool isAnagram(char * s, char * t){\n    int find[256] = {0};\n    int s_len = 0, t_len = 0;\n\n    if (s == NULL || t == NULL)\n        return false;\n\n    while (*s != '\\0') {\n        find[*s++ - 'a']++;\n        s_len++;\n    }\n    while (*t != '\\0') {\n        find[*t++ - 'a']--;\n        t_len++;\n    } \n    return s_len == t_len \u0026\u0026 is_all_zero(find, 26);\n}",
    "id": "263596331",
    "lang": "c",
    "memory": "5.6 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "242",
     "title": "Valid Anagram",
     "titleSlug": "valid-anagram",
     "translatedTitle": "有效的字母异位词"
    },
    "rawMemory": "5772000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/valid-anagram/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "C",
     "flagType": "RED"
    },
    "timestamp": 1643479268,
    "totalTestCaseCnt": 36
   },
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int cnt[256] = {0,};\n\n        for (auto \u0026c : s) cnt[c]++;\n        for (auto \u0026c : t) cnt[c]--;\n        return all_of(cnt+'a', cnt+'z' + 1, [](int c){ return  c == 0; });\n    }\n};",
    "id": "263596023",
    "lang": "cpp",
    "memory": "7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "242",
     "title": "Valid Anagram",
     "titleSlug": "valid-anagram",
     "translatedTitle": "有效的字母异位词"
    },
    "rawMemory": "7212000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/valid-anagram/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "数组法。stl",
     "flagType": "RED"
    },
    "timestamp": 1643478830,
    "totalTestCaseCnt": 36
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func isAnagram(s string, t string) bool {\n    cntMap := make(map[rune]int)\n    if len(s) != len(t) {\n        return false\n    }\n\n    for _, c := range s {\n        cntMap[c]++\n    }\n\n    for _, c := range t {\n        cntMap[c]--\n    }\n\n    for _, v := range cntMap {\n        if v != 0 {\n            return false\n        }\n    }\n\n    return true\n}",
    "id": "196683412",
    "lang": "golang",
    "memory": "2.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 35,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "242",
     "title": "Valid Anagram",
     "titleSlug": "valid-anagram",
     "translatedTitle": "有效的字母异位词"
    },
    "rawMemory": "2828000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/valid-anagram/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626498311,
    "totalTestCaseCnt": 36
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def isAnagram(self, s: str, t: str) -\u003e bool:\n        return sorted(s) == sorted(t)",
    "id": "196675062",
    "lang": "python3",
    "memory": "15.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 35,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "242",
     "title": "Valid Anagram",
     "titleSlug": "valid-anagram",
     "translatedTitle": "有效的字母异位词"
    },
    "rawMemory": "16164000",
    "runtime": "32 ms",
    "sourceUrl": "/problems/valid-anagram/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626495632,
    "totalTestCaseCnt": 36
   }
  },
  "valid-palindrome": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int l = 0, r = s.size() - 1;\n        while (l \u003c r) {\n            if (!isalnum(s[l])) {\n                l++;\n                continue;\n            }\n\n            if (!isalnum(s[r])) {\n                r--;\n                continue;\n            }\n\n            if (toupper(s[l]) != toupper(s[r])) {\n                return false;\n            }\n            \n            l++;\n            r--;\n        }\n        return true;\n    }\n};",
    "id": "9875247",
    "lang": "cpp",
    "memory": "N/A",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 476,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "125",
     "title": "Valid Palindrome",
     "titleSlug": "valid-palindrome",
     "translatedTitle": "验证回文串"
    },
    "rawMemory": "N/A",
    "runtime": "8 ms",
    "sourceUrl": "/problems/valid-palindrome/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1543409562,
    "totalTestCaseCnt": 480
   }
  },
  "valid-parentheses": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        unordered_map\u003cint, int\u003e symbol_map = {\n                {'(', 1},\n                {')', -1},\n                {'[', 2},\n                {']', -2},\n                {'{', 3},\n                {'}', -3},\n        };\n        stack\u003cint\u003e s_stack;\n        for (auto c : s) {\n            int v = symbol_map[c];\n            if (v \u003e 0) {\n                s_stack.push(v);\n            } else if (v \u003c 0) {\n                if (s_stack.empty() || s_stack.top() != -v) {\n                    return false;\n                }\n                s_stack.pop();\n            }\n        }\n        if (!s_stack.empty()) return false;\n        return true;\n    }\n};",
    "id": "10349170",
    "lang": "cpp",
    "memory": "1.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 76,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "20",
     "title": "Valid Parentheses",
     "titleSlug": "valid-parentheses",
     "translatedTitle": "有效的括号"
    },
    "rawMemory": "1175552",
    "runtime": "4 ms",
    "sourceUrl": "/problems/valid-parentheses/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544510651,
    "totalTestCaseCnt": 91
   }
  },
  "valid-perfect-square": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool isPerfectSquare(int num) {\n        long square = 1, n = 1;\n        while (square \u003c= num) {\n            square = n*n;\n            if (square == num) return true;\n            n++;\n        }\n        return false;\n    }\n};",
    "id": "277890104",
    "lang": "cpp",
    "memory": "5.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "367",
     "title": "Valid Perfect Square",
     "titleSlug": "valid-perfect-square",
     "translatedTitle": "有效的完全平方数"
    },
    "rawMemory": "6012000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/valid-perfect-square/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646489662,
    "totalTestCaseCnt": 70
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func isPerfectSquare(num int) bool {\n    lo, hi := int64(0), int64(num)\n    var square int64 = 0 \n    for lo \u003c= hi {\n        mid := int64(lo + (hi - lo)/2)\n        square = mid * mid\n        if square \u003e int64(num) {\n            hi = mid -1\n        } else if square \u003c int64(num) {\n            lo = mid + 1\n        } else {\n            return true\n        }\n    }\n    return false\n}",
    "id": "277893509",
    "lang": "golang",
    "memory": "1.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 70,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "367",
     "title": "Valid Perfect Square",
     "titleSlug": "valid-perfect-square",
     "translatedTitle": "有效的完全平方数"
    },
    "rawMemory": "1892000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/valid-perfect-square/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646490025,
    "totalTestCaseCnt": 70
   }
  },
  "valid-square": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int Distance(vector\u003cint\u003e\u0026 x, vector\u003cint\u003e\u0026 y) {\n        int d = abs(x[0] - y[0])*abs(x[0] - y[0]) + \n                    abs(x[1] - y[1])*abs(x[1] - y[1]);\n        return d;\n    }\n    \n    bool validSquare(vector\u003cint\u003e\u0026 p1, vector\u003cint\u003e\u0026 p2, vector\u003cint\u003e\u0026 p3, vector\u003cint\u003e\u0026 p4) {\n        vector\u003cint\u003e d;\n        d.push_back(Distance(p1, p2));\n        d.push_back(Distance(p1, p3));\n        d.push_back(Distance(p1, p4));\n        d.push_back(Distance(p2, p3));\n        d.push_back(Distance(p2, p4));\n        d.push_back(Distance(p3, p4));\n        \n        sort(d.begin(), d.end());\n        for (int i = 1; i \u003c 4; i++) {\n             if (d[i - 1] != d[i]) return false;\n        }\n        \n        if (d[3] == d[4]) return false;\n        if (d[4] != d[5]) return false;\n        \n        return true;\n    }\n};",
    "id": "10319319",
    "lang": "cpp",
    "memory": "1.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 244,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "593",
     "title": "Valid Square",
     "titleSlug": "valid-square",
     "translatedTitle": "有效的正方形"
    },
    "rawMemory": "1826816",
    "runtime": "8 ms",
    "sourceUrl": "/problems/valid-square/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544433974,
    "totalTestCaseCnt": 253
   }
  },
  "validate-binary-search-tree": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    //中序遍历，从小到大排列\n    bool isValidBST(TreeNode* root) {\n        vector\u003cint\u003e v;\n        inorderVisit(root, v);\n        for (int i = 1; i \u003c v.size(); i++) {\n            if (v[i - 1] \u003e= v[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    void inorderVisit(TreeNode* root, vector\u003cint\u003e\u0026 v) {\n        if (root) {\n            inorderVisit(root-\u003eleft, v);\n            v.push_back(root-\u003eval);\n            inorderVisit(root-\u003eright, v);\n        }\n    }\n};",
    "id": "10431819",
    "lang": "cpp",
    "memory": "1.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 75,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "98",
     "title": "Validate Binary Search Tree",
     "titleSlug": "validate-binary-search-tree",
     "translatedTitle": "验证二叉搜索树"
    },
    "rawMemory": "1855488",
    "runtime": "8 ms",
    "sourceUrl": "/problems/validate-binary-search-tree/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1544688643,
    "totalTestCaseCnt": 80
   }
  },
  "validate-ip-address": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    void splitString(const string\u0026 str, vector\u003cstring\u003e\u0026 res, char delim=' ') {\n        istringstream in(str);\n        string line;\n        while (std::getline(in, line, delim)) {\n            res.emplace_back(line);\n        }\n        if (!str.empty() \u0026\u0026 str.back() == delim) {\n            res.push_back(\"\");\n        }\n    }\n\n    bool IsIPv4(const string\u0026 ip) {\n        vector\u003cstring\u003e digits;\n        splitString(ip, digits, '.');\n        if (digits.size() != 4) return false;\n        for (auto\u0026 d : digits) {\n            if (d.size() \u003e 1 \u0026\u0026 d[0] == '0') return false;\n            for (auto\u0026 c: d) {\n                if (!std::isdigit(c)) return false;\n            }\n            int n = stoi(d);\n            if (n \u003c 0 || n \u003e 255) return false;\n        }\n        return true;\n    }\n\n    bool IsIPv6(const string\u0026 ip) {\n        vector\u003cstring\u003e digits;\n        splitString(ip, digits, ':');\n        if (digits.size() != 8) return false;\n        for (auto\u0026 d : digits) {\n            if (d.size() \u003e 4 || d.size() == 0) return false;\n            for (auto\u0026 c : d) {\n                auto lower = tolower(c);\n                if (!isdigit(c) \u0026\u0026 !('a' \u003c= lower \u0026\u0026 lower \u003c= 'f' )) return false;\n            }\n        }\n        return true;\n    }\n\n    string validIPAddress(string queryIP) {\n        try {\n            if (IsIPv4(queryIP)) {\n                return \"IPv4\";\n            } else if (IsIPv6(queryIP)) {\n                return \"IPv6\";\n            }\n            \n        } catch (std::exception\u0026 e) {\n            return \"Neither\";\n        }\n        return \"Neither\";\n    }\n};",
    "id": "262603678",
    "lang": "cpp",
    "memory": "6.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 73,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "468",
     "title": "Validate IP Address",
     "titleSlug": "validate-ip-address",
     "translatedTitle": "验证IP地址"
    },
    "rawMemory": "6956000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/validate-ip-address/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OK。\n注意 getline 字符流分隔函数。\n注意要处理异常。",
     "flagType": "RED"
    },
    "timestamp": 1643193663,
    "totalTestCaseCnt": 73
   }
  },
  "video-stitching": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\r\npublic:\r\n    int videoStitching(vector\u003cvector\u003cint\u003e\u003e\u0026 clips, int time) {\r\n        vector\u003cint\u003e dp(time+1, time+1);\r\n        dp[0] = 0;\r\n\r\n        for (int i = 1; i \u003c= time; i++) {\r\n            for (auto \u0026clip : clips) {\r\n                if (clip[0] \u003c=i \u0026\u0026 i \u003c= clip[1]) {\r\n                    dp[i] = std::min(dp[i], dp[clip[0]] + 1);\r\n                }\r\n            }\r\n        }\r\n        return dp[time] == time+1 ? -1 : dp[time];\r\n    }\r\n};",
    "id": "193203197",
    "lang": "cpp",
    "memory": "7.7 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 60,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "1081",
     "title": "Video Stitching",
     "titleSlug": "video-stitching",
     "translatedTitle": "视频拼接"
    },
    "rawMemory": "7852000",
    "runtime": "4 ms",
    "sourceUrl": "/problems/video-stitching/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1625639990,
    "totalTestCaseCnt": 60
   }
  },
  "wildcard-matching": {
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        sn = len(s)\n        pn = len(p)\n        dp = [[False] * (pn + 1) for _ in range(sn + 1)]\n        dp[0][0] = True\n        for j in range(1, pn + 1):\n            if p[j - 1] == \"*\":\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, sn + 1):\n            for j in range(1, pn + 1):\n                if (s[i - 1] == p[j - 1] or p[j - 1] == \"?\"):\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == \"*\":\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n        return dp[-1][-1]",
    "id": "180214781",
    "lang": "python3",
    "memory": "22.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 1811,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "44",
     "title": "Wildcard Matching",
     "titleSlug": "wildcard-matching",
     "translatedTitle": "通配符匹配"
    },
    "rawMemory": "23456000",
    "runtime": "684 ms",
    "sourceUrl": "/problems/wildcard-matching/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1621783073,
    "totalTestCaseCnt": 1811
   }
  },
  "word-break": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector\u003cstring\u003e\u0026 wordDict) {\n        if (s.empty()) return false;\n        vector\u003cbool\u003e dp(s.size(), false);\n        dp[0] = true;\n\n        for(int i = 1; i \u003c= s.size(); i++) {\n            for (auto \u0026word : wordDict) {\n                auto wordLen = word.size();\n                if (i \u003e= wordLen \u0026\u0026 word == s.substr(i-wordLen, wordLen))\n                    dp[i] = dp[i] || dp[i - wordLen];\n            }\n        }\n        return dp[s.size()];\n    }\n};",
    "id": "261175173",
    "lang": "cpp",
    "memory": "7.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 45,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "139",
     "title": "Word Break",
     "titleSlug": "word-break",
     "translatedTitle": "单词拆分"
    },
    "rawMemory": "7584000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/word-break/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "OKK\n",
     "flagType": "RED"
    },
    "timestamp": 1642831723,
    "totalTestCaseCnt": 45
   }
  },
  "word-pattern": {
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "func wordPattern(pattern string, s string) bool {\n    words := strings.Fields(s)\n    if len(pattern) != len(words) {\n        return false\n    }\n    seen := make(map[byte]int)\n    seenWord := make(map[string]int)\n    for i := 0; i \u003c len(pattern); i++ {\n        if seen[pattern[i]] != seenWord[words[i]] {\n            return false\n        }\n        seen[pattern[i]] = i + 1\n        seenWord[words[i]] = i + 1\n    }\n    return true\n}",
    "id": "196764125",
    "lang": "golang",
    "memory": "2 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 36,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "290",
     "title": "Word Pattern",
     "titleSlug": "word-pattern",
     "translatedTitle": "单词规律"
    },
    "rawMemory": "2004000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/word-pattern/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626512123,
    "totalTestCaseCnt": 36
   }
  },
  "word-search": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    bool exist(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, string word) {\n        int m = board.size(), n = board[0].size();\n        for (int i = 0; i \u003c m; i++) {\n            for (int j = 0; j \u003c n; j++) {\n                // 每个点都可以\n                if (check(board, word, 0, i, j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    bool check(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, string\u0026 word, int index, int i, int j) {\n        if (word.size() == index) {\n            return true;\n        }\n        if (i \u003c 0 || j \u003c 0 || i == board.size() || j == board[0].size()) {\n            return false;\n        }\n\n        if (word[index] != board[i][j]) {\n            return false;\n        }\n        // 由于不能访问重复路径，过河拆桥\n        board[i][j] = 0;\n        bool res = check(board, word, index+1, i+1, j) ||\n                   check(board, word, index+1, i, j+1) ||\n                   check(board, word, index+1, i-1, j) ||\n                   check(board, word, index+1, i, j-1);      \n        board[i][j] = word[index];\n        return res;\n    }\n};",
    "id": "263995199",
    "lang": "cpp",
    "memory": "7.8 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 83,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "79",
     "title": "Word Search",
     "titleSlug": "word-search",
     "translatedTitle": "单词搜索"
    },
    "rawMemory": "7936000",
    "runtime": "184 ms",
    "sourceUrl": "/problems/word-search/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "回溯算法。",
     "flagType": "RED"
    },
    "timestamp": 1643647543,
    "totalTestCaseCnt": 83
   },
   "python3": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -\u003e bool:\n        m, n, word_len = len(board), len(board[0]), len(word)\n        def dfs(i, j, k):\n            if k == word_len:\n                return True\n            if not 0 \u003c= i \u003c m or not 0 \u003c= j \u003c n:\n                return False\n                \n            if word[k] != board[i][j]:\n                return False\n            board[i][j] = '*'\n\n            res = dfs(i-1, j, k+1) or dfs(i+1, j, k+1) or dfs(i, j-1, k+1) or dfs(i, j+1, k+1)\n            board[i][j] = word[k]\n            return res\n            \n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0):\n                    return True\n        return False",
    "id": "263997569",
    "lang": "python3",
    "memory": "15.1 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 83,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "79",
     "title": "Word Search",
     "titleSlug": "word-search",
     "translatedTitle": "单词搜索"
    },
    "rawMemory": "15464000",
    "runtime": "3136 ms",
    "sourceUrl": "/problems/word-search/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "注意比较运算符。",
     "flagType": "RED"
    },
    "timestamp": 1643650099,
    "totalTestCaseCnt": 83
   }
  },
  "xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    int minArray(vector\u003cint\u003e\u0026 numbers) {\n        int l = 0, r = numbers.size() - 1;\n        if (numbers.size() == 0) return -1;\n        // 二分查找\n        // 确定 target 为最右端 r\n        // [5,1,2,3,4]\n        // 如果 num[mid] \u003c num[r], 则 mid右边全部是有序的(可以用反证法证明), 在左侧找，r = mid\n        // 如果 num[mid] == num[r], 则 r = r - 1\n        // 如果 num[mid] \u003e num[r], 则 可以确定在 mid 右侧找， l = mid + 1\n\n        while (l \u003c= r) {\n            int mid = (r-l)/2 + l;\n            if (numbers[mid] \u003e numbers[r]) {\n                l = mid + 1;\n            } else if (numbers[mid] \u003c numbers[r]){\n                r = mid;\n            } else {\n                r = r - 1;\n            }\n        }\n\n        return numbers[l];\n    }\n};",
    "id": "257025751",
    "lang": "cpp",
    "memory": "11.9 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 192,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100278",
     "title": "旋转数组的最小数字  LCOF",
     "titleSlug": "xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof",
     "translatedTitle": "旋转数组的最小数字"
    },
    "rawMemory": "12152000",
    "runtime": "0 ms",
    "sourceUrl": "/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "二分",
     "flagType": "GREEN"
    },
    "timestamp": 1641815854,
    "totalTestCaseCnt": 192
   }
  },
  "yong-liang-ge-zhan-shi-xian-dui-lie-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class CQueue {\npublic:\n    CQueue() {\n\n    }\n    \n    void appendTail(int value) {\n        st1.push(value);\n    }\n    \n    int deleteHead() {\n        if (st2.empty()) {\n            while (!st1.empty()) {\n                st2.push(st1.top());\n                st1.pop();\n            }\n        }\n        if (st2.empty()) {\n            return -1;\n        }\n\n        int top = st2.top();\n        st2.pop();\n        return top;\n    }\nprivate:\n    stack\u003cint\u003e st1;\n    stack\u003cint\u003e st2;\n};\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue* obj = new CQueue();\n * obj-\u003eappendTail(value);\n * int param_2 = obj-\u003edeleteHead();\n */",
    "id": "293342053",
    "lang": "cpp",
    "memory": "101 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 55,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100273",
     "title": "用两个栈实现队列 LCOF",
     "titleSlug": "yong-liang-ge-zhan-shi-xian-dui-lie-lcof",
     "translatedTitle": "用两个栈实现队列"
    },
    "rawMemory": "103456000",
    "runtime": "268 ms",
    "sourceUrl": "/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1648819197,
    "totalTestCaseCnt": 55
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "type CQueue struct {\n    a []int\n    b []int\n}\n\n\nfunc Constructor() CQueue {\n    return CQueue{}\n}\n\n\nfunc (this *CQueue) AppendTail(value int)  {\n    this.a = append(this.a, value)\n}\n\n\nfunc (this *CQueue) DeleteHead() int {\n    bLen := len(this.b)\n    if len(this.a) + bLen == 0 {\n        return -1\n    }\n\n    if bLen == 0 {\n        bLen = len(this.a)\n        for i := bLen - 1; i \u003e= 0; i-- {\n            this.b = append(this.b, this.a[i])\n        }\n        this.a = this.a[:0]\n    }\n\n    res := this.b[bLen - 1]\n    this.b = this.b[:bLen - 1]\n    return res\n}\n\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.AppendTail(value);\n * param_2 := obj.DeleteHead();\n */",
    "id": "197558044",
    "lang": "golang",
    "memory": "8.4 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 55,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100273",
     "title": "用两个栈实现队列 LCOF",
     "titleSlug": "yong-liang-ge-zhan-shi-xian-dui-lie-lcof",
     "translatedTitle": "用两个栈实现队列"
    },
    "rawMemory": "8644000",
    "runtime": "200 ms",
    "sourceUrl": "/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1626704682,
    "totalTestCaseCnt": 55
   }
  },
  "zui-xiao-de-kge-shu-lcof": {
   "cpp": {
    "__typename": "GeneralSubmissionNode",
    "code": "class Solution {\npublic:\n    vector\u003cint\u003e getLeastNumbers(vector\u003cint\u003e\u0026 arr, int k) {\n        std::vector\u003cint\u003e res;\n        if (k == 0) return res;\n        std::priority_queue\u003cint, std::vector\u003cint\u003e, std::less\u003cint\u003e\u003e pq;\n\n        for (auto v : arr) {\n            if (pq.size() \u003c k) {\n                pq.push(v);\n            } else {\n                if (pq.top() \u003e v) {\n                    pq.pop();\n                    pq.push(v);\n                }\n            }\n        }\n        while (pq.size() \u003e 0) {\n            res.emplace_back(pq.top());\n            pq.pop();\n        }\n\n        return res;      \n    }\n};",
    "id": "276910925",
    "lang": "cpp",
    "memory": "19.3 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100301",
     "title": "最小的k个数  LCOF",
     "titleSlug": "zui-xiao-de-kge-shu-lcof",
     "translatedTitle": "最小的k个数"
    },
    "rawMemory": "19716000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/zui-xiao-de-kge-shu-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": null,
    "timestamp": 1646329339,
    "totalTestCaseCnt": 38
   },
   "golang": {
    "__typename": "GeneralSubmissionNode",
    "code": "\n// max heap\ntype Pq struct {\n    v []int\n}\n\nfunc NewPq(size int) *Pq {\n    return \u0026Pq{\n        v : make([]int, 1, size + 1),\n    }\n}\n\nfunc (p *Pq) shiftUp() {\n    cur := len(p.v) - 1\n    for {\n        if cur == 1 {\n            break\n        }\n\n        f := cur / 2\n        if (p.v[cur] \u003e p.v[f]) {\n            p.v[f], p.v[cur] = p.v[cur], p.v[f]\n            cur = f\n        } else {\n            break\n        }\n    }\n}\n\nfunc (p *Pq) shiftDown() {\n    p.v[1] = p.v[p.Size()]\n    p.v = p.v[0 : p.Size()]\n    curr := 1\n    for {\n        c := curr \u003c\u003c 1\n        if c \u003e= p.Size() {\n            break\n        }\n\n        if p.v[c] \u003c p.v[c + 1] {\n            c++\n        }\n\n        if p.v[curr] \u003c p.v[c] {\n            p.v[curr], p.v[c] = p.v[c], p.v[curr]\n            curr = c\n        } else {\n            break\n        }\n\n    }\n}\n\nfunc (p *Pq) Size() int {\n    return len(p.v) - 1\n}\n\nfunc (p *Pq) Push(k int) {\n    p.v = append(p.v, k)\n    p.shiftUp()\n}\n\nfunc (p *Pq) Pop() int {\n    v := p.Top()\n    p.shiftDown()\n    return v\n}\n\nfunc (p *Pq) Top() int {\n    return p.v[1]\n}\n\nfunc (q *Pq) Empty() bool {\n    return q.Size() == 0\n}\n\n\nfunc getLeastNumbers(arr []int, k int) []int {\n    res := make([]int, 0, k)\n    if k == 0 {\n        return []int{}\n    }\n    pq := NewPq(k)\n\n    for _, v := range arr {\n        if pq.Size() \u003c k {\n            pq.Push(v)\n        } else {\n            if v \u003c pq.Top() {\n                pq.Pop()\n                pq.Push(v)\n            }\n        } \n    }\n\n    for pq.Size() != 0 {\n        res = append(res, pq.Pop())\n    }\n\n    return res\n}",
    "id": "234822712",
    "lang": "golang",
    "memory": "6.5 MB",
    "outputDetail": {
     "__typename": "SubmissionOutputNode",
     "codeOutput": "",
     "compileError": "",
     "expectedOutput": "",
     "input": "",
     "lastTestcase": "",
     "runtimeError": ""
    },
    "passedTestCaseCnt": 38,
    "question": {
     "__typename": "QuestionNode",
     "questionId": "100301",
     "title": "最小的k个数  LCOF",
     "titleSlug": "zui-xiao-de-kge-shu-lcof",
     "translatedTitle": "最小的k个数"
    },
    "rawMemory": "6672000",
    "runtime": "28 ms",
    "sourceUrl": "/problems/zui-xiao-de-kge-shu-lcof/",
    "statusDisplay": "Accepted",
    "submissionComment": {
     "__typename": "SubmissionCommentNode",
     "comment": "这个堆实现的不错。",
     "flagType": "ORANGE"
    },
    "timestamp": 1635858146,
    "totalTestCaseCnt": 38
   }
  }
 }
}
